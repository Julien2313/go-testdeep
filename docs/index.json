[
{
	"uri": "https://go-testdeep.zetta.rocks/operators/matrix/",
	"title": "Operators matrices",
	"tags": [],
	"description": "",
	"content": " Operator → go type matrix    Operator vs go type nil bool string {u,}int* float* complex* array slice map struct pointer interface¹ chan func operator     All ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ All   Any ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ Any   Array ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✗ ✗ ✗ ptr on array ✓ ✗ ✗ Array   ArrayEach ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✓ ✗ ✗ ptr on array/slice ✓ ✗ ✗ ArrayEach   Bag ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✓ ✗ ✗ ptr on array/slice ✓ ✗ ✗ Bag   Between ✗ ✗ ✓ ✓ ✓ todo ✗ ✗ ✗ time.Time ✗ ✓ ✗ ✗ Between   Cap ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✓ ✗ ✗ ✗ ✓ ✓ ✗ Cap   Catch ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ Catch   Code ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ Code   Contains ✗ ✗ ✓ ✗ ✗ ✗ ✓ ✓ ✓ ✗ ✗ ✓ ✗ ✗ Contains       Operator vs go type nil bool string {u,}int* float* complex* array slice map struct pointer interface¹ chan func operator     ContainsKey ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✗ ✗ ✓ ✗ ✗ ContainsKey   Empty ✗ ✗ ✓ ✗ ✗ ✗ ✓ ✓ ✓ ✗ ptr on array/slice/map/string ✓ ✓ ✗ Empty   Gt ✗ ✗ ✓ ✓ ✓ todo ✗ ✗ ✗ time.Time ✗ ✓ ✗ ✗ Gt   Gte ✗ ✗ ✓ ✓ ✓ todo ✗ ✗ ✗ time.Time ✗ ✓ ✗ ✗ Gte   HasPrefix ✗ ✗ ✓ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✓ + fmt.Stringer/error ✗ ✗ HasPrefix   HasSuffix ✗ ✗ ✓ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✓ + fmt.Stringer/error ✗ ✗ HasSuffix   Ignore ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ Ignore   Isa ✗ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ Isa   JSON ✓ ✓ ✓ ✓ ✓ ✗ ✓ ✓ ✓ ✓ ✓ ✓ ✗ ✗ JSON   Keys ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✗ ✗ ✓ ✗ ✗ Keys       Operator vs go type nil bool string {u,}int* float* complex* array slice map struct pointer interface¹ chan func operator     Lax ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ Lax   Len ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✓ ✓ ✗ ✗ ✓ ✓ ✗ Len   Lt ✗ ✗ ✓ ✓ ✓ todo ✗ ✗ ✗ time.Time ✗ ✓ ✗ ✗ Lt   Lte ✗ ✗ ✓ ✓ ✓ todo ✗ ✗ ✗ time.Time ✗ ✓ ✗ ✗ Lte   Map ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✗ ptr on map ✓ ✗ ✗ Map   MapEach ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✗ ptr on map ✓ ✗ ✗ MapEach   N ✗ ✗ ✗ ✓ ✓ todo ✗ ✗ ✗ ✗ ✗ ✓ ✗ ✗ N   NaN ✗ ✗ ✗ ✗ ✓ ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✗ ✗ NaN   Nil ✓ ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✓ ✗ ✓ ✓ ✓ ✓ Nil   None ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ None       Operator vs go type nil bool string {u,}int* float* complex* array slice map struct pointer interface¹ chan func operator     Not ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ Not   NotAny ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✓ ✗ ✗ ptr on array/slice ✓ ✗ ✗ NotAny   NotEmpty ✗ ✗ ✓ ✗ ✗ ✗ ✓ ✓ ✓ ✗ ptr on array/slice/map/string ✓ ✓ ✗ NotEmpty   NotNaN ✗ ✗ ✗ ✗ ✓ ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✗ ✗ NotNaN   NotNil ✓ ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✓ ✗ ✓ ✓ ✓ ✓ NotNil   NotZero ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ NotZero   PPtr ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✓ ✗ ✗ PPtr   Ptr ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✓ ✗ ✗ Ptr   Re ✗ ✗ ✓ ✗ ✗ ✗ ✗ []byte ✗ ✗ ✗ ✓ + fmt.Stringer/error ✗ ✗ Re   ReAll ✗ ✗ ✓ ✗ ✗ ✗ ✗ []byte ✗ ✗ ✗ ✓ + fmt.Stringer/error ✗ ✗ ReAll       Operator vs go type nil bool string {u,}int* float* complex* array slice map struct pointer interface¹ chan func operator     Set ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✓ ✗ ✗ ptr on array/slice ✓ ✗ ✗ Set   Shallow ✓ ✗ ✓ ✗ ✗ ✗ ✗ ✓ ✓ ✗ ✓ ✓ ✓ ✓ Shallow   Slice ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✗ ✗ ptr on slice ✓ ✗ ✗ Slice   Smuggle ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ Smuggle   String ✗ ✗ ✓ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✓ + fmt.Stringer/error ✗ ✗ String   Struct ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✓ ptr on struct ✓ ✗ ✗ Struct   SubBagOf ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✓ ✗ ✗ ptr on array/slice ✓ ✗ ✗ SubBagOf   SubMapOf ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✗ ptr on map ✓ ✗ ✗ SubMapOf   SubSetOf ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✓ ✗ ✗ ptr on array/slice ✓ ✗ ✗ SubSetOf   SuperBagOf ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✓ ✗ ✗ ptr on array/slice ✓ ✗ ✗ SuperBagOf       Operator vs go type nil bool string {u,}int* float* complex* array slice map struct pointer interface¹ chan func operator     SuperMapOf ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✗ ptr on map ✓ ✗ ✗ SuperMapOf   SuperSetOf ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✓ ✗ ✗ ptr on array/slice ✓ ✗ ✗ SuperSetOf   Tag ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ Tag   TruncTime ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ time.Time todo ✓ ✗ ✗ TruncTime   Values ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✗ ✗ ✓ ✗ ✗ Values   Zero ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ Zero    Legend:\n ✗ means using this operator with a value type of this kind will always fail ✓ means using this operator with a value type of this kind can succeed []byte, time.Time, ptr on X, fmt.Stringer, error means using this operator with this go type can succeed todo means should be implemented in future (PRs welcome :) ) ¹ + ✓ means using this operator with the data behind the interface can succeed  go type → operator matrix Operators likely to succeed for each go type:\nUntyped nil value  All Any Catch Code Ignore JSON Lax Nil None Not NotNil NotZero Shallow Smuggle Tag Zero   bool values (or any type based on bool)  All Any Catch Code Ignore Isa JSON Lax None Not NotZero Smuggle Tag Zero   string values (or any type based on string)  All Any Between Catch Code Contains Empty Gt Gte HasPrefix HasSuffix Ignore Isa JSON Lax Lt Lte None Not NotEmpty NotZero Re ReAll Shallow Smuggle String Tag Zero   Integer values (uint*, int* or any type based on them)  All Any Between Catch Code Gt Gte Ignore Isa JSON Lax Lt Lte N None Not NotZero Smuggle Tag Zero   Float values (float32, float64 or any type based on them)  All Any Between Catch Code Gt Gte Ignore Isa JSON Lax Lt Lte N NaN None Not NotNaN NotZero Smuggle Tag Zero   Complex values (complex64, complex128 or any type based on them)  All Any Catch Code Ignore Isa Lax None Not NotZero Smuggle Tag Zero   Arrays  All Any Array ArrayEach Bag Cap Catch Code Contains Empty Ignore Isa JSON Lax Len None Not NotAny NotEmpty NotZero Set Smuggle SubBagOf SubSetOf SuperBagOf SuperSetOf Tag Zero   Slices  All Any ArrayEach Bag Cap Catch Code Contains Empty Ignore Isa JSON Lax Len Nil None Not NotAny NotEmpty NotNil NotZero Re only []byte ReAll only []byte Set Shallow Slice Smuggle SubBagOf SubSetOf SuperBagOf SuperSetOf Tag Zero   Maps  All Any Catch Code Contains ContainsKey Empty Ignore Isa JSON Keys Lax Len Map MapEach Nil None Not NotEmpty NotNil NotZero Shallow Smuggle SubMapOf SuperMapOf Tag Values Zero   Structs  All Any Between only time.Time Catch Code Gt only time.Time Gte only time.Time Ignore Isa JSON Lax Lt only time.Time Lte only time.Time None Not NotZero Smuggle Struct Tag TruncTime only time.Time Zero   Interface values As all operators accept interface values, only specific interfaces are listed below:\n HasPrefix → fmt.Stringer/error HasSuffix → fmt.Stringer/error Re → fmt.Stringer/error ReAll → fmt.Stringer/error String → fmt.Stringer/error   Any pointer  All Any Array only ptr on array ArrayEach only ptr on array/slice Bag only ptr on array/slice Catch Code Empty only ptr on array/slice/map/string Ignore Isa JSON Lax Map only ptr on map MapEach only ptr on map Nil None Not NotAny only ptr on array/slice NotEmpty only ptr on array/slice/map/string NotNil NotZero PPtr Ptr Set only ptr on array/slice Shallow Slice only ptr on slice Smuggle Struct only ptr on struct SubBagOf only ptr on array/slice SubMapOf only ptr on map SubSetOf only ptr on array/slice SuperBagOf only ptr on array/slice SuperMapOf only ptr on map SuperSetOf only ptr on array/slice Tag Zero   Channels  All Any Cap Catch Code Empty Ignore Isa Lax Len Nil None Not NotEmpty NotNil NotZero Shallow Smuggle Tag Zero   Functions  All Any Catch Code Ignore Isa Lax Nil None Not NotNil NotZero Shallow Smuggle Tag Zero   "
},
{
	"uri": "https://go-testdeep.zetta.rocks/",
	"title": "go-testdeep",
	"tags": [],
	"description": "",
	"content": " go-testdeep The testdeep package allows golang extremely flexible deep comparison. It is built for testing.\n← use the right menu to navigate. A good starting point is the introduction. "
},
{
	"uri": "https://go-testdeep.zetta.rocks/introduction/",
	"title": "Introduction",
	"tags": [],
	"description": "",
	"content": " Synopsis Simplest usage:\nimport ( \u0026#34;testing\u0026#34; td \u0026#34;github.com/maxatome/go-testdeep\u0026#34; ) func TestMyFunc(t *testing.T) { td.Cmp(t, MyFunc(), \u0026amp;Info{Name: \u0026#34;Alice\u0026#34;, Age: 42}) } Example of produced error in case of mismatch:\nDescription go-testdeep is a go rewrite and adaptation of wonderful Test::Deep perl.\nIn golang, comparing data structure is usually done using reflect.DeepEqual or using a package that uses this function behind the scene.\nThis function works very well, but it is not flexible. Both compared structures must match exactly and when a difference is returned, it is up to the caller to display it. Not easy when comparing big data structures.\nThe purpose of testdeep package is to do its best to introduce this missing flexibility using \u0026ldquo;operators\u0026rdquo;, when the expected value (or one of its component) cannot be matched exactly, mixed with some useful comparison functions.\n"
},
{
	"uri": "https://go-testdeep.zetta.rocks/operators/all/",
	"title": "All",
	"tags": [],
	"description": "",
	"content": " func All(expectedValues ...interface{}) TestDeep All operator compares data against several expected values. During a match, all of them have to match to succeed.\nTypeBehind method can return a non-nil reflect.Type if all items known non-interface types are equal, or if only interface types are found (mostly issued from Isa()) and they are equal.\n See also  All godoc.\n Examples   Base example   t := \u0026amp;testing.T{} got := \u0026#34;foo/bar\u0026#34; // Checks got string against: \t// \u0026#34;o/b\u0026#34; regexp *AND* \u0026#34;bar\u0026#34; suffix *AND* exact \u0026#34;foo/bar\u0026#34; string \tok := Cmp(t, got, All(Re(\u0026#34;o/b\u0026#34;), HasSuffix(\u0026#34;bar\u0026#34;), \u0026#34;foo/bar\u0026#34;), \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) // Checks got string against: \t// \u0026#34;o/b\u0026#34; regexp *AND* \u0026#34;bar\u0026#34; suffix *AND* exact \u0026#34;fooX/Ybar\u0026#34; string \tok = Cmp(t, got, All(Re(\u0026#34;o/b\u0026#34;), HasSuffix(\u0026#34;bar\u0026#34;), \u0026#34;fooX/Ybar\u0026#34;), \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// false   CmpAll shortcut func CmpAll(t TestingT, got interface{}, expectedValues []interface{}, args ...interface{}) bool CmpAll is a shortcut for:\nCmp(t, got, All(expectedValues...), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also  CmpAll godoc.\n Examples   Base example   t := \u0026amp;testing.T{} got := \u0026#34;foo/bar\u0026#34; // Checks got string against: \t// \u0026#34;o/b\u0026#34; regexp *AND* \u0026#34;bar\u0026#34; suffix *AND* exact \u0026#34;foo/bar\u0026#34; string \tok := CmpAll(t, got, []interface{}{Re(\u0026#34;o/b\u0026#34;), HasSuffix(\u0026#34;bar\u0026#34;), \u0026#34;foo/bar\u0026#34;}, \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) // Checks got string against: \t// \u0026#34;o/b\u0026#34; regexp *AND* \u0026#34;bar\u0026#34; suffix *AND* exact \u0026#34;fooX/Ybar\u0026#34; string \tok = CmpAll(t, got, []interface{}{Re(\u0026#34;o/b\u0026#34;), HasSuffix(\u0026#34;bar\u0026#34;), \u0026#34;fooX/Ybar\u0026#34;}, \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// false   T.All shortcut func (t *T) All(got interface{}, expectedValues []interface{}, args ...interface{}) bool All is a shortcut for:\nt.Cmp(got, All(expectedValues...), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also  T.All godoc.\n Examples   Base example   t := NewT(\u0026amp;testing.T{}) got := \u0026#34;foo/bar\u0026#34; // Checks got string against: \t// \u0026#34;o/b\u0026#34; regexp *AND* \u0026#34;bar\u0026#34; suffix *AND* exact \u0026#34;foo/bar\u0026#34; string \tok := t.All(got, []interface{}{Re(\u0026#34;o/b\u0026#34;), HasSuffix(\u0026#34;bar\u0026#34;), \u0026#34;foo/bar\u0026#34;}, \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) // Checks got string against: \t// \u0026#34;o/b\u0026#34; regexp *AND* \u0026#34;bar\u0026#34; suffix *AND* exact \u0026#34;fooX/Ybar\u0026#34; string \tok = t.All(got, []interface{}{Re(\u0026#34;o/b\u0026#34;), HasSuffix(\u0026#34;bar\u0026#34;), \u0026#34;fooX/Ybar\u0026#34;}, \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// false   "
},
{
	"uri": "https://go-testdeep.zetta.rocks/operators/any/",
	"title": "Any",
	"tags": [],
	"description": "",
	"content": " func Any(expectedValues ...interface{}) TestDeep Any operator compares data against several expected values. During a match, at least one of them has to match to succeed.\nTypeBehind method can return a non-nil reflect.Type if all items known non-interface types are equal, or if only interface types are found (mostly issued from Isa()) and they are equal.\n See also  Any godoc.\n Examples   Base example   t := \u0026amp;testing.T{} got := \u0026#34;foo/bar\u0026#34; // Checks got string against: \t// \u0026#34;zip\u0026#34; regexp *OR* \u0026#34;bar\u0026#34; suffix \tok := Cmp(t, got, Any(Re(\u0026#34;zip\u0026#34;), HasSuffix(\u0026#34;bar\u0026#34;)), \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) // Checks got string against: \t// \u0026#34;zip\u0026#34; regexp *OR* \u0026#34;foo\u0026#34; suffix \tok = Cmp(t, got, Any(Re(\u0026#34;zip\u0026#34;), HasSuffix(\u0026#34;foo\u0026#34;)), \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// false   CmpAny shortcut func CmpAny(t TestingT, got interface{}, expectedValues []interface{}, args ...interface{}) bool CmpAny is a shortcut for:\nCmp(t, got, Any(expectedValues...), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also  CmpAny godoc.\n Examples   Base example   t := \u0026amp;testing.T{} got := \u0026#34;foo/bar\u0026#34; // Checks got string against: \t// \u0026#34;zip\u0026#34; regexp *OR* \u0026#34;bar\u0026#34; suffix \tok := CmpAny(t, got, []interface{}{Re(\u0026#34;zip\u0026#34;), HasSuffix(\u0026#34;bar\u0026#34;)}, \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) // Checks got string against: \t// \u0026#34;zip\u0026#34; regexp *OR* \u0026#34;foo\u0026#34; suffix \tok = CmpAny(t, got, []interface{}{Re(\u0026#34;zip\u0026#34;), HasSuffix(\u0026#34;foo\u0026#34;)}, \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// false   T.Any shortcut func (t *T) Any(got interface{}, expectedValues []interface{}, args ...interface{}) bool Any is a shortcut for:\nt.Cmp(got, Any(expectedValues...), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also  T.Any godoc.\n Examples   Base example   t := NewT(\u0026amp;testing.T{}) got := \u0026#34;foo/bar\u0026#34; // Checks got string against: \t// \u0026#34;zip\u0026#34; regexp *OR* \u0026#34;bar\u0026#34; suffix \tok := t.Any(got, []interface{}{Re(\u0026#34;zip\u0026#34;), HasSuffix(\u0026#34;bar\u0026#34;)}, \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) // Checks got string against: \t// \u0026#34;zip\u0026#34; regexp *OR* \u0026#34;foo\u0026#34; suffix \tok = t.Any(got, []interface{}{Re(\u0026#34;zip\u0026#34;), HasSuffix(\u0026#34;foo\u0026#34;)}, \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// false   "
},
{
	"uri": "https://go-testdeep.zetta.rocks/operators/array/",
	"title": "Array",
	"tags": [],
	"description": "",
	"content": " func Array(model interface{}, expectedEntries ArrayEntries) TestDeep Array operator compares the contents of an array or a pointer on an array against the non-zero values of model (if any) and the values of expectedEntries.\nmodel must be the same type as compared data.\nexpectedEntries can be nil, if no zero entries are expected and no TestDeep operator are involved.\nTypeBehind method returns the reflect.Type of model.\n See also  Array godoc.\n Examples    Array example   t := \u0026amp;testing.T{} got := [3]int{42, 58, 26} ok := Cmp(t, got, Array([3]int{42}, ArrayEntries{1: 58, 2: Ignore()}), \u0026#34;checks array %v\u0026#34;, got) fmt.Println(ok) // Output: \t// true     TypedArray example   t := \u0026amp;testing.T{} type MyArray [3]int got := MyArray{42, 58, 26} ok := Cmp(t, got, Array(MyArray{42}, ArrayEntries{1: 58, 2: Ignore()}), \u0026#34;checks typed array %v\u0026#34;, got) fmt.Println(ok) ok = Cmp(t, \u0026amp;got, Array(\u0026amp;MyArray{42}, ArrayEntries{1: 58, 2: Ignore()}), \u0026#34;checks pointer on typed array %v\u0026#34;, got) fmt.Println(ok) ok = Cmp(t, \u0026amp;got, Array(\u0026amp;MyArray{}, ArrayEntries{0: 42, 1: 58, 2: Ignore()}), \u0026#34;checks pointer on typed array %v\u0026#34;, got) fmt.Println(ok) ok = Cmp(t, \u0026amp;got, Array((*MyArray)(nil), ArrayEntries{0: 42, 1: 58, 2: Ignore()}), \u0026#34;checks pointer on typed array %v\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// true \t// true \t// true  \nCmpArray shortcut func CmpArray(t TestingT, got interface{}, model interface{}, expectedEntries ArrayEntries, args ...interface{}) bool CmpArray is a shortcut for:\nCmp(t, got, Array(model, expectedEntries), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also  CmpArray godoc.\n Examples    Array example   t := \u0026amp;testing.T{} got := [3]int{42, 58, 26} ok := CmpArray(t, got, [3]int{42}, ArrayEntries{1: 58, 2: Ignore()}, \u0026#34;checks array %v\u0026#34;, got) fmt.Println(ok) // Output: \t// true     TypedArray example   t := \u0026amp;testing.T{} type MyArray [3]int got := MyArray{42, 58, 26} ok := CmpArray(t, got, MyArray{42}, ArrayEntries{1: 58, 2: Ignore()}, \u0026#34;checks typed array %v\u0026#34;, got) fmt.Println(ok) ok = CmpArray(t, \u0026amp;got, \u0026amp;MyArray{42}, ArrayEntries{1: 58, 2: Ignore()}, \u0026#34;checks pointer on typed array %v\u0026#34;, got) fmt.Println(ok) ok = CmpArray(t, \u0026amp;got, \u0026amp;MyArray{}, ArrayEntries{0: 42, 1: 58, 2: Ignore()}, \u0026#34;checks pointer on typed array %v\u0026#34;, got) fmt.Println(ok) ok = CmpArray(t, \u0026amp;got, (*MyArray)(nil), ArrayEntries{0: 42, 1: 58, 2: Ignore()}, \u0026#34;checks pointer on typed array %v\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// true \t// true \t// true  \nT.Array shortcut func (t *T) Array(got interface{}, model interface{}, expectedEntries ArrayEntries, args ...interface{}) bool Array is a shortcut for:\nt.Cmp(got, Array(model, expectedEntries), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also  T.Array godoc.\n Examples    Array example   t := NewT(\u0026amp;testing.T{}) got := [3]int{42, 58, 26} ok := t.Array(got, [3]int{42}, ArrayEntries{1: 58, 2: Ignore()}, \u0026#34;checks array %v\u0026#34;, got) fmt.Println(ok) // Output: \t// true     TypedArray example   t := NewT(\u0026amp;testing.T{}) type MyArray [3]int got := MyArray{42, 58, 26} ok := t.Array(got, MyArray{42}, ArrayEntries{1: 58, 2: Ignore()}, \u0026#34;checks typed array %v\u0026#34;, got) fmt.Println(ok) ok = t.Array(\u0026amp;got, \u0026amp;MyArray{42}, ArrayEntries{1: 58, 2: Ignore()}, \u0026#34;checks pointer on typed array %v\u0026#34;, got) fmt.Println(ok) ok = t.Array(\u0026amp;got, \u0026amp;MyArray{}, ArrayEntries{0: 42, 1: 58, 2: Ignore()}, \u0026#34;checks pointer on typed array %v\u0026#34;, got) fmt.Println(ok) ok = t.Array(\u0026amp;got, (*MyArray)(nil), ArrayEntries{0: 42, 1: 58, 2: Ignore()}, \u0026#34;checks pointer on typed array %v\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// true \t// true \t// true  \n"
},
{
	"uri": "https://go-testdeep.zetta.rocks/operators/arrayeach/",
	"title": "ArrayEach",
	"tags": [],
	"description": "",
	"content": " func ArrayEach(expectedValue interface{}) TestDeep ArrayEach operator has to be applied on arrays or slices or on pointers on array/slice. It compares each item of data array/slice against expectedValue. During a match, all items have to match to succeed.\n See also  ArrayEach godoc.\n Examples    Array example   t := \u0026amp;testing.T{} got := [3]int{42, 58, 26} ok := Cmp(t, got, ArrayEach(Between(25, 60)), \u0026#34;checks each item of array %v is in [25 .. 60]\u0026#34;, got) fmt.Println(ok) // Output: \t// true     TypedArray example   t := \u0026amp;testing.T{} type MyArray [3]int got := MyArray{42, 58, 26} ok := Cmp(t, got, ArrayEach(Between(25, 60)), \u0026#34;checks each item of typed array %v is in [25 .. 60]\u0026#34;, got) fmt.Println(ok) ok = Cmp(t, \u0026amp;got, ArrayEach(Between(25, 60)), \u0026#34;checks each item of typed array pointer %v is in [25 .. 60]\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// true     Slice example   t := \u0026amp;testing.T{} got := []int{42, 58, 26} ok := Cmp(t, got, ArrayEach(Between(25, 60)), \u0026#34;checks each item of slice %v is in [25 .. 60]\u0026#34;, got) fmt.Println(ok) // Output: \t// true     TypedSlice example   t := \u0026amp;testing.T{} type MySlice []int got := MySlice{42, 58, 26} ok := Cmp(t, got, ArrayEach(Between(25, 60)), \u0026#34;checks each item of typed slice %v is in [25 .. 60]\u0026#34;, got) fmt.Println(ok) ok = Cmp(t, \u0026amp;got, ArrayEach(Between(25, 60)), \u0026#34;checks each item of typed slice pointer %v is in [25 .. 60]\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// true  \nCmpArrayEach shortcut func CmpArrayEach(t TestingT, got interface{}, expectedValue interface{}, args ...interface{}) bool CmpArrayEach is a shortcut for:\nCmp(t, got, ArrayEach(expectedValue), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also  CmpArrayEach godoc.\n Examples    Array example   t := \u0026amp;testing.T{} got := [3]int{42, 58, 26} ok := CmpArrayEach(t, got, Between(25, 60), \u0026#34;checks each item of array %v is in [25 .. 60]\u0026#34;, got) fmt.Println(ok) // Output: \t// true     TypedArray example   t := \u0026amp;testing.T{} type MyArray [3]int got := MyArray{42, 58, 26} ok := CmpArrayEach(t, got, Between(25, 60), \u0026#34;checks each item of typed array %v is in [25 .. 60]\u0026#34;, got) fmt.Println(ok) ok = CmpArrayEach(t, \u0026amp;got, Between(25, 60), \u0026#34;checks each item of typed array pointer %v is in [25 .. 60]\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// true     Slice example   t := \u0026amp;testing.T{} got := []int{42, 58, 26} ok := CmpArrayEach(t, got, Between(25, 60), \u0026#34;checks each item of slice %v is in [25 .. 60]\u0026#34;, got) fmt.Println(ok) // Output: \t// true     TypedSlice example   t := \u0026amp;testing.T{} type MySlice []int got := MySlice{42, 58, 26} ok := CmpArrayEach(t, got, Between(25, 60), \u0026#34;checks each item of typed slice %v is in [25 .. 60]\u0026#34;, got) fmt.Println(ok) ok = CmpArrayEach(t, \u0026amp;got, Between(25, 60), \u0026#34;checks each item of typed slice pointer %v is in [25 .. 60]\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// true  \nT.ArrayEach shortcut func (t *T) ArrayEach(got interface{}, expectedValue interface{}, args ...interface{}) bool ArrayEach is a shortcut for:\nt.Cmp(got, ArrayEach(expectedValue), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also  T.ArrayEach godoc.\n Examples    Array example   t := NewT(\u0026amp;testing.T{}) got := [3]int{42, 58, 26} ok := t.ArrayEach(got, Between(25, 60), \u0026#34;checks each item of array %v is in [25 .. 60]\u0026#34;, got) fmt.Println(ok) // Output: \t// true     TypedArray example   t := NewT(\u0026amp;testing.T{}) type MyArray [3]int got := MyArray{42, 58, 26} ok := t.ArrayEach(got, Between(25, 60), \u0026#34;checks each item of typed array %v is in [25 .. 60]\u0026#34;, got) fmt.Println(ok) ok = t.ArrayEach(\u0026amp;got, Between(25, 60), \u0026#34;checks each item of typed array pointer %v is in [25 .. 60]\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// true     Slice example   t := NewT(\u0026amp;testing.T{}) got := []int{42, 58, 26} ok := t.ArrayEach(got, Between(25, 60), \u0026#34;checks each item of slice %v is in [25 .. 60]\u0026#34;, got) fmt.Println(ok) // Output: \t// true     TypedSlice example   t := NewT(\u0026amp;testing.T{}) type MySlice []int got := MySlice{42, 58, 26} ok := t.ArrayEach(got, Between(25, 60), \u0026#34;checks each item of typed slice %v is in [25 .. 60]\u0026#34;, got) fmt.Println(ok) ok = t.ArrayEach(\u0026amp;got, Between(25, 60), \u0026#34;checks each item of typed slice pointer %v is in [25 .. 60]\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// true  \n"
},
{
	"uri": "https://go-testdeep.zetta.rocks/operators/bag/",
	"title": "Bag",
	"tags": [],
	"description": "",
	"content": " func Bag(expectedItems ...interface{}) TestDeep Bag operator compares the contents of an array or a slice (or a pointer on array/slice) without taking care of the order of items.\nDuring a match, each expected item should match in the compared array/slice, and each array/slice item should be matched by an expected item to succeed.\nCmp(t, []int{1, 1, 2}, Bag(1, 1, 2)) // succeeds Cmp(t, []int{1, 1, 2}, Bag(1, 2, 1)) // succeeds Cmp(t, []int{1, 1, 2}, Bag(2, 1, 1)) // succeeds Cmp(t, []int{1, 1, 2}, Bag(1, 2)) // fails, one 1 is missing Cmp(t, []int{1, 1, 2}, Bag(1, 2, 1, 3)) // fails, 3 is missing  See also  Bag godoc.\n Examples   Base example   t := \u0026amp;testing.T{} got := []int{1, 3, 5, 8, 8, 1, 2} // Matches as all items are present \tok := Cmp(t, got, Bag(1, 1, 2, 3, 5, 8, 8), \u0026#34;checks all items are present, in any order\u0026#34;) fmt.Println(ok) // Does not match as got contains 2 times 1 and 8, and these \t// duplicates are not expected \tok = Cmp(t, got, Bag(1, 2, 3, 5, 8), \u0026#34;checks all items are present, in any order\u0026#34;) fmt.Println(ok) got = []int{1, 3, 5, 8, 2} // Duplicates of 1 and 8 are expected but not present in got \tok = Cmp(t, got, Bag(1, 1, 2, 3, 5, 8, 8), \u0026#34;checks all items are present, in any order\u0026#34;) fmt.Println(ok) // Matches as all items are present \tok = Cmp(t, got, Bag(1, 2, 3, 5, Gt(7)), \u0026#34;checks all items are present, in any order\u0026#34;) fmt.Println(ok) // Output: \t// true \t// false \t// false \t// true   CmpBag shortcut func CmpBag(t TestingT, got interface{}, expectedItems []interface{}, args ...interface{}) bool CmpBag is a shortcut for:\nCmp(t, got, Bag(expectedItems...), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also  CmpBag godoc.\n Examples   Base example   t := \u0026amp;testing.T{} got := []int{1, 3, 5, 8, 8, 1, 2} // Matches as all items are present \tok := CmpBag(t, got, []interface{}{1, 1, 2, 3, 5, 8, 8}, \u0026#34;checks all items are present, in any order\u0026#34;) fmt.Println(ok) // Does not match as got contains 2 times 1 and 8, and these \t// duplicates are not expected \tok = CmpBag(t, got, []interface{}{1, 2, 3, 5, 8}, \u0026#34;checks all items are present, in any order\u0026#34;) fmt.Println(ok) got = []int{1, 3, 5, 8, 2} // Duplicates of 1 and 8 are expected but not present in got \tok = CmpBag(t, got, []interface{}{1, 1, 2, 3, 5, 8, 8}, \u0026#34;checks all items are present, in any order\u0026#34;) fmt.Println(ok) // Matches as all items are present \tok = CmpBag(t, got, []interface{}{1, 2, 3, 5, Gt(7)}, \u0026#34;checks all items are present, in any order\u0026#34;) fmt.Println(ok) // Output: \t// true \t// false \t// false \t// true   T.Bag shortcut func (t *T) Bag(got interface{}, expectedItems []interface{}, args ...interface{}) bool Bag is a shortcut for:\nt.Cmp(got, Bag(expectedItems...), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also  T.Bag godoc.\n Examples   Base example   t := NewT(\u0026amp;testing.T{}) got := []int{1, 3, 5, 8, 8, 1, 2} // Matches as all items are present \tok := t.Bag(got, []interface{}{1, 1, 2, 3, 5, 8, 8}, \u0026#34;checks all items are present, in any order\u0026#34;) fmt.Println(ok) // Does not match as got contains 2 times 1 and 8, and these \t// duplicates are not expected \tok = t.Bag(got, []interface{}{1, 2, 3, 5, 8}, \u0026#34;checks all items are present, in any order\u0026#34;) fmt.Println(ok) got = []int{1, 3, 5, 8, 2} // Duplicates of 1 and 8 are expected but not present in got \tok = t.Bag(got, []interface{}{1, 1, 2, 3, 5, 8, 8}, \u0026#34;checks all items are present, in any order\u0026#34;) fmt.Println(ok) // Matches as all items are present \tok = t.Bag(got, []interface{}{1, 2, 3, 5, Gt(7)}, \u0026#34;checks all items are present, in any order\u0026#34;) fmt.Println(ok) // Output: \t// true \t// false \t// false \t// true   "
},
{
	"uri": "https://go-testdeep.zetta.rocks/operators/between/",
	"title": "Between",
	"tags": [],
	"description": "",
	"content": " func Between(from interface{}, to interface{}, bounds ...BoundsKind) TestDeep Between operator checks that data is between from and to. from and to can be any numeric, string or time.Time (or assignable) value. from and to must be the same kind as the compared value if numeric, and the same type if string or time.Time (or assignable). bounds allows to specify whether bounds are included or not:\n BoundsInIn (default): between from and to both included BoundsInOut: between from included and to excluded BoundsOutIn: between from excluded and to included BoundsOutOut: between from and to both excluded  If bounds is missing, it defaults to BoundsInIn.\nTypeBehind method returns the reflect.Type of from (same as the to one.)\n See also  Between godoc.\n Examples    Int example   t := \u0026amp;testing.T{} got := 156 ok := Cmp(t, got, Between(154, 156), \u0026#34;checks %v is in [154 .. 156]\u0026#34;, got) fmt.Println(ok) // BoundsInIn is implicit \tok = Cmp(t, got, Between(154, 156, BoundsInIn), \u0026#34;checks %v is in [154 .. 156]\u0026#34;, got) fmt.Println(ok) ok = Cmp(t, got, Between(154, 156, BoundsInOut), \u0026#34;checks %v is in [154 .. 156[\u0026#34;, got) fmt.Println(ok) ok = Cmp(t, got, Between(154, 156, BoundsOutIn), \u0026#34;checks %v is in ]154 .. 156]\u0026#34;, got) fmt.Println(ok) ok = Cmp(t, got, Between(154, 156, BoundsOutOut), \u0026#34;checks %v is in ]154 .. 156[\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// true \t// false \t// true \t// false     String example   t := \u0026amp;testing.T{} got := \u0026#34;abc\u0026#34; ok := Cmp(t, got, Between(\u0026#34;aaa\u0026#34;, \u0026#34;abc\u0026#34;), `checks \u0026#34;%v\u0026#34; is in [\u0026#34;aaa\u0026#34; .. \u0026#34;abc\u0026#34;]`, got) fmt.Println(ok) // BoundsInIn is implicit \tok = Cmp(t, got, Between(\u0026#34;aaa\u0026#34;, \u0026#34;abc\u0026#34;, BoundsInIn), `checks \u0026#34;%v\u0026#34; is in [\u0026#34;aaa\u0026#34; .. \u0026#34;abc\u0026#34;]`, got) fmt.Println(ok) ok = Cmp(t, got, Between(\u0026#34;aaa\u0026#34;, \u0026#34;abc\u0026#34;, BoundsInOut), `checks \u0026#34;%v\u0026#34; is in [\u0026#34;aaa\u0026#34; .. \u0026#34;abc\u0026#34;[`, got) fmt.Println(ok) ok = Cmp(t, got, Between(\u0026#34;aaa\u0026#34;, \u0026#34;abc\u0026#34;, BoundsOutIn), `checks \u0026#34;%v\u0026#34; is in ]\u0026#34;aaa\u0026#34; .. \u0026#34;abc\u0026#34;]`, got) fmt.Println(ok) ok = Cmp(t, got, Between(\u0026#34;aaa\u0026#34;, \u0026#34;abc\u0026#34;, BoundsOutOut), `checks \u0026#34;%v\u0026#34; is in ]\u0026#34;aaa\u0026#34; .. \u0026#34;abc\u0026#34;[`, got) fmt.Println(ok) // Output: \t// true \t// true \t// false \t// true \t// false  \nCmpBetween shortcut func CmpBetween(t TestingT, got interface{}, from interface{}, to interface{}, bounds BoundsKind, args ...interface{}) bool CmpBetween is a shortcut for:\nCmp(t, got, Between(from, to, bounds), args...) See above for details.\nBetween() optional parameter bounds is here mandatory. BoundsInIn value should be passed to mimic its absence in original Between() call.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also  CmpBetween godoc.\n Examples    Int example   t := \u0026amp;testing.T{} got := 156 ok := CmpBetween(t, got, 154, 156, BoundsInIn, \u0026#34;checks %v is in [154 .. 156]\u0026#34;, got) fmt.Println(ok) // BoundsInIn is implicit \tok = CmpBetween(t, got, 154, 156, BoundsInIn, \u0026#34;checks %v is in [154 .. 156]\u0026#34;, got) fmt.Println(ok) ok = CmpBetween(t, got, 154, 156, BoundsInOut, \u0026#34;checks %v is in [154 .. 156[\u0026#34;, got) fmt.Println(ok) ok = CmpBetween(t, got, 154, 156, BoundsOutIn, \u0026#34;checks %v is in ]154 .. 156]\u0026#34;, got) fmt.Println(ok) ok = CmpBetween(t, got, 154, 156, BoundsOutOut, \u0026#34;checks %v is in ]154 .. 156[\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// true \t// false \t// true \t// false     String example   t := \u0026amp;testing.T{} got := \u0026#34;abc\u0026#34; ok := CmpBetween(t, got, \u0026#34;aaa\u0026#34;, \u0026#34;abc\u0026#34;, BoundsInIn, `checks \u0026#34;%v\u0026#34; is in [\u0026#34;aaa\u0026#34; .. \u0026#34;abc\u0026#34;]`, got) fmt.Println(ok) // BoundsInIn is implicit \tok = CmpBetween(t, got, \u0026#34;aaa\u0026#34;, \u0026#34;abc\u0026#34;, BoundsInIn, `checks \u0026#34;%v\u0026#34; is in [\u0026#34;aaa\u0026#34; .. \u0026#34;abc\u0026#34;]`, got) fmt.Println(ok) ok = CmpBetween(t, got, \u0026#34;aaa\u0026#34;, \u0026#34;abc\u0026#34;, BoundsInOut, `checks \u0026#34;%v\u0026#34; is in [\u0026#34;aaa\u0026#34; .. \u0026#34;abc\u0026#34;[`, got) fmt.Println(ok) ok = CmpBetween(t, got, \u0026#34;aaa\u0026#34;, \u0026#34;abc\u0026#34;, BoundsOutIn, `checks \u0026#34;%v\u0026#34; is in ]\u0026#34;aaa\u0026#34; .. \u0026#34;abc\u0026#34;]`, got) fmt.Println(ok) ok = CmpBetween(t, got, \u0026#34;aaa\u0026#34;, \u0026#34;abc\u0026#34;, BoundsOutOut, `checks \u0026#34;%v\u0026#34; is in ]\u0026#34;aaa\u0026#34; .. \u0026#34;abc\u0026#34;[`, got) fmt.Println(ok) // Output: \t// true \t// true \t// false \t// true \t// false  \nT.Between shortcut func (t *T) Between(got interface{}, from interface{}, to interface{}, bounds BoundsKind, args ...interface{}) bool Between is a shortcut for:\nt.Cmp(got, Between(from, to, bounds), args...) See above for details.\nBetween() optional parameter bounds is here mandatory. BoundsInIn value should be passed to mimic its absence in original Between() call.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also  T.Between godoc.\n Examples    Int example   t := NewT(\u0026amp;testing.T{}) got := 156 ok := t.Between(got, 154, 156, BoundsInIn, \u0026#34;checks %v is in [154 .. 156]\u0026#34;, got) fmt.Println(ok) // BoundsInIn is implicit \tok = t.Between(got, 154, 156, BoundsInIn, \u0026#34;checks %v is in [154 .. 156]\u0026#34;, got) fmt.Println(ok) ok = t.Between(got, 154, 156, BoundsInOut, \u0026#34;checks %v is in [154 .. 156[\u0026#34;, got) fmt.Println(ok) ok = t.Between(got, 154, 156, BoundsOutIn, \u0026#34;checks %v is in ]154 .. 156]\u0026#34;, got) fmt.Println(ok) ok = t.Between(got, 154, 156, BoundsOutOut, \u0026#34;checks %v is in ]154 .. 156[\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// true \t// false \t// true \t// false     String example   t := NewT(\u0026amp;testing.T{}) got := \u0026#34;abc\u0026#34; ok := t.Between(got, \u0026#34;aaa\u0026#34;, \u0026#34;abc\u0026#34;, BoundsInIn, `checks \u0026#34;%v\u0026#34; is in [\u0026#34;aaa\u0026#34; .. \u0026#34;abc\u0026#34;]`, got) fmt.Println(ok) // BoundsInIn is implicit \tok = t.Between(got, \u0026#34;aaa\u0026#34;, \u0026#34;abc\u0026#34;, BoundsInIn, `checks \u0026#34;%v\u0026#34; is in [\u0026#34;aaa\u0026#34; .. \u0026#34;abc\u0026#34;]`, got) fmt.Println(ok) ok = t.Between(got, \u0026#34;aaa\u0026#34;, \u0026#34;abc\u0026#34;, BoundsInOut, `checks \u0026#34;%v\u0026#34; is in [\u0026#34;aaa\u0026#34; .. \u0026#34;abc\u0026#34;[`, got) fmt.Println(ok) ok = t.Between(got, \u0026#34;aaa\u0026#34;, \u0026#34;abc\u0026#34;, BoundsOutIn, `checks \u0026#34;%v\u0026#34; is in ]\u0026#34;aaa\u0026#34; .. \u0026#34;abc\u0026#34;]`, got) fmt.Println(ok) ok = t.Between(got, \u0026#34;aaa\u0026#34;, \u0026#34;abc\u0026#34;, BoundsOutOut, `checks \u0026#34;%v\u0026#34; is in ]\u0026#34;aaa\u0026#34; .. \u0026#34;abc\u0026#34;[`, got) fmt.Println(ok) // Output: \t// true \t// true \t// false \t// true \t// false  \n"
},
{
	"uri": "https://go-testdeep.zetta.rocks/operators/cap/",
	"title": "Cap",
	"tags": [],
	"description": "",
	"content": " func Cap(expectedCap interface{}) TestDeep Cap is a smuggler operator. It takes data, applies cap() function on it and compares its result to expectedCap. Of course, the compared value must be an array, a channel or a slice.\nexpectedCap can be an int value:\nCmp(t, gotSlice, Cap(12)) as well as an other operator:\nCmp(t, gotSlice, Cap(Between(3, 4)))  See also  Cap godoc.\n Examples    Base example   t := \u0026amp;testing.T{} got := make([]int, 0, 12) ok := Cmp(t, got, Cap(12), \u0026#34;checks %v capacity is 12\u0026#34;, got) fmt.Println(ok) ok = Cmp(t, got, Cap(0), \u0026#34;checks %v capacity is 0\u0026#34;, got) fmt.Println(ok) got = nil ok = Cmp(t, got, Cap(0), \u0026#34;checks %v capacity is 0\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// false \t// true     Operator example   t := \u0026amp;testing.T{} got := make([]int, 0, 12) ok := Cmp(t, got, Cap(Between(10, 12)), \u0026#34;checks %v capacity is in [10 .. 12]\u0026#34;, got) fmt.Println(ok) ok = Cmp(t, got, Cap(Gt(10)), \u0026#34;checks %v capacity is in [10 .. 12]\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// true  \nCmpCap shortcut func CmpCap(t TestingT, got interface{}, expectedCap interface{}, args ...interface{}) bool CmpCap is a shortcut for:\nCmp(t, got, Cap(expectedCap), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also  CmpCap godoc.\n Examples    Base example   t := \u0026amp;testing.T{} got := make([]int, 0, 12) ok := CmpCap(t, got, 12, \u0026#34;checks %v capacity is 12\u0026#34;, got) fmt.Println(ok) ok = CmpCap(t, got, 0, \u0026#34;checks %v capacity is 0\u0026#34;, got) fmt.Println(ok) got = nil ok = CmpCap(t, got, 0, \u0026#34;checks %v capacity is 0\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// false \t// true     Operator example   t := \u0026amp;testing.T{} got := make([]int, 0, 12) ok := CmpCap(t, got, Between(10, 12), \u0026#34;checks %v capacity is in [10 .. 12]\u0026#34;, got) fmt.Println(ok) ok = CmpCap(t, got, Gt(10), \u0026#34;checks %v capacity is in [10 .. 12]\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// true  \nT.Cap shortcut func (t *T) Cap(got interface{}, expectedCap interface{}, args ...interface{}) bool Cap is a shortcut for:\nt.Cmp(got, Cap(expectedCap), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also  T.Cap godoc.\n Examples    Base example   t := NewT(\u0026amp;testing.T{}) got := make([]int, 0, 12) ok := t.Cap(got, 12, \u0026#34;checks %v capacity is 12\u0026#34;, got) fmt.Println(ok) ok = t.Cap(got, 0, \u0026#34;checks %v capacity is 0\u0026#34;, got) fmt.Println(ok) got = nil ok = t.Cap(got, 0, \u0026#34;checks %v capacity is 0\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// false \t// true     Operator example   t := NewT(\u0026amp;testing.T{}) got := make([]int, 0, 12) ok := t.Cap(got, Between(10, 12), \u0026#34;checks %v capacity is in [10 .. 12]\u0026#34;, got) fmt.Println(ok) ok = t.Cap(got, Gt(10), \u0026#34;checks %v capacity is in [10 .. 12]\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// true  \n"
},
{
	"uri": "https://go-testdeep.zetta.rocks/operators/catch/",
	"title": "Catch",
	"tags": [],
	"description": "",
	"content": " func Catch(target interface{}, expectedValue interface{}) TestDeep Catch is a smuggler operator. It allows to copy data in target on the fly before comparing it as usual against expectedValue.\ntarget must be a non-nil pointer and data should be assignable to its pointed type. If BeLax config flag is true or called under Lax (and so JSON) operator, data should be convertible to its pointer type.\nvar id int64 if Cmp(t, CreateRecord(\u0026#34;test\u0026#34;), JSON(`{\u0026#34;id\u0026#34;: $1, \u0026#34;name\u0026#34;: \u0026#34;test\u0026#34;}`, Catch(\u0026amp;id, NotZero()))) { t.Logf(\u0026#34;Created record ID is %d\u0026#34;, id) } It is really useful when used with JSON operator and/or tdhttp helper.\nvar id int64 if tdhttp.CmpJSONResponse(t, tdhttp.NewRequest(\u0026#34;POST\u0026#34;, \u0026#34;/item\u0026#34;, `{\u0026#34;name\u0026#34;:\u0026#34;foo\u0026#34;}`), api.Handler, tdhttp.Response{ Status: http.StatusCreated, Body: testdeep.JSON(`{\u0026#34;id\u0026#34;: $id, \u0026#34;name\u0026#34;: \u0026#34;foo\u0026#34;}`, testdeep.Tag(\u0026#34;id\u0026#34;, testdeep.Catch(\u0026amp;id, testdeep.Gt(0)))), }) { t.Logf(\u0026#34;Created record ID is %d\u0026#34;, id) } If you need to only catch data without comparing it, use Ignore operator as expectedValue as in:\nvar id int64 if Cmp(t, CreateRecord(\u0026#34;test\u0026#34;), JSON(`{\u0026#34;id\u0026#34;: $1, \u0026#34;name\u0026#34;: \u0026#34;test\u0026#34;}`, Catch(\u0026amp;id, Ignore()))) { t.Logf(\u0026#34;Created record ID is %d\u0026#34;, id) }  See also  Catch godoc.\n Examples   Base example   t := \u0026amp;testing.T{} got := \u0026amp;struct { Fullname string `json:\u0026#34;fullname\u0026#34;` Age int `json:\u0026#34;age\u0026#34;` }{ Fullname: \u0026#34;Bob\u0026#34;, Age: 42, } var age int ok := Cmp(t, got, JSON(`{\u0026#34;age\u0026#34;:$1,\u0026#34;fullname\u0026#34;:\u0026#34;Bob\u0026#34;}`, Catch(\u0026amp;age, Between(40, 45)))) fmt.Println(\u0026#34;check got age+fullname:\u0026#34;, ok) fmt.Println(\u0026#34;caught age:\u0026#34;, age) // Output: \t// check got age+fullname: true \t// caught age: 42   "
},
{
	"uri": "https://go-testdeep.zetta.rocks/operators/code/",
	"title": "Code",
	"tags": [],
	"description": "",
	"content": " func Code(fn interface{}) TestDeep Code operator allows to check data using a custom function. So fn is a function that must take one parameter whose type must be the same as the type of the compared value.\nfn can return a single bool kind value, telling that yes or no the custom test is successful:\nCmp(t, gotTime, Code(func (date time.Time) bool { return date.Year() == 2018 })) or two values (bool, string) kinds. The bool value has the same meaning as above, and the string value is used to describe the test when it fails:\nCmp(t, gotTime, Code(func (date time.Time) (bool, string) { if date.Year() == 2018 { return true, \u0026#34;\u0026#34; } return false, \u0026#34;year must be 2018\u0026#34; })) or a single error value. If the returned error is nil, the test succeeded, else the error contains the reason of failure:\nCmp(t, gotJsonRawMesg, Code(func (b json.RawMessage) error { var c map[string]int err := json.Unmarshal(b, \u0026amp;c) if err != nil { return err } if c[\u0026#34;test\u0026#34;] != 42 { return fmt.Errorf(`key \u0026#34;test\u0026#34; does not match 42`) } return nil })) This operator allows to handle any specific comparison not handled by standard operators.\nIt is not recommended to call Cmp (or any other Cmp* functions or *T methods) inside the body of fn, because of confusion produced by output in case of failure. When the data needs to be transformed before being compared again, Smuggle operator should be used instead.\nTypeBehind method returns the reflect.Type of only parameter of fn.\n See also  Code godoc.\n Examples   Base example   t := \u0026amp;testing.T{} got := \u0026#34;12\u0026#34; ok := Cmp(t, got, Code(func(num string) bool { n, err := strconv.Atoi(num) return err == nil \u0026amp;\u0026amp; n \u0026gt; 10 \u0026amp;\u0026amp; n \u0026lt; 100 }), \u0026#34;checks string `%s` contains a number and this number is in ]10 .. 100[\u0026#34;, got) fmt.Println(ok) // Same with failure reason \tok = Cmp(t, got, Code(func(num string) (bool, string) { n, err := strconv.Atoi(num) if err != nil { return false, \u0026#34;not a number\u0026#34; } if n \u0026gt; 10 \u0026amp;\u0026amp; n \u0026lt; 100 { return true, \u0026#34;\u0026#34; } return false, \u0026#34;not in ]10 .. 100[\u0026#34; }), \u0026#34;checks string `%s` contains a number and this number is in ]10 .. 100[\u0026#34;, got) fmt.Println(ok) // Same with failure reason thanks to error \tok = Cmp(t, got, Code(func(num string) error { n, err := strconv.Atoi(num) if err != nil { return err } if n \u0026gt; 10 \u0026amp;\u0026amp; n \u0026lt; 100 { return nil } return fmt.Errorf(\u0026#34;%d not in ]10 .. 100[\u0026#34;, n) }), \u0026#34;checks string `%s` contains a number and this number is in ]10 .. 100[\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// true \t// true   CmpCode shortcut func CmpCode(t TestingT, got interface{}, fn interface{}, args ...interface{}) bool CmpCode is a shortcut for:\nCmp(t, got, Code(fn), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also  CmpCode godoc.\n Examples   Base example   t := \u0026amp;testing.T{} got := \u0026#34;12\u0026#34; ok := CmpCode(t, got, func(num string) bool { n, err := strconv.Atoi(num) return err == nil \u0026amp;\u0026amp; n \u0026gt; 10 \u0026amp;\u0026amp; n \u0026lt; 100 }, \u0026#34;checks string `%s` contains a number and this number is in ]10 .. 100[\u0026#34;, got) fmt.Println(ok) // Same with failure reason \tok = CmpCode(t, got, func(num string) (bool, string) { n, err := strconv.Atoi(num) if err != nil { return false, \u0026#34;not a number\u0026#34; } if n \u0026gt; 10 \u0026amp;\u0026amp; n \u0026lt; 100 { return true, \u0026#34;\u0026#34; } return false, \u0026#34;not in ]10 .. 100[\u0026#34; }, \u0026#34;checks string `%s` contains a number and this number is in ]10 .. 100[\u0026#34;, got) fmt.Println(ok) // Same with failure reason thanks to error \tok = CmpCode(t, got, func(num string) error { n, err := strconv.Atoi(num) if err != nil { return err } if n \u0026gt; 10 \u0026amp;\u0026amp; n \u0026lt; 100 { return nil } return fmt.Errorf(\u0026#34;%d not in ]10 .. 100[\u0026#34;, n) }, \u0026#34;checks string `%s` contains a number and this number is in ]10 .. 100[\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// true \t// true   T.Code shortcut func (t *T) Code(got interface{}, fn interface{}, args ...interface{}) bool Code is a shortcut for:\nt.Cmp(got, Code(fn), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also  T.Code godoc.\n Examples   Base example   t := NewT(\u0026amp;testing.T{}) got := \u0026#34;12\u0026#34; ok := t.Code(got, func(num string) bool { n, err := strconv.Atoi(num) return err == nil \u0026amp;\u0026amp; n \u0026gt; 10 \u0026amp;\u0026amp; n \u0026lt; 100 }, \u0026#34;checks string `%s` contains a number and this number is in ]10 .. 100[\u0026#34;, got) fmt.Println(ok) // Same with failure reason \tok = t.Code(got, func(num string) (bool, string) { n, err := strconv.Atoi(num) if err != nil { return false, \u0026#34;not a number\u0026#34; } if n \u0026gt; 10 \u0026amp;\u0026amp; n \u0026lt; 100 { return true, \u0026#34;\u0026#34; } return false, \u0026#34;not in ]10 .. 100[\u0026#34; }, \u0026#34;checks string `%s` contains a number and this number is in ]10 .. 100[\u0026#34;, got) fmt.Println(ok) // Same with failure reason thanks to error \tok = t.Code(got, func(num string) error { n, err := strconv.Atoi(num) if err != nil { return err } if n \u0026gt; 10 \u0026amp;\u0026amp; n \u0026lt; 100 { return nil } return fmt.Errorf(\u0026#34;%d not in ]10 .. 100[\u0026#34;, n) }, \u0026#34;checks string `%s` contains a number and this number is in ]10 .. 100[\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// true \t// true   "
},
{
	"uri": "https://go-testdeep.zetta.rocks/operators/contains/",
	"title": "Contains",
	"tags": [],
	"description": "",
	"content": " func Contains(expectedValue interface{}) TestDeep Contains is a smuggler operator with a little convenient exception for strings. Contains has to be applied on arrays, slices, maps or strings. It compares each item of data array/slice/map/string (rune for strings) against expectedValue.\nlist := []int{12, 34, 28} Cmp(t, list, Contains(34)) // succeeds Cmp(t, list, Contains(Between(30, 35))) // succeeds too Cmp(t, list, Contains(35)) // fails  hash := map[string]int{\u0026#34;foo\u0026#34;: 12, \u0026#34;bar\u0026#34;: 34, \u0026#34;zip\u0026#34;: 28} Cmp(t, hash, Contains(34)) // succeeds Cmp(t, hash, Contains(Between(30, 35))) // succeeds too Cmp(t, hash, Contains(35)) // fails  got := \u0026#34;foo bar\u0026#34; Cmp(t, got, Contains(\u0026#39;o\u0026#39;)) // succeeds Cmp(t, got, Contains(rune(\u0026#39;o\u0026#39;))) // succeeds Cmp(t, got, Contains(Between(\u0026#39;n\u0026#39;, \u0026#39;p\u0026#39;))) // succeeds When Contains(nil) is used, nil is automatically converted to a typed nil on the fly to avoid confusion (if the array/slice/map item type allows it of course.) So all following Cmp calls are equivalent (except the (*byte)(nil) one):\nnum := 123 list := []*int{\u0026amp;num, nil} Cmp(t, list, Contains(nil)) // succeeds → (*int)(nil) Cmp(t, list, Contains((*int)(nil))) // succeeds Cmp(t, list, Contains(Nil())) // succeeds // But... Cmp(t, list, Contains((*byte)(nil))) // fails: (*byte)(nil) ≠ (*int)(nil) As well as these ones:\nhash := map[string]*int{\u0026#34;foo\u0026#34;: nil, \u0026#34;bar\u0026#34;: \u0026amp;num} Cmp(t, hash, Contains(nil)) // succeeds → (*int)(nil) Cmp(t, hash, Contains((*int)(nil))) // succeeds Cmp(t, hash, Contains(Nil())) // succeeds As a special case for string (or convertible), error or fmt.Stringer interface (error interface is tested before fmt.Stringer), expectedValue can be a string, a rune or a byte. In this case, it tests if the got string contains this expected string, rune or byte.\ntype Foobar string Cmp(t, Foobar(\u0026#34;foobar\u0026#34;), Contains(\u0026#34;ooba\u0026#34;)) // succeeds  err := errors.New(\u0026#34;error!\u0026#34;) Cmp(t, err, Contains(\u0026#34;ror\u0026#34;)) // succeeds  bstr := bytes.NewBufferString(\u0026#34;fmt.Stringer!\u0026#34;) Cmp(t, bstr, Contains(\u0026#34;String\u0026#34;)) // succeeds  See also  Contains godoc.\n Examples    ArraySlice example   t := \u0026amp;testing.T{} ok := Cmp(t, [...]int{11, 22, 33, 44}, Contains(22)) fmt.Println(\u0026#34;array contains 22:\u0026#34;, ok) ok = Cmp(t, [...]int{11, 22, 33, 44}, Contains(Between(20, 25))) fmt.Println(\u0026#34;array contains at least one item in [20 .. 25]:\u0026#34;, ok) ok = Cmp(t, []int{11, 22, 33, 44}, Contains(22)) fmt.Println(\u0026#34;slice contains 22:\u0026#34;, ok) ok = Cmp(t, []int{11, 22, 33, 44}, Contains(Between(20, 25))) fmt.Println(\u0026#34;slice contains at least one item in [20 .. 25]:\u0026#34;, ok) // Output: \t// array contains 22: true \t// array contains at least one item in [20 .. 25]: true \t// slice contains 22: true \t// slice contains at least one item in [20 .. 25]: true     Nil example   t := \u0026amp;testing.T{} num := 123 got := [...]*int{\u0026amp;num, nil} ok := Cmp(t, got, Contains(nil)) fmt.Println(\u0026#34;array contains untyped nil:\u0026#34;, ok) ok = Cmp(t, got, Contains((*int)(nil))) fmt.Println(\u0026#34;array contains *int nil:\u0026#34;, ok) ok = Cmp(t, got, Contains(Nil())) fmt.Println(\u0026#34;array contains Nil():\u0026#34;, ok) ok = Cmp(t, got, Contains((*byte)(nil))) fmt.Println(\u0026#34;array contains *byte nil:\u0026#34;, ok) // types differ: *byte ≠ *int  // Output: \t// array contains untyped nil: true \t// array contains *int nil: true \t// array contains Nil(): true \t// array contains *byte nil: false     Map example   t := \u0026amp;testing.T{} ok := Cmp(t, map[string]int{\u0026#34;foo\u0026#34;: 11, \u0026#34;bar\u0026#34;: 22, \u0026#34;zip\u0026#34;: 33}, Contains(22)) fmt.Println(\u0026#34;map contains value 22:\u0026#34;, ok) ok = Cmp(t, map[string]int{\u0026#34;foo\u0026#34;: 11, \u0026#34;bar\u0026#34;: 22, \u0026#34;zip\u0026#34;: 33}, Contains(Between(20, 25))) fmt.Println(\u0026#34;map contains at least one value in [20 .. 25]:\u0026#34;, ok) // Output: \t// map contains value 22: true \t// map contains at least one value in [20 .. 25]: true     String example   t := \u0026amp;testing.T{} got := \u0026#34;foobar\u0026#34; ok := Cmp(t, got, Contains(\u0026#34;oob\u0026#34;), \u0026#34;checks %s\u0026#34;, got) fmt.Println(\u0026#34;contains `oob` string:\u0026#34;, ok) ok = Cmp(t, got, Contains(\u0026#39;b\u0026#39;), \u0026#34;checks %s\u0026#34;, got) fmt.Println(\u0026#34;contains \u0026#39;b\u0026#39; rune:\u0026#34;, ok) ok = Cmp(t, got, Contains(byte(\u0026#39;a\u0026#39;)), \u0026#34;checks %s\u0026#34;, got) fmt.Println(\u0026#34;contains \u0026#39;a\u0026#39; byte:\u0026#34;, ok) ok = Cmp(t, got, Contains(Between(\u0026#39;n\u0026#39;, \u0026#39;p\u0026#39;)), \u0026#34;checks %s\u0026#34;, got) fmt.Println(\u0026#34;contains at least one character [\u0026#39;n\u0026#39; .. \u0026#39;p\u0026#39;]:\u0026#34;, ok) // Output: \t// contains `oob` string: true \t// contains \u0026#39;b\u0026#39; rune: true \t// contains \u0026#39;a\u0026#39; byte: true \t// contains at least one character [\u0026#39;n\u0026#39; .. \u0026#39;p\u0026#39;]: true     Stringer example   t := \u0026amp;testing.T{} // bytes.Buffer implements fmt.Stringer \tgot := bytes.NewBufferString(\u0026#34;foobar\u0026#34;) ok := Cmp(t, got, Contains(\u0026#34;oob\u0026#34;), \u0026#34;checks %s\u0026#34;, got) fmt.Println(\u0026#34;contains `oob` string:\u0026#34;, ok) ok = Cmp(t, got, Contains(\u0026#39;b\u0026#39;), \u0026#34;checks %s\u0026#34;, got) fmt.Println(\u0026#34;contains \u0026#39;b\u0026#39; rune:\u0026#34;, ok) ok = Cmp(t, got, Contains(byte(\u0026#39;a\u0026#39;)), \u0026#34;checks %s\u0026#34;, got) fmt.Println(\u0026#34;contains \u0026#39;a\u0026#39; byte:\u0026#34;, ok) // Be careful! TestDeep operators in Contains() do not work with \t// fmt.Stringer nor error interfaces \tok = Cmp(t, got, Contains(Between(\u0026#39;n\u0026#39;, \u0026#39;p\u0026#39;)), \u0026#34;checks %s\u0026#34;, got) fmt.Println(\u0026#34;try TestDeep operator:\u0026#34;, ok) // Output: \t// contains `oob` string: true \t// contains \u0026#39;b\u0026#39; rune: true \t// contains \u0026#39;a\u0026#39; byte: true \t// try TestDeep operator: false     Error example   t := \u0026amp;testing.T{} got := errors.New(\u0026#34;foobar\u0026#34;) ok := Cmp(t, got, Contains(\u0026#34;oob\u0026#34;), \u0026#34;checks %s\u0026#34;, got) fmt.Println(\u0026#34;contains `oob` string:\u0026#34;, ok) ok = Cmp(t, got, Contains(\u0026#39;b\u0026#39;), \u0026#34;checks %s\u0026#34;, got) fmt.Println(\u0026#34;contains \u0026#39;b\u0026#39; rune:\u0026#34;, ok) ok = Cmp(t, got, Contains(byte(\u0026#39;a\u0026#39;)), \u0026#34;checks %s\u0026#34;, got) fmt.Println(\u0026#34;contains \u0026#39;a\u0026#39; byte:\u0026#34;, ok) // Be careful! TestDeep operators in Contains() do not work with \t// fmt.Stringer nor error interfaces \tok = Cmp(t, got, Contains(Between(\u0026#39;n\u0026#39;, \u0026#39;p\u0026#39;)), \u0026#34;checks %s\u0026#34;, got) fmt.Println(\u0026#34;try TestDeep operator:\u0026#34;, ok) // Output: \t// contains `oob` string: true \t// contains \u0026#39;b\u0026#39; rune: true \t// contains \u0026#39;a\u0026#39; byte: true \t// try TestDeep operator: false  \nCmpContains shortcut func CmpContains(t TestingT, got interface{}, expectedValue interface{}, args ...interface{}) bool CmpContains is a shortcut for:\nCmp(t, got, Contains(expectedValue), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also  CmpContains godoc.\n Examples    ArraySlice example   t := \u0026amp;testing.T{} ok := CmpContains(t, [...]int{11, 22, 33, 44}, 22) fmt.Println(\u0026#34;array contains 22:\u0026#34;, ok) ok = CmpContains(t, [...]int{11, 22, 33, 44}, Between(20, 25)) fmt.Println(\u0026#34;array contains at least one item in [20 .. 25]:\u0026#34;, ok) ok = CmpContains(t, []int{11, 22, 33, 44}, 22) fmt.Println(\u0026#34;slice contains 22:\u0026#34;, ok) ok = CmpContains(t, []int{11, 22, 33, 44}, Between(20, 25)) fmt.Println(\u0026#34;slice contains at least one item in [20 .. 25]:\u0026#34;, ok) // Output: \t// array contains 22: true \t// array contains at least one item in [20 .. 25]: true \t// slice contains 22: true \t// slice contains at least one item in [20 .. 25]: true     Nil example   t := \u0026amp;testing.T{} num := 123 got := [...]*int{\u0026amp;num, nil} ok := CmpContains(t, got, nil) fmt.Println(\u0026#34;array contains untyped nil:\u0026#34;, ok) ok = CmpContains(t, got, (*int)(nil)) fmt.Println(\u0026#34;array contains *int nil:\u0026#34;, ok) ok = CmpContains(t, got, Nil()) fmt.Println(\u0026#34;array contains Nil():\u0026#34;, ok) ok = CmpContains(t, got, (*byte)(nil)) fmt.Println(\u0026#34;array contains *byte nil:\u0026#34;, ok) // types differ: *byte ≠ *int  // Output: \t// array contains untyped nil: true \t// array contains *int nil: true \t// array contains Nil(): true \t// array contains *byte nil: false     Map example   t := \u0026amp;testing.T{} ok := CmpContains(t, map[string]int{\u0026#34;foo\u0026#34;: 11, \u0026#34;bar\u0026#34;: 22, \u0026#34;zip\u0026#34;: 33}, 22) fmt.Println(\u0026#34;map contains value 22:\u0026#34;, ok) ok = CmpContains(t, map[string]int{\u0026#34;foo\u0026#34;: 11, \u0026#34;bar\u0026#34;: 22, \u0026#34;zip\u0026#34;: 33}, Between(20, 25)) fmt.Println(\u0026#34;map contains at least one value in [20 .. 25]:\u0026#34;, ok) // Output: \t// map contains value 22: true \t// map contains at least one value in [20 .. 25]: true     String example   t := \u0026amp;testing.T{} got := \u0026#34;foobar\u0026#34; ok := CmpContains(t, got, \u0026#34;oob\u0026#34;, \u0026#34;checks %s\u0026#34;, got) fmt.Println(\u0026#34;contains `oob` string:\u0026#34;, ok) ok = CmpContains(t, got, \u0026#39;b\u0026#39;, \u0026#34;checks %s\u0026#34;, got) fmt.Println(\u0026#34;contains \u0026#39;b\u0026#39; rune:\u0026#34;, ok) ok = CmpContains(t, got, byte(\u0026#39;a\u0026#39;), \u0026#34;checks %s\u0026#34;, got) fmt.Println(\u0026#34;contains \u0026#39;a\u0026#39; byte:\u0026#34;, ok) ok = CmpContains(t, got, Between(\u0026#39;n\u0026#39;, \u0026#39;p\u0026#39;), \u0026#34;checks %s\u0026#34;, got) fmt.Println(\u0026#34;contains at least one character [\u0026#39;n\u0026#39; .. \u0026#39;p\u0026#39;]:\u0026#34;, ok) // Output: \t// contains `oob` string: true \t// contains \u0026#39;b\u0026#39; rune: true \t// contains \u0026#39;a\u0026#39; byte: true \t// contains at least one character [\u0026#39;n\u0026#39; .. \u0026#39;p\u0026#39;]: true     Stringer example   t := \u0026amp;testing.T{} // bytes.Buffer implements fmt.Stringer \tgot := bytes.NewBufferString(\u0026#34;foobar\u0026#34;) ok := CmpContains(t, got, \u0026#34;oob\u0026#34;, \u0026#34;checks %s\u0026#34;, got) fmt.Println(\u0026#34;contains `oob` string:\u0026#34;, ok) ok = CmpContains(t, got, \u0026#39;b\u0026#39;, \u0026#34;checks %s\u0026#34;, got) fmt.Println(\u0026#34;contains \u0026#39;b\u0026#39; rune:\u0026#34;, ok) ok = CmpContains(t, got, byte(\u0026#39;a\u0026#39;), \u0026#34;checks %s\u0026#34;, got) fmt.Println(\u0026#34;contains \u0026#39;a\u0026#39; byte:\u0026#34;, ok) // Be careful! TestDeep operators in Contains() do not work with \t// fmt.Stringer nor error interfaces \tok = CmpContains(t, got, Between(\u0026#39;n\u0026#39;, \u0026#39;p\u0026#39;), \u0026#34;checks %s\u0026#34;, got) fmt.Println(\u0026#34;try TestDeep operator:\u0026#34;, ok) // Output: \t// contains `oob` string: true \t// contains \u0026#39;b\u0026#39; rune: true \t// contains \u0026#39;a\u0026#39; byte: true \t// try TestDeep operator: false     Error example   t := \u0026amp;testing.T{} got := errors.New(\u0026#34;foobar\u0026#34;) ok := CmpContains(t, got, \u0026#34;oob\u0026#34;, \u0026#34;checks %s\u0026#34;, got) fmt.Println(\u0026#34;contains `oob` string:\u0026#34;, ok) ok = CmpContains(t, got, \u0026#39;b\u0026#39;, \u0026#34;checks %s\u0026#34;, got) fmt.Println(\u0026#34;contains \u0026#39;b\u0026#39; rune:\u0026#34;, ok) ok = CmpContains(t, got, byte(\u0026#39;a\u0026#39;), \u0026#34;checks %s\u0026#34;, got) fmt.Println(\u0026#34;contains \u0026#39;a\u0026#39; byte:\u0026#34;, ok) // Be careful! TestDeep operators in Contains() do not work with \t// fmt.Stringer nor error interfaces \tok = CmpContains(t, got, Between(\u0026#39;n\u0026#39;, \u0026#39;p\u0026#39;), \u0026#34;checks %s\u0026#34;, got) fmt.Println(\u0026#34;try TestDeep operator:\u0026#34;, ok) // Output: \t// contains `oob` string: true \t// contains \u0026#39;b\u0026#39; rune: true \t// contains \u0026#39;a\u0026#39; byte: true \t// try TestDeep operator: false  \nT.Contains shortcut func (t *T) Contains(got interface{}, expectedValue interface{}, args ...interface{}) bool Contains is a shortcut for:\nt.Cmp(got, Contains(expectedValue), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also  T.Contains godoc.\n Examples    ArraySlice example   t := NewT(\u0026amp;testing.T{}) ok := t.Contains([...]int{11, 22, 33, 44}, 22) fmt.Println(\u0026#34;array contains 22:\u0026#34;, ok) ok = t.Contains([...]int{11, 22, 33, 44}, Between(20, 25)) fmt.Println(\u0026#34;array contains at least one item in [20 .. 25]:\u0026#34;, ok) ok = t.Contains([]int{11, 22, 33, 44}, 22) fmt.Println(\u0026#34;slice contains 22:\u0026#34;, ok) ok = t.Contains([]int{11, 22, 33, 44}, Between(20, 25)) fmt.Println(\u0026#34;slice contains at least one item in [20 .. 25]:\u0026#34;, ok) // Output: \t// array contains 22: true \t// array contains at least one item in [20 .. 25]: true \t// slice contains 22: true \t// slice contains at least one item in [20 .. 25]: true     Nil example   t := NewT(\u0026amp;testing.T{}) num := 123 got := [...]*int{\u0026amp;num, nil} ok := t.Contains(got, nil) fmt.Println(\u0026#34;array contains untyped nil:\u0026#34;, ok) ok = t.Contains(got, (*int)(nil)) fmt.Println(\u0026#34;array contains *int nil:\u0026#34;, ok) ok = t.Contains(got, Nil()) fmt.Println(\u0026#34;array contains Nil():\u0026#34;, ok) ok = t.Contains(got, (*byte)(nil)) fmt.Println(\u0026#34;array contains *byte nil:\u0026#34;, ok) // types differ: *byte ≠ *int  // Output: \t// array contains untyped nil: true \t// array contains *int nil: true \t// array contains Nil(): true \t// array contains *byte nil: false     Map example   t := NewT(\u0026amp;testing.T{}) ok := t.Contains(map[string]int{\u0026#34;foo\u0026#34;: 11, \u0026#34;bar\u0026#34;: 22, \u0026#34;zip\u0026#34;: 33}, 22) fmt.Println(\u0026#34;map contains value 22:\u0026#34;, ok) ok = t.Contains(map[string]int{\u0026#34;foo\u0026#34;: 11, \u0026#34;bar\u0026#34;: 22, \u0026#34;zip\u0026#34;: 33}, Between(20, 25)) fmt.Println(\u0026#34;map contains at least one value in [20 .. 25]:\u0026#34;, ok) // Output: \t// map contains value 22: true \t// map contains at least one value in [20 .. 25]: true     String example   t := NewT(\u0026amp;testing.T{}) got := \u0026#34;foobar\u0026#34; ok := t.Contains(got, \u0026#34;oob\u0026#34;, \u0026#34;checks %s\u0026#34;, got) fmt.Println(\u0026#34;contains `oob` string:\u0026#34;, ok) ok = t.Contains(got, \u0026#39;b\u0026#39;, \u0026#34;checks %s\u0026#34;, got) fmt.Println(\u0026#34;contains \u0026#39;b\u0026#39; rune:\u0026#34;, ok) ok = t.Contains(got, byte(\u0026#39;a\u0026#39;), \u0026#34;checks %s\u0026#34;, got) fmt.Println(\u0026#34;contains \u0026#39;a\u0026#39; byte:\u0026#34;, ok) ok = t.Contains(got, Between(\u0026#39;n\u0026#39;, \u0026#39;p\u0026#39;), \u0026#34;checks %s\u0026#34;, got) fmt.Println(\u0026#34;contains at least one character [\u0026#39;n\u0026#39; .. \u0026#39;p\u0026#39;]:\u0026#34;, ok) // Output: \t// contains `oob` string: true \t// contains \u0026#39;b\u0026#39; rune: true \t// contains \u0026#39;a\u0026#39; byte: true \t// contains at least one character [\u0026#39;n\u0026#39; .. \u0026#39;p\u0026#39;]: true     Stringer example   t := NewT(\u0026amp;testing.T{}) // bytes.Buffer implements fmt.Stringer \tgot := bytes.NewBufferString(\u0026#34;foobar\u0026#34;) ok := t.Contains(got, \u0026#34;oob\u0026#34;, \u0026#34;checks %s\u0026#34;, got) fmt.Println(\u0026#34;contains `oob` string:\u0026#34;, ok) ok = t.Contains(got, \u0026#39;b\u0026#39;, \u0026#34;checks %s\u0026#34;, got) fmt.Println(\u0026#34;contains \u0026#39;b\u0026#39; rune:\u0026#34;, ok) ok = t.Contains(got, byte(\u0026#39;a\u0026#39;), \u0026#34;checks %s\u0026#34;, got) fmt.Println(\u0026#34;contains \u0026#39;a\u0026#39; byte:\u0026#34;, ok) // Be careful! TestDeep operators in Contains() do not work with \t// fmt.Stringer nor error interfaces \tok = t.Contains(got, Between(\u0026#39;n\u0026#39;, \u0026#39;p\u0026#39;), \u0026#34;checks %s\u0026#34;, got) fmt.Println(\u0026#34;try TestDeep operator:\u0026#34;, ok) // Output: \t// contains `oob` string: true \t// contains \u0026#39;b\u0026#39; rune: true \t// contains \u0026#39;a\u0026#39; byte: true \t// try TestDeep operator: false     Error example   t := NewT(\u0026amp;testing.T{}) got := errors.New(\u0026#34;foobar\u0026#34;) ok := t.Contains(got, \u0026#34;oob\u0026#34;, \u0026#34;checks %s\u0026#34;, got) fmt.Println(\u0026#34;contains `oob` string:\u0026#34;, ok) ok = t.Contains(got, \u0026#39;b\u0026#39;, \u0026#34;checks %s\u0026#34;, got) fmt.Println(\u0026#34;contains \u0026#39;b\u0026#39; rune:\u0026#34;, ok) ok = t.Contains(got, byte(\u0026#39;a\u0026#39;), \u0026#34;checks %s\u0026#34;, got) fmt.Println(\u0026#34;contains \u0026#39;a\u0026#39; byte:\u0026#34;, ok) // Be careful! TestDeep operators in Contains() do not work with \t// fmt.Stringer nor error interfaces \tok = t.Contains(got, Between(\u0026#39;n\u0026#39;, \u0026#39;p\u0026#39;), \u0026#34;checks %s\u0026#34;, got) fmt.Println(\u0026#34;try TestDeep operator:\u0026#34;, ok) // Output: \t// contains `oob` string: true \t// contains \u0026#39;b\u0026#39; rune: true \t// contains \u0026#39;a\u0026#39; byte: true \t// try TestDeep operator: false  \n"
},
{
	"uri": "https://go-testdeep.zetta.rocks/operators/containskey/",
	"title": "ContainsKey",
	"tags": [],
	"description": "",
	"content": " func ContainsKey(expectedValue interface{}) TestDeep ContainsKey is a smuggler operator and works on maps only. It compares each key of map against expectedValue.\nhash := map[string]int{\u0026#34;foo\u0026#34;: 12, \u0026#34;bar\u0026#34;: 34, \u0026#34;zip\u0026#34;: 28} Cmp(t, hash, ContainsKey(\u0026#34;foo\u0026#34;)) // succeeds Cmp(t, hash, ContainsKey(HasPrefix(\u0026#34;z\u0026#34;))) // succeeds Cmp(t, hash, ContainsKey(HasPrefix(\u0026#34;x\u0026#34;)) // fails  hnum := map[int]string{1: \u0026#34;foo\u0026#34;, 42: \u0026#34;bar\u0026#34;} Cmp(t, hash, ContainsKey(42)) // succeeds Cmp(t, hash, ContainsKey(Between(40, 45)) // succeeds When ContainsKey(nil) is used, nil is automatically converted to a typed nil on the fly to avoid confusion (if the map key type allows it of course.) So all following Cmp calls are equivalent (except the (*byte)(nil) one):\nnum := 123 hnum := map[*int]bool{\u0026amp;num: true, nil: true} Cmp(t, hnum, ContainsKey(nil)) // succeeds → (*int)(nil) Cmp(t, hnum, ContainsKey((*int)(nil))) // succeeds Cmp(t, hnum, ContainsKey(Nil())) // succeeds // But... Cmp(t, hnum, ContainsKey((*byte)(nil))) // fails: (*byte)(nil) ≠ (*int)(nil)  See also  ContainsKey godoc.\n Examples    Base example   t := \u0026amp;testing.T{} ok := Cmp(t, map[string]int{\u0026#34;foo\u0026#34;: 11, \u0026#34;bar\u0026#34;: 22, \u0026#34;zip\u0026#34;: 33}, ContainsKey(\u0026#34;foo\u0026#34;)) fmt.Println(`map contains key \u0026#34;foo\u0026#34;:`, ok) ok = Cmp(t, map[int]bool{12: true, 24: false, 42: true, 51: false}, ContainsKey(Between(40, 50))) fmt.Println(\u0026#34;map contains at least a key in [40 .. 50]:\u0026#34;, ok) // Output: \t// map contains key \u0026#34;foo\u0026#34;: true \t// map contains at least a key in [40 .. 50]: true     Nil example   t := \u0026amp;testing.T{} num := 1234 got := map[*int]bool{\u0026amp;num: false, nil: true} ok := Cmp(t, got, ContainsKey(nil)) fmt.Println(\u0026#34;map contains untyped nil key:\u0026#34;, ok) ok = Cmp(t, got, ContainsKey((*int)(nil))) fmt.Println(\u0026#34;map contains *int nil key:\u0026#34;, ok) ok = Cmp(t, got, ContainsKey(Nil())) fmt.Println(\u0026#34;map contains Nil() key:\u0026#34;, ok) ok = Cmp(t, got, ContainsKey((*byte)(nil))) fmt.Println(\u0026#34;map contains *byte nil key:\u0026#34;, ok) // types differ: *byte ≠ *int  // Output: \t// map contains untyped nil key: true \t// map contains *int nil key: true \t// map contains Nil() key: true \t// map contains *byte nil key: false  \nCmpContainsKey shortcut func CmpContainsKey(t TestingT, got interface{}, expectedValue interface{}, args ...interface{}) bool CmpContainsKey is a shortcut for:\nCmp(t, got, ContainsKey(expectedValue), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also  CmpContainsKey godoc.\n Examples    Base example   t := \u0026amp;testing.T{} ok := CmpContainsKey(t, map[string]int{\u0026#34;foo\u0026#34;: 11, \u0026#34;bar\u0026#34;: 22, \u0026#34;zip\u0026#34;: 33}, \u0026#34;foo\u0026#34;) fmt.Println(`map contains key \u0026#34;foo\u0026#34;:`, ok) ok = CmpContainsKey(t, map[int]bool{12: true, 24: false, 42: true, 51: false}, Between(40, 50)) fmt.Println(\u0026#34;map contains at least a key in [40 .. 50]:\u0026#34;, ok) // Output: \t// map contains key \u0026#34;foo\u0026#34;: true \t// map contains at least a key in [40 .. 50]: true     Nil example   t := \u0026amp;testing.T{} num := 1234 got := map[*int]bool{\u0026amp;num: false, nil: true} ok := CmpContainsKey(t, got, nil) fmt.Println(\u0026#34;map contains untyped nil key:\u0026#34;, ok) ok = CmpContainsKey(t, got, (*int)(nil)) fmt.Println(\u0026#34;map contains *int nil key:\u0026#34;, ok) ok = CmpContainsKey(t, got, Nil()) fmt.Println(\u0026#34;map contains Nil() key:\u0026#34;, ok) ok = CmpContainsKey(t, got, (*byte)(nil)) fmt.Println(\u0026#34;map contains *byte nil key:\u0026#34;, ok) // types differ: *byte ≠ *int  // Output: \t// map contains untyped nil key: true \t// map contains *int nil key: true \t// map contains Nil() key: true \t// map contains *byte nil key: false  \nT.ContainsKey shortcut func (t *T) ContainsKey(got interface{}, expectedValue interface{}, args ...interface{}) bool ContainsKey is a shortcut for:\nt.Cmp(got, ContainsKey(expectedValue), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also  T.ContainsKey godoc.\n Examples    Base example   t := NewT(\u0026amp;testing.T{}) ok := t.ContainsKey(map[string]int{\u0026#34;foo\u0026#34;: 11, \u0026#34;bar\u0026#34;: 22, \u0026#34;zip\u0026#34;: 33}, \u0026#34;foo\u0026#34;) fmt.Println(`map contains key \u0026#34;foo\u0026#34;:`, ok) ok = t.ContainsKey(map[int]bool{12: true, 24: false, 42: true, 51: false}, Between(40, 50)) fmt.Println(\u0026#34;map contains at least a key in [40 .. 50]:\u0026#34;, ok) // Output: \t// map contains key \u0026#34;foo\u0026#34;: true \t// map contains at least a key in [40 .. 50]: true     Nil example   t := NewT(\u0026amp;testing.T{}) num := 1234 got := map[*int]bool{\u0026amp;num: false, nil: true} ok := t.ContainsKey(got, nil) fmt.Println(\u0026#34;map contains untyped nil key:\u0026#34;, ok) ok = t.ContainsKey(got, (*int)(nil)) fmt.Println(\u0026#34;map contains *int nil key:\u0026#34;, ok) ok = t.ContainsKey(got, Nil()) fmt.Println(\u0026#34;map contains Nil() key:\u0026#34;, ok) ok = t.ContainsKey(got, (*byte)(nil)) fmt.Println(\u0026#34;map contains *byte nil key:\u0026#34;, ok) // types differ: *byte ≠ *int  // Output: \t// map contains untyped nil key: true \t// map contains *int nil key: true \t// map contains Nil() key: true \t// map contains *byte nil key: false  \n"
},
{
	"uri": "https://go-testdeep.zetta.rocks/operators/empty/",
	"title": "Empty",
	"tags": [],
	"description": "",
	"content": " func Empty() TestDeep Empty operator checks that an array, a channel, a map, a slice or a string is empty. As a special case (non-typed) nil, as well as nil channel, map or slice are considered empty.\nNote that the compared data can be a pointer (of pointer of pointer etc.) on an array, a channel, a map, a slice or a string.\n See also  Empty godoc.\n Examples    Base example   t := \u0026amp;testing.T{} ok := Cmp(t, nil, Empty()) // special case: nil is considered empty \tfmt.Println(ok) // fails, typed nil is not empty (expect for channel, map, slice or \t// pointers on array, channel, map slice and strings) \tok = Cmp(t, (*int)(nil), Empty()) fmt.Println(ok) ok = Cmp(t, \u0026#34;\u0026#34;, Empty()) fmt.Println(ok) // Fails as 0 is a number, so not empty. Use Zero() instead \tok = Cmp(t, 0, Empty()) fmt.Println(ok) ok = Cmp(t, (map[string]int)(nil), Empty()) fmt.Println(ok) ok = Cmp(t, map[string]int{}, Empty()) fmt.Println(ok) ok = Cmp(t, ([]int)(nil), Empty()) fmt.Println(ok) ok = Cmp(t, []int{}, Empty()) fmt.Println(ok) ok = Cmp(t, []int{3}, Empty()) // fails, as not empty \tfmt.Println(ok) ok = Cmp(t, [3]int{}, Empty()) // fails, Empty() is not Zero()! \tfmt.Println(ok) // Output: \t// true \t// false \t// true \t// false \t// true \t// true \t// true \t// true \t// false \t// false     Pointers example   t := \u0026amp;testing.T{} type MySlice []int ok := Cmp(t, MySlice{}, Empty()) // Ptr() not needed \tfmt.Println(ok) ok = Cmp(t, \u0026amp;MySlice{}, Empty()) fmt.Println(ok) l1 := \u0026amp;MySlice{} l2 := \u0026amp;l1 l3 := \u0026amp;l2 ok = Cmp(t, \u0026amp;l3, Empty()) fmt.Println(ok) // Works the same for array, map, channel and string  // But not for others types as: \ttype MyStruct struct { Value int } ok = Cmp(t, \u0026amp;MyStruct{}, Empty()) // fails, use Zero() instead \tfmt.Println(ok) // Output: \t// true \t// true \t// true \t// false  \nCmpEmpty shortcut func CmpEmpty(t TestingT, got interface{}, args ...interface{}) bool CmpEmpty is a shortcut for:\nCmp(t, got, Empty(), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also  CmpEmpty godoc.\n Examples    Base example   t := \u0026amp;testing.T{} ok := CmpEmpty(t, nil) // special case: nil is considered empty \tfmt.Println(ok) // fails, typed nil is not empty (expect for channel, map, slice or \t// pointers on array, channel, map slice and strings) \tok = CmpEmpty(t, (*int)(nil)) fmt.Println(ok) ok = CmpEmpty(t, \u0026#34;\u0026#34;) fmt.Println(ok) // Fails as 0 is a number, so not empty. Use Zero() instead \tok = CmpEmpty(t, 0) fmt.Println(ok) ok = CmpEmpty(t, (map[string]int)(nil)) fmt.Println(ok) ok = CmpEmpty(t, map[string]int{}) fmt.Println(ok) ok = CmpEmpty(t, ([]int)(nil)) fmt.Println(ok) ok = CmpEmpty(t, []int{}) fmt.Println(ok) ok = CmpEmpty(t, []int{3}) // fails, as not empty \tfmt.Println(ok) ok = CmpEmpty(t, [3]int{}) // fails, Empty() is not Zero()! \tfmt.Println(ok) // Output: \t// true \t// false \t// true \t// false \t// true \t// true \t// true \t// true \t// false \t// false     Pointers example   t := \u0026amp;testing.T{} type MySlice []int ok := CmpEmpty(t, MySlice{}) // Ptr() not needed \tfmt.Println(ok) ok = CmpEmpty(t, \u0026amp;MySlice{}) fmt.Println(ok) l1 := \u0026amp;MySlice{} l2 := \u0026amp;l1 l3 := \u0026amp;l2 ok = CmpEmpty(t, \u0026amp;l3) fmt.Println(ok) // Works the same for array, map, channel and string  // But not for others types as: \ttype MyStruct struct { Value int } ok = CmpEmpty(t, \u0026amp;MyStruct{}) // fails, use Zero() instead \tfmt.Println(ok) // Output: \t// true \t// true \t// true \t// false  \nT.Empty shortcut func (t *T) Empty(got interface{}, args ...interface{}) bool Empty is a shortcut for:\nt.Cmp(got, Empty(), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also  T.Empty godoc.\n Examples    Base example   t := NewT(\u0026amp;testing.T{}) ok := t.Empty(nil) // special case: nil is considered empty \tfmt.Println(ok) // fails, typed nil is not empty (expect for channel, map, slice or \t// pointers on array, channel, map slice and strings) \tok = t.Empty((*int)(nil)) fmt.Println(ok) ok = t.Empty(\u0026#34;\u0026#34;) fmt.Println(ok) // Fails as 0 is a number, so not empty. Use Zero() instead \tok = t.Empty(0) fmt.Println(ok) ok = t.Empty((map[string]int)(nil)) fmt.Println(ok) ok = t.Empty(map[string]int{}) fmt.Println(ok) ok = t.Empty(([]int)(nil)) fmt.Println(ok) ok = t.Empty([]int{}) fmt.Println(ok) ok = t.Empty([]int{3}) // fails, as not empty \tfmt.Println(ok) ok = t.Empty([3]int{}) // fails, Empty() is not Zero()! \tfmt.Println(ok) // Output: \t// true \t// false \t// true \t// false \t// true \t// true \t// true \t// true \t// false \t// false     Pointers example   t := NewT(\u0026amp;testing.T{}) type MySlice []int ok := t.Empty(MySlice{}) // Ptr() not needed \tfmt.Println(ok) ok = t.Empty(\u0026amp;MySlice{}) fmt.Println(ok) l1 := \u0026amp;MySlice{} l2 := \u0026amp;l1 l3 := \u0026amp;l2 ok = t.Empty(\u0026amp;l3) fmt.Println(ok) // Works the same for array, map, channel and string  // But not for others types as: \ttype MyStruct struct { Value int } ok = t.Empty(\u0026amp;MyStruct{}) // fails, use Zero() instead \tfmt.Println(ok) // Output: \t// true \t// true \t// true \t// false  \n"
},
{
	"uri": "https://go-testdeep.zetta.rocks/operators/gt/",
	"title": "Gt",
	"tags": [],
	"description": "",
	"content": " func Gt(minExpectedValue interface{}) TestDeep Gt operator checks that data is greater than minExpectedValue. minExpectedValue can be any numeric or time.Time (or assignable) value. minExpectedValue must be the same kind as the compared value if numeric, and the same type if time.Time (or assignable).\nTypeBehind method returns the reflect.Type of minExpectedValue.\n See also  Gt godoc.\n Examples    Int example   t := \u0026amp;testing.T{} got := 156 ok := Cmp(t, got, Gt(155), \u0026#34;checks %v is \u0026gt; 155\u0026#34;, got) fmt.Println(ok) ok = Cmp(t, got, Gt(156), \u0026#34;checks %v is \u0026gt; 156\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// false     String example   t := \u0026amp;testing.T{} got := \u0026#34;abc\u0026#34; ok := Cmp(t, got, Gt(\u0026#34;abb\u0026#34;), `checks \u0026#34;%v\u0026#34; is \u0026gt; \u0026#34;abb\u0026#34;`, got) fmt.Println(ok) ok = Cmp(t, got, Gt(\u0026#34;abc\u0026#34;), `checks \u0026#34;%v\u0026#34; is \u0026gt; \u0026#34;abc\u0026#34;`, got) fmt.Println(ok) // Output: \t// true \t// false  \nCmpGt shortcut func CmpGt(t TestingT, got interface{}, minExpectedValue interface{}, args ...interface{}) bool CmpGt is a shortcut for:\nCmp(t, got, Gt(minExpectedValue), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also  CmpGt godoc.\n Examples    Int example   t := \u0026amp;testing.T{} got := 156 ok := CmpGt(t, got, 155, \u0026#34;checks %v is \u0026gt; 155\u0026#34;, got) fmt.Println(ok) ok = CmpGt(t, got, 156, \u0026#34;checks %v is \u0026gt; 156\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// false     String example   t := \u0026amp;testing.T{} got := \u0026#34;abc\u0026#34; ok := CmpGt(t, got, \u0026#34;abb\u0026#34;, `checks \u0026#34;%v\u0026#34; is \u0026gt; \u0026#34;abb\u0026#34;`, got) fmt.Println(ok) ok = CmpGt(t, got, \u0026#34;abc\u0026#34;, `checks \u0026#34;%v\u0026#34; is \u0026gt; \u0026#34;abc\u0026#34;`, got) fmt.Println(ok) // Output: \t// true \t// false  \nT.Gt shortcut func (t *T) Gt(got interface{}, minExpectedValue interface{}, args ...interface{}) bool Gt is a shortcut for:\nt.Cmp(got, Gt(minExpectedValue), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also  T.Gt godoc.\n Examples    Int example   t := NewT(\u0026amp;testing.T{}) got := 156 ok := t.Gt(got, 155, \u0026#34;checks %v is \u0026gt; 155\u0026#34;, got) fmt.Println(ok) ok = t.Gt(got, 156, \u0026#34;checks %v is \u0026gt; 156\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// false     String example   t := NewT(\u0026amp;testing.T{}) got := \u0026#34;abc\u0026#34; ok := t.Gt(got, \u0026#34;abb\u0026#34;, `checks \u0026#34;%v\u0026#34; is \u0026gt; \u0026#34;abb\u0026#34;`, got) fmt.Println(ok) ok = t.Gt(got, \u0026#34;abc\u0026#34;, `checks \u0026#34;%v\u0026#34; is \u0026gt; \u0026#34;abc\u0026#34;`, got) fmt.Println(ok) // Output: \t// true \t// false  \n"
},
{
	"uri": "https://go-testdeep.zetta.rocks/operators/gte/",
	"title": "Gte",
	"tags": [],
	"description": "",
	"content": " func Gte(minExpectedValue interface{}) TestDeep Gte operator checks that data is greater or equal than minExpectedValue. minExpectedValue can be any numeric or time.Time (or assignable) value. minExpectedValue must be the same kind as the compared value if numeric, and the same type if time.Time (or assignable).\nTypeBehind method returns the reflect.Type of minExpectedValue.\n See also  Gte godoc.\n Examples    Int example   t := \u0026amp;testing.T{} got := 156 ok := Cmp(t, got, Gte(156), \u0026#34;checks %v is ≥ 156\u0026#34;, got) fmt.Println(ok) ok = Cmp(t, got, Gte(155), \u0026#34;checks %v is ≥ 155\u0026#34;, got) fmt.Println(ok) ok = Cmp(t, got, Gte(157), \u0026#34;checks %v is ≥ 157\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// true \t// false     String example   t := \u0026amp;testing.T{} got := \u0026#34;abc\u0026#34; ok := Cmp(t, got, Gte(\u0026#34;abc\u0026#34;), `checks \u0026#34;%v\u0026#34; is ≥ \u0026#34;abc\u0026#34;`, got) fmt.Println(ok) ok = Cmp(t, got, Gte(\u0026#34;abb\u0026#34;), `checks \u0026#34;%v\u0026#34; is ≥ \u0026#34;abb\u0026#34;`, got) fmt.Println(ok) ok = Cmp(t, got, Gte(\u0026#34;abd\u0026#34;), `checks \u0026#34;%v\u0026#34; is ≥ \u0026#34;abd\u0026#34;`, got) fmt.Println(ok) // Output: \t// true \t// true \t// false  \nCmpGte shortcut func CmpGte(t TestingT, got interface{}, minExpectedValue interface{}, args ...interface{}) bool CmpGte is a shortcut for:\nCmp(t, got, Gte(minExpectedValue), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also  CmpGte godoc.\n Examples    Int example   t := \u0026amp;testing.T{} got := 156 ok := CmpGte(t, got, 156, \u0026#34;checks %v is ≥ 156\u0026#34;, got) fmt.Println(ok) ok = CmpGte(t, got, 155, \u0026#34;checks %v is ≥ 155\u0026#34;, got) fmt.Println(ok) ok = CmpGte(t, got, 157, \u0026#34;checks %v is ≥ 157\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// true \t// false     String example   t := \u0026amp;testing.T{} got := \u0026#34;abc\u0026#34; ok := CmpGte(t, got, \u0026#34;abc\u0026#34;, `checks \u0026#34;%v\u0026#34; is ≥ \u0026#34;abc\u0026#34;`, got) fmt.Println(ok) ok = CmpGte(t, got, \u0026#34;abb\u0026#34;, `checks \u0026#34;%v\u0026#34; is ≥ \u0026#34;abb\u0026#34;`, got) fmt.Println(ok) ok = CmpGte(t, got, \u0026#34;abd\u0026#34;, `checks \u0026#34;%v\u0026#34; is ≥ \u0026#34;abd\u0026#34;`, got) fmt.Println(ok) // Output: \t// true \t// true \t// false  \nT.Gte shortcut func (t *T) Gte(got interface{}, minExpectedValue interface{}, args ...interface{}) bool Gte is a shortcut for:\nt.Cmp(got, Gte(minExpectedValue), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also  T.Gte godoc.\n Examples    Int example   t := NewT(\u0026amp;testing.T{}) got := 156 ok := t.Gte(got, 156, \u0026#34;checks %v is ≥ 156\u0026#34;, got) fmt.Println(ok) ok = t.Gte(got, 155, \u0026#34;checks %v is ≥ 155\u0026#34;, got) fmt.Println(ok) ok = t.Gte(got, 157, \u0026#34;checks %v is ≥ 157\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// true \t// false     String example   t := NewT(\u0026amp;testing.T{}) got := \u0026#34;abc\u0026#34; ok := t.Gte(got, \u0026#34;abc\u0026#34;, `checks \u0026#34;%v\u0026#34; is ≥ \u0026#34;abc\u0026#34;`, got) fmt.Println(ok) ok = t.Gte(got, \u0026#34;abb\u0026#34;, `checks \u0026#34;%v\u0026#34; is ≥ \u0026#34;abb\u0026#34;`, got) fmt.Println(ok) ok = t.Gte(got, \u0026#34;abd\u0026#34;, `checks \u0026#34;%v\u0026#34; is ≥ \u0026#34;abd\u0026#34;`, got) fmt.Println(ok) // Output: \t// true \t// true \t// false  \n"
},
{
	"uri": "https://go-testdeep.zetta.rocks/operators/hasprefix/",
	"title": "HasPrefix",
	"tags": [],
	"description": "",
	"content": " func HasPrefix(expected string) TestDeep HasPrefix operator allows to compare the prefix of a string (or convertible), error or fmt.Stringer interface (error interface is tested before fmt.Stringer.)\ntype Foobar string Cmp(t, Foobar(\u0026#34;foobar\u0026#34;), HasPrefix(\u0026#34;foo\u0026#34;)) // succeeds  err := errors.New(\u0026#34;error!\u0026#34;) Cmp(t, err, HasPrefix(\u0026#34;err\u0026#34;)) // succeeds  bstr := bytes.NewBufferString(\u0026#34;fmt.Stringer!\u0026#34;) Cmp(t, bstr, HasPrefix(\u0026#34;fmt\u0026#34;)) // succeeds  See also  HasPrefix godoc.\n Examples    Base example   t := \u0026amp;testing.T{} got := \u0026#34;foobar\u0026#34; ok := Cmp(t, got, HasPrefix(\u0026#34;foo\u0026#34;), \u0026#34;checks %s\u0026#34;, got) fmt.Println(ok) // Output: \t// true     Stringer example   t := \u0026amp;testing.T{} // bytes.Buffer implements fmt.Stringer \tgot := bytes.NewBufferString(\u0026#34;foobar\u0026#34;) ok := Cmp(t, got, HasPrefix(\u0026#34;foo\u0026#34;), \u0026#34;checks %s\u0026#34;, got) fmt.Println(ok) // Output: \t// true     Error example   t := \u0026amp;testing.T{} got := errors.New(\u0026#34;foobar\u0026#34;) ok := Cmp(t, got, HasPrefix(\u0026#34;foo\u0026#34;), \u0026#34;checks %s\u0026#34;, got) fmt.Println(ok) // Output: \t// true  \nCmpHasPrefix shortcut func CmpHasPrefix(t TestingT, got interface{}, expected string, args ...interface{}) bool CmpHasPrefix is a shortcut for:\nCmp(t, got, HasPrefix(expected), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also  CmpHasPrefix godoc.\n Examples    Base example   t := \u0026amp;testing.T{} got := \u0026#34;foobar\u0026#34; ok := CmpHasPrefix(t, got, \u0026#34;foo\u0026#34;, \u0026#34;checks %s\u0026#34;, got) fmt.Println(ok) // Output: \t// true     Stringer example   t := \u0026amp;testing.T{} // bytes.Buffer implements fmt.Stringer \tgot := bytes.NewBufferString(\u0026#34;foobar\u0026#34;) ok := CmpHasPrefix(t, got, \u0026#34;foo\u0026#34;, \u0026#34;checks %s\u0026#34;, got) fmt.Println(ok) // Output: \t// true     Error example   t := \u0026amp;testing.T{} got := errors.New(\u0026#34;foobar\u0026#34;) ok := CmpHasPrefix(t, got, \u0026#34;foo\u0026#34;, \u0026#34;checks %s\u0026#34;, got) fmt.Println(ok) // Output: \t// true  \nT.HasPrefix shortcut func (t *T) HasPrefix(got interface{}, expected string, args ...interface{}) bool HasPrefix is a shortcut for:\nt.Cmp(got, HasPrefix(expected), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also  T.HasPrefix godoc.\n Examples    Base example   t := NewT(\u0026amp;testing.T{}) got := \u0026#34;foobar\u0026#34; ok := t.HasPrefix(got, \u0026#34;foo\u0026#34;, \u0026#34;checks %s\u0026#34;, got) fmt.Println(ok) // Output: \t// true     Stringer example   t := NewT(\u0026amp;testing.T{}) // bytes.Buffer implements fmt.Stringer \tgot := bytes.NewBufferString(\u0026#34;foobar\u0026#34;) ok := t.HasPrefix(got, \u0026#34;foo\u0026#34;, \u0026#34;checks %s\u0026#34;, got) fmt.Println(ok) // Output: \t// true     Error example   t := NewT(\u0026amp;testing.T{}) got := errors.New(\u0026#34;foobar\u0026#34;) ok := t.HasPrefix(got, \u0026#34;foo\u0026#34;, \u0026#34;checks %s\u0026#34;, got) fmt.Println(ok) // Output: \t// true  \n"
},
{
	"uri": "https://go-testdeep.zetta.rocks/operators/hassuffix/",
	"title": "HasSuffix",
	"tags": [],
	"description": "",
	"content": " func HasSuffix(expected string) TestDeep HasSuffix operator allows to compare the suffix of a string (or convertible), error or fmt.Stringer interface (error interface is tested before fmt.Stringer.)\ntype Foobar string Cmp(t, Foobar(\u0026#34;foobar\u0026#34;), HasSuffix(\u0026#34;bar\u0026#34;)) // succeeds  err := errors.New(\u0026#34;error!\u0026#34;) Cmp(t, err, HasSuffix(\u0026#34;!\u0026#34;)) // succeeds  bstr := bytes.NewBufferString(\u0026#34;fmt.Stringer!\u0026#34;) Cmp(t, bstr, HasSuffix(\u0026#34;!\u0026#34;)) // succeeds  See also  HasSuffix godoc.\n Examples    Base example   t := \u0026amp;testing.T{} got := \u0026#34;foobar\u0026#34; ok := Cmp(t, got, HasSuffix(\u0026#34;bar\u0026#34;), \u0026#34;checks %s\u0026#34;, got) fmt.Println(ok) // Output: \t// true     Stringer example   t := \u0026amp;testing.T{} // bytes.Buffer implements fmt.Stringer \tgot := bytes.NewBufferString(\u0026#34;foobar\u0026#34;) ok := Cmp(t, got, HasSuffix(\u0026#34;bar\u0026#34;), \u0026#34;checks %s\u0026#34;, got) fmt.Println(ok) // Output: \t// true     Error example   t := \u0026amp;testing.T{} got := errors.New(\u0026#34;foobar\u0026#34;) ok := Cmp(t, got, HasSuffix(\u0026#34;bar\u0026#34;), \u0026#34;checks %s\u0026#34;, got) fmt.Println(ok) // Output: \t// true  \nCmpHasSuffix shortcut func CmpHasSuffix(t TestingT, got interface{}, expected string, args ...interface{}) bool CmpHasSuffix is a shortcut for:\nCmp(t, got, HasSuffix(expected), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also  CmpHasSuffix godoc.\n Examples    Base example   t := \u0026amp;testing.T{} got := \u0026#34;foobar\u0026#34; ok := CmpHasSuffix(t, got, \u0026#34;bar\u0026#34;, \u0026#34;checks %s\u0026#34;, got) fmt.Println(ok) // Output: \t// true     Stringer example   t := \u0026amp;testing.T{} // bytes.Buffer implements fmt.Stringer \tgot := bytes.NewBufferString(\u0026#34;foobar\u0026#34;) ok := CmpHasSuffix(t, got, \u0026#34;bar\u0026#34;, \u0026#34;checks %s\u0026#34;, got) fmt.Println(ok) // Output: \t// true     Error example   t := \u0026amp;testing.T{} got := errors.New(\u0026#34;foobar\u0026#34;) ok := CmpHasSuffix(t, got, \u0026#34;bar\u0026#34;, \u0026#34;checks %s\u0026#34;, got) fmt.Println(ok) // Output: \t// true  \nT.HasSuffix shortcut func (t *T) HasSuffix(got interface{}, expected string, args ...interface{}) bool HasSuffix is a shortcut for:\nt.Cmp(got, HasSuffix(expected), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also  T.HasSuffix godoc.\n Examples    Base example   t := NewT(\u0026amp;testing.T{}) got := \u0026#34;foobar\u0026#34; ok := t.HasSuffix(got, \u0026#34;bar\u0026#34;, \u0026#34;checks %s\u0026#34;, got) fmt.Println(ok) // Output: \t// true     Stringer example   t := NewT(\u0026amp;testing.T{}) // bytes.Buffer implements fmt.Stringer \tgot := bytes.NewBufferString(\u0026#34;foobar\u0026#34;) ok := t.HasSuffix(got, \u0026#34;bar\u0026#34;, \u0026#34;checks %s\u0026#34;, got) fmt.Println(ok) // Output: \t// true     Error example   t := NewT(\u0026amp;testing.T{}) got := errors.New(\u0026#34;foobar\u0026#34;) ok := t.HasSuffix(got, \u0026#34;bar\u0026#34;, \u0026#34;checks %s\u0026#34;, got) fmt.Println(ok) // Output: \t// true  \n"
},
{
	"uri": "https://go-testdeep.zetta.rocks/operators/ignore/",
	"title": "Ignore",
	"tags": [],
	"description": "",
	"content": " func Ignore() TestDeep Ignore operator is always true, whatever data is. It is useful when comparing a slice and wanting to ignore some indexes, for example.\n See also  Ignore godoc.\n Examples   Base example   t := \u0026amp;testing.T{} ok := Cmp(t, []int{1, 2, 3}, Slice([]int{}, ArrayEntries{ 0: 1, 1: Ignore(), // do not care about this entry \t2: 3, })) fmt.Println(ok) // Output: \t// true   "
},
{
	"uri": "https://go-testdeep.zetta.rocks/operators/isa/",
	"title": "Isa",
	"tags": [],
	"description": "",
	"content": " func Isa(model interface{}) TestDeep Isa operator checks the data type or whether data implements an interface or not.\nTypically type checks:\nIsa(time.Time{}) Isa(\u0026amp;time.Time{}) Isa(map[string]time.Time{}) For interfaces it is a bit more complicated, as:\nfmt.Stringer(nil) is not an interface, but just nil\u0026hellip; To bypass this golang limitation, Isa accepts pointers on interfaces. So checking that data implements fmt.Stringer interface should be written as:\nIsa((*fmt.Stringer)(nil)) Of course, in the latter case, if data type is *fmt.Stringer, Isa will match too (in fact before checking whether it implements fmt.Stringer or not.)\nTypeBehind method returns the reflect.Type of model.\n See also  Isa godoc.\n Examples    Base example   t := \u0026amp;testing.T{} type TstStruct struct { Field int } got := TstStruct{Field: 1} ok := Cmp(t, got, Isa(TstStruct{}), \u0026#34;checks got is a TstStruct\u0026#34;) fmt.Println(ok) ok = Cmp(t, got, Isa(\u0026amp;TstStruct{}), \u0026#34;checks got is a pointer on a TstStruct\u0026#34;) fmt.Println(ok) ok = Cmp(t, \u0026amp;got, Isa(\u0026amp;TstStruct{}), \u0026#34;checks \u0026amp;got is a pointer on a TstStruct\u0026#34;) fmt.Println(ok) // Output: \t// true \t// false \t// true     Interface example   t := \u0026amp;testing.T{} got := bytes.NewBufferString(\u0026#34;foobar\u0026#34;) ok := Cmp(t, got, Isa((*fmt.Stringer)(nil)), \u0026#34;checks got implements fmt.Stringer interface\u0026#34;) fmt.Println(ok) errGot := fmt.Errorf(\u0026#34;An error #%d occurred\u0026#34;, 123) ok = Cmp(t, errGot, Isa((*error)(nil)), \u0026#34;checks errGot is a *error or implements error interface\u0026#34;) fmt.Println(ok) // As nil, is passed below, it is not an interface but nil... So it \t// does not match \terrGot = nil ok = Cmp(t, errGot, Isa((*error)(nil)), \u0026#34;checks errGot is a *error or implements error interface\u0026#34;) fmt.Println(ok) // BUT if its address is passed, now it is OK as the types match \tok = Cmp(t, \u0026amp;errGot, Isa((*error)(nil)), \u0026#34;checks \u0026amp;errGot is a *error or implements error interface\u0026#34;) fmt.Println(ok) // Output: \t// true \t// true \t// false \t// true  \nCmpIsa shortcut func CmpIsa(t TestingT, got interface{}, model interface{}, args ...interface{}) bool CmpIsa is a shortcut for:\nCmp(t, got, Isa(model), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also  CmpIsa godoc.\n Examples    Base example   t := \u0026amp;testing.T{} type TstStruct struct { Field int } got := TstStruct{Field: 1} ok := CmpIsa(t, got, TstStruct{}, \u0026#34;checks got is a TstStruct\u0026#34;) fmt.Println(ok) ok = CmpIsa(t, got, \u0026amp;TstStruct{}, \u0026#34;checks got is a pointer on a TstStruct\u0026#34;) fmt.Println(ok) ok = CmpIsa(t, \u0026amp;got, \u0026amp;TstStruct{}, \u0026#34;checks \u0026amp;got is a pointer on a TstStruct\u0026#34;) fmt.Println(ok) // Output: \t// true \t// false \t// true     Interface example   t := \u0026amp;testing.T{} got := bytes.NewBufferString(\u0026#34;foobar\u0026#34;) ok := CmpIsa(t, got, (*fmt.Stringer)(nil), \u0026#34;checks got implements fmt.Stringer interface\u0026#34;) fmt.Println(ok) errGot := fmt.Errorf(\u0026#34;An error #%d occurred\u0026#34;, 123) ok = CmpIsa(t, errGot, (*error)(nil), \u0026#34;checks errGot is a *error or implements error interface\u0026#34;) fmt.Println(ok) // As nil, is passed below, it is not an interface but nil... So it \t// does not match \terrGot = nil ok = CmpIsa(t, errGot, (*error)(nil), \u0026#34;checks errGot is a *error or implements error interface\u0026#34;) fmt.Println(ok) // BUT if its address is passed, now it is OK as the types match \tok = CmpIsa(t, \u0026amp;errGot, (*error)(nil), \u0026#34;checks \u0026amp;errGot is a *error or implements error interface\u0026#34;) fmt.Println(ok) // Output: \t// true \t// true \t// false \t// true  \nT.Isa shortcut func (t *T) Isa(got interface{}, model interface{}, args ...interface{}) bool Isa is a shortcut for:\nt.Cmp(got, Isa(model), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also  T.Isa godoc.\n Examples    Base example   t := NewT(\u0026amp;testing.T{}) type TstStruct struct { Field int } got := TstStruct{Field: 1} ok := t.Isa(got, TstStruct{}, \u0026#34;checks got is a TstStruct\u0026#34;) fmt.Println(ok) ok = t.Isa(got, \u0026amp;TstStruct{}, \u0026#34;checks got is a pointer on a TstStruct\u0026#34;) fmt.Println(ok) ok = t.Isa(\u0026amp;got, \u0026amp;TstStruct{}, \u0026#34;checks \u0026amp;got is a pointer on a TstStruct\u0026#34;) fmt.Println(ok) // Output: \t// true \t// false \t// true     Interface example   t := NewT(\u0026amp;testing.T{}) got := bytes.NewBufferString(\u0026#34;foobar\u0026#34;) ok := t.Isa(got, (*fmt.Stringer)(nil), \u0026#34;checks got implements fmt.Stringer interface\u0026#34;) fmt.Println(ok) errGot := fmt.Errorf(\u0026#34;An error #%d occurred\u0026#34;, 123) ok = t.Isa(errGot, (*error)(nil), \u0026#34;checks errGot is a *error or implements error interface\u0026#34;) fmt.Println(ok) // As nil, is passed below, it is not an interface but nil... So it \t// does not match \terrGot = nil ok = t.Isa(errGot, (*error)(nil), \u0026#34;checks errGot is a *error or implements error interface\u0026#34;) fmt.Println(ok) // BUT if its address is passed, now it is OK as the types match \tok = t.Isa(\u0026amp;errGot, (*error)(nil), \u0026#34;checks \u0026amp;errGot is a *error or implements error interface\u0026#34;) fmt.Println(ok) // Output: \t// true \t// true \t// false \t// true  \n"
},
{
	"uri": "https://go-testdeep.zetta.rocks/operators/json/",
	"title": "JSON",
	"tags": [],
	"description": "",
	"content": " func JSON(expectedJSON interface{}, params ...interface{}) TestDeep JSON operator allows to compare the JSON representation of data against expectedJSON. expectedJSON can be a:\n string containing JSON data like {\u0026quot;fullname\u0026quot;:\u0026quot;Bob\u0026quot;,\u0026quot;age\u0026quot;:42} string containing a JSON filename, ending with \u0026ldquo;.json\u0026rdquo; (its content is ioutil.ReadFile before unmarshaling) []byte containing JSON data io.Reader stream containing JSON data (is ioutil.ReadAll before unmarshaling)  expectedJSON JSON value can contain placeholders. The params are for any placeholder parameters in expectedJSON. params can contain TestDeep operators as well as raw values. A placeholder can be numeric like $2 or named like $name and always references an item in params.\nNumeric placeholders reference the n\u0026rsquo;th \u0026ldquo;operators\u0026rdquo; item (starting at 1). Named placeholders are used with Tag operator as follows:\nCmp(t, gotValue, JSON(`{\u0026#34;fullname\u0026#34;: $name, \u0026#34;age\u0026#34;: $2, \u0026#34;gender\u0026#34;: $3}`, Tag(\u0026#34;name\u0026#34;, HasPrefix(\u0026#34;Foo\u0026#34;)), // matches $1 and $name  Between(41, 43), // matches only $2  \u0026#34;male\u0026#34;)) // matches only $3 Note that placeholders can be double-quoted as in:\nCmp(t, gotValue, JSON(`{\u0026#34;fullname\u0026#34;: \u0026#34;$name\u0026#34;, \u0026#34;age\u0026#34;: \u0026#34;$2\u0026#34;, \u0026#34;gender\u0026#34;: \u0026#34;$3\u0026#34;}`, Tag(\u0026#34;name\u0026#34;, HasPrefix(\u0026#34;Foo\u0026#34;)), // matches $1 and $name  Between(41, 43), // matches only $2  \u0026#34;male\u0026#34;)) // matches only $3 It makes no difference whatever the underlying type of the replaced item is (= double quoting a placeholder matching a number is not a problem). It is just a matter of taste, double-quoting placeholders can be preferred when the JSON data has to conform to the JSON specification, like when used in a \u0026ldquo;.json\u0026rdquo; file.\nNote expectedJSON can be a []byte, JSON filename or io.Reader:\nCmp(t, gotValue, JSON(\u0026#34;file.json\u0026#34;, Between(12, 34))) Cmp(t, gotValue, JSON([]byte(`[1, $1, 3]`), Between(12, 34))) Cmp(t, gotValue, JSON(osFile, Between(12, 34))) A JSON filename ends with \u0026ldquo;.json\u0026rdquo;.\nTo avoid a legit \u0026ldquo;$\u0026rdquo; string prefix cause a bad placeholder error, just double it to escape it. Note it is only needed when the \u0026ldquo;$\u0026rdquo; is the first character of a string:\nCmp(t, gotValue, JSON(`{\u0026#34;fullname\u0026#34;: \u0026#34;$name\u0026#34;, \u0026#34;details\u0026#34;: \u0026#34;$$info\u0026#34;, \u0026#34;age\u0026#34;: $2}`, Tag(\u0026#34;name\u0026#34;, HasPrefix(\u0026#34;Foo\u0026#34;)), // matches $1 and $name  Between(41, 43))) // matches only $2 For the \u0026ldquo;details\u0026rdquo; key, the raw value \u0026ldquo;$info\u0026rdquo; is expected, no placeholders are involved here.\nLast but not least, Lax mode is automatically enabled by JSON operator to simplify numeric tests.\nTypeBehind method returns the reflect.Type of the expectedJSON json.Unmarshal\u0026lsquo;ed. So it can be bool, string, float64, []interface{}, map[string]interface{} or interface{} in case expectedJSON is \u0026ldquo;null\u0026rdquo;.\n See also  JSON godoc.\n Examples    Basic example   t := \u0026amp;testing.T{} got := \u0026amp;struct { Fullname string `json:\u0026#34;fullname\u0026#34;` Age int `json:\u0026#34;age\u0026#34;` }{ Fullname: \u0026#34;Bob\u0026#34;, Age: 42, } ok := Cmp(t, got, JSON(`{\u0026#34;age\u0026#34;:42,\u0026#34;fullname\u0026#34;:\u0026#34;Bob\u0026#34;}`)) fmt.Println(\u0026#34;check got with age then fullname:\u0026#34;, ok) ok = Cmp(t, got, JSON(`{\u0026#34;fullname\u0026#34;:\u0026#34;Bob\u0026#34;,\u0026#34;age\u0026#34;:42}`)) fmt.Println(\u0026#34;check got with fullname then age:\u0026#34;, ok) ok = Cmp(t, got, JSON(`{ \u0026#34;fullname\u0026#34;: \u0026#34;Bob\u0026#34;, \u0026#34;age\u0026#34;: 42 }`)) fmt.Println(\u0026#34;check got with nicely formatted JSON:\u0026#34;, ok) ok = Cmp(t, got, JSON(`{\u0026#34;fullname\u0026#34;:\u0026#34;Bob\u0026#34;,\u0026#34;age\u0026#34;:42,\u0026#34;gender\u0026#34;:\u0026#34;male\u0026#34;}`)) fmt.Println(\u0026#34;check got with gender field:\u0026#34;, ok) ok = Cmp(t, got, JSON(`{\u0026#34;fullname\u0026#34;:\u0026#34;Bob\u0026#34;}`)) fmt.Println(\u0026#34;check got with fullname only:\u0026#34;, ok) ok = Cmp(t, true, JSON(`true`)) fmt.Println(\u0026#34;check boolean got is true:\u0026#34;, ok) ok = Cmp(t, 42, JSON(`42`)) fmt.Println(\u0026#34;check numeric got is 42:\u0026#34;, ok) got = nil ok = Cmp(t, got, JSON(`null`)) fmt.Println(\u0026#34;check nil got is null:\u0026#34;, ok) // Output: \t// check got with age then fullname: true \t// check got with fullname then age: true \t// check got with nicely formatted JSON: true \t// check got with gender field: false \t// check got with fullname only: false \t// check boolean got is true: true \t// check numeric got is 42: true \t// check nil got is null: true     Placeholders example   t := \u0026amp;testing.T{} got := \u0026amp;struct { Fullname string `json:\u0026#34;fullname\u0026#34;` Age int `json:\u0026#34;age\u0026#34;` }{ Fullname: \u0026#34;Bob Foobar\u0026#34;, Age: 42, } ok := Cmp(t, got, JSON(`{\u0026#34;age\u0026#34;: $1, \u0026#34;fullname\u0026#34;: $2}`, 42, \u0026#34;Bob Foobar\u0026#34;)) fmt.Println(\u0026#34;check got with numeric placeholders without operators:\u0026#34;, ok) ok = Cmp(t, got, JSON(`{\u0026#34;age\u0026#34;: $1, \u0026#34;fullname\u0026#34;: $2}`, Between(40, 45), HasSuffix(\u0026#34;Foobar\u0026#34;))) fmt.Println(\u0026#34;check got with numeric placeholders:\u0026#34;, ok) ok = Cmp(t, got, JSON(`{\u0026#34;age\u0026#34;: \u0026#34;$1\u0026#34;, \u0026#34;fullname\u0026#34;: \u0026#34;$2\u0026#34;}`, Between(40, 45), HasSuffix(\u0026#34;Foobar\u0026#34;))) fmt.Println(\u0026#34;check got with double-quoted numeric placeholders:\u0026#34;, ok) ok = Cmp(t, got, JSON(`{\u0026#34;age\u0026#34;: $age, \u0026#34;fullname\u0026#34;: $name}`, Tag(\u0026#34;age\u0026#34;, Between(40, 45)), Tag(\u0026#34;name\u0026#34;, HasSuffix(\u0026#34;Foobar\u0026#34;)))) fmt.Println(\u0026#34;check got with named placeholders:\u0026#34;, ok) // Output: \t// check got with numeric placeholders without operators: true \t// check got with numeric placeholders: true \t// check got with double-quoted numeric placeholders: true \t// check got with named placeholders: true     File example   t := \u0026amp;testing.T{} got := \u0026amp;struct { Fullname string `json:\u0026#34;fullname\u0026#34;` Age int `json:\u0026#34;age\u0026#34;` Gender string `json:\u0026#34;gender\u0026#34;` }{ Fullname: \u0026#34;Bob Foobar\u0026#34;, Age: 42, Gender: \u0026#34;male\u0026#34;, } tmpDir, err := ioutil.TempDir(\u0026#34;\u0026#34;, \u0026#34;\u0026#34;) if err != nil { t.Fatal(err) } defer os.RemoveAll(tmpDir) // clean up  filename := tmpDir + \u0026#34;/test.json\u0026#34; if err = ioutil.WriteFile(filename, []byte(` { \u0026#34;fullname\u0026#34;: \u0026#34;$name\u0026#34;, \u0026#34;age\u0026#34;: \u0026#34;$age\u0026#34;, \u0026#34;gender\u0026#34;: \u0026#34;$gender\u0026#34; }`), 0644); err != nil { t.Fatal(err) } // OK let\u0026#39;s test with this file \tok := Cmp(t, got, JSON(filename, Tag(\u0026#34;name\u0026#34;, HasPrefix(\u0026#34;Bob\u0026#34;)), Tag(\u0026#34;age\u0026#34;, Between(40, 45)), Tag(\u0026#34;gender\u0026#34;, Re(`^(male|female)\\z`)))) fmt.Println(\u0026#34;Full match from file name:\u0026#34;, ok) // When the file is already open \tfile, err := os.Open(filename) if err != nil { t.Fatal(err) } ok = Cmp(t, got, JSON(file, Tag(\u0026#34;name\u0026#34;, HasPrefix(\u0026#34;Bob\u0026#34;)), Tag(\u0026#34;age\u0026#34;, Between(40, 45)), Tag(\u0026#34;gender\u0026#34;, Re(`^(male|female)\\z`)))) fmt.Println(\u0026#34;Full match from io.Reader:\u0026#34;, ok) // Output: \t// Full match from file name: true \t// Full match from io.Reader: true  \nCmpJSON shortcut func CmpJSON(t TestingT, got interface{}, expectedJSON interface{}, params []interface{}, args ...interface{}) bool CmpJSON is a shortcut for:\nCmp(t, got, JSON(expectedJSON, params...), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also  CmpJSON godoc.\n Examples    Basic example   t := \u0026amp;testing.T{} got := \u0026amp;struct { Fullname string `json:\u0026#34;fullname\u0026#34;` Age int `json:\u0026#34;age\u0026#34;` }{ Fullname: \u0026#34;Bob\u0026#34;, Age: 42, } ok := CmpJSON(t, got, `{\u0026#34;age\u0026#34;:42,\u0026#34;fullname\u0026#34;:\u0026#34;Bob\u0026#34;}`, nil) fmt.Println(\u0026#34;check got with age then fullname:\u0026#34;, ok) ok = CmpJSON(t, got, `{\u0026#34;fullname\u0026#34;:\u0026#34;Bob\u0026#34;,\u0026#34;age\u0026#34;:42}`, nil) fmt.Println(\u0026#34;check got with fullname then age:\u0026#34;, ok) ok = CmpJSON(t, got, `{ \u0026#34;fullname\u0026#34;: \u0026#34;Bob\u0026#34;, \u0026#34;age\u0026#34;: 42 }`, nil) fmt.Println(\u0026#34;check got with nicely formatted JSON:\u0026#34;, ok) ok = CmpJSON(t, got, `{\u0026#34;fullname\u0026#34;:\u0026#34;Bob\u0026#34;,\u0026#34;age\u0026#34;:42,\u0026#34;gender\u0026#34;:\u0026#34;male\u0026#34;}`, nil) fmt.Println(\u0026#34;check got with gender field:\u0026#34;, ok) ok = CmpJSON(t, got, `{\u0026#34;fullname\u0026#34;:\u0026#34;Bob\u0026#34;}`, nil) fmt.Println(\u0026#34;check got with fullname only:\u0026#34;, ok) ok = CmpJSON(t, true, `true`, nil) fmt.Println(\u0026#34;check boolean got is true:\u0026#34;, ok) ok = CmpJSON(t, 42, `42`, nil) fmt.Println(\u0026#34;check numeric got is 42:\u0026#34;, ok) got = nil ok = CmpJSON(t, got, `null`, nil) fmt.Println(\u0026#34;check nil got is null:\u0026#34;, ok) // Output: \t// check got with age then fullname: true \t// check got with fullname then age: true \t// check got with nicely formatted JSON: true \t// check got with gender field: false \t// check got with fullname only: false \t// check boolean got is true: true \t// check numeric got is 42: true \t// check nil got is null: true     Placeholders example   t := \u0026amp;testing.T{} got := \u0026amp;struct { Fullname string `json:\u0026#34;fullname\u0026#34;` Age int `json:\u0026#34;age\u0026#34;` }{ Fullname: \u0026#34;Bob Foobar\u0026#34;, Age: 42, } ok := CmpJSON(t, got, `{\u0026#34;age\u0026#34;: $1, \u0026#34;fullname\u0026#34;: $2}`, []interface{}{42, \u0026#34;Bob Foobar\u0026#34;}) fmt.Println(\u0026#34;check got with numeric placeholders without operators:\u0026#34;, ok) ok = CmpJSON(t, got, `{\u0026#34;age\u0026#34;: $1, \u0026#34;fullname\u0026#34;: $2}`, []interface{}{Between(40, 45), HasSuffix(\u0026#34;Foobar\u0026#34;)}) fmt.Println(\u0026#34;check got with numeric placeholders:\u0026#34;, ok) ok = CmpJSON(t, got, `{\u0026#34;age\u0026#34;: \u0026#34;$1\u0026#34;, \u0026#34;fullname\u0026#34;: \u0026#34;$2\u0026#34;}`, []interface{}{Between(40, 45), HasSuffix(\u0026#34;Foobar\u0026#34;)}) fmt.Println(\u0026#34;check got with double-quoted numeric placeholders:\u0026#34;, ok) ok = CmpJSON(t, got, `{\u0026#34;age\u0026#34;: $age, \u0026#34;fullname\u0026#34;: $name}`, []interface{}{Tag(\u0026#34;age\u0026#34;, Between(40, 45)), Tag(\u0026#34;name\u0026#34;, HasSuffix(\u0026#34;Foobar\u0026#34;))}) fmt.Println(\u0026#34;check got with named placeholders:\u0026#34;, ok) // Output: \t// check got with numeric placeholders without operators: true \t// check got with numeric placeholders: true \t// check got with double-quoted numeric placeholders: true \t// check got with named placeholders: true     File example   t := \u0026amp;testing.T{} got := \u0026amp;struct { Fullname string `json:\u0026#34;fullname\u0026#34;` Age int `json:\u0026#34;age\u0026#34;` Gender string `json:\u0026#34;gender\u0026#34;` }{ Fullname: \u0026#34;Bob Foobar\u0026#34;, Age: 42, Gender: \u0026#34;male\u0026#34;, } tmpDir, err := ioutil.TempDir(\u0026#34;\u0026#34;, \u0026#34;\u0026#34;) if err != nil { t.Fatal(err) } defer os.RemoveAll(tmpDir) // clean up  filename := tmpDir + \u0026#34;/test.json\u0026#34; if err = ioutil.WriteFile(filename, []byte(` { \u0026#34;fullname\u0026#34;: \u0026#34;$name\u0026#34;, \u0026#34;age\u0026#34;: \u0026#34;$age\u0026#34;, \u0026#34;gender\u0026#34;: \u0026#34;$gender\u0026#34; }`), 0644); err != nil { t.Fatal(err) } // OK let\u0026#39;s test with this file \tok := CmpJSON(t, got, filename, []interface{}{Tag(\u0026#34;name\u0026#34;, HasPrefix(\u0026#34;Bob\u0026#34;)), Tag(\u0026#34;age\u0026#34;, Between(40, 45)), Tag(\u0026#34;gender\u0026#34;, Re(`^(male|female)\\z`))}) fmt.Println(\u0026#34;Full match from file name:\u0026#34;, ok) // When the file is already open \tfile, err := os.Open(filename) if err != nil { t.Fatal(err) } ok = CmpJSON(t, got, file, []interface{}{Tag(\u0026#34;name\u0026#34;, HasPrefix(\u0026#34;Bob\u0026#34;)), Tag(\u0026#34;age\u0026#34;, Between(40, 45)), Tag(\u0026#34;gender\u0026#34;, Re(`^(male|female)\\z`))}) fmt.Println(\u0026#34;Full match from io.Reader:\u0026#34;, ok) // Output: \t// Full match from file name: true \t// Full match from io.Reader: true  \nT.JSON shortcut func (t *T) JSON(got interface{}, expectedJSON interface{}, params []interface{}, args ...interface{}) bool JSON is a shortcut for:\nt.Cmp(got, JSON(expectedJSON, params...), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also  T.JSON godoc.\n Examples    Basic example   t := NewT(\u0026amp;testing.T{}) got := \u0026amp;struct { Fullname string `json:\u0026#34;fullname\u0026#34;` Age int `json:\u0026#34;age\u0026#34;` }{ Fullname: \u0026#34;Bob\u0026#34;, Age: 42, } ok := t.JSON(got, `{\u0026#34;age\u0026#34;:42,\u0026#34;fullname\u0026#34;:\u0026#34;Bob\u0026#34;}`, nil) fmt.Println(\u0026#34;check got with age then fullname:\u0026#34;, ok) ok = t.JSON(got, `{\u0026#34;fullname\u0026#34;:\u0026#34;Bob\u0026#34;,\u0026#34;age\u0026#34;:42}`, nil) fmt.Println(\u0026#34;check got with fullname then age:\u0026#34;, ok) ok = t.JSON(got, `{ \u0026#34;fullname\u0026#34;: \u0026#34;Bob\u0026#34;, \u0026#34;age\u0026#34;: 42 }`, nil) fmt.Println(\u0026#34;check got with nicely formatted JSON:\u0026#34;, ok) ok = t.JSON(got, `{\u0026#34;fullname\u0026#34;:\u0026#34;Bob\u0026#34;,\u0026#34;age\u0026#34;:42,\u0026#34;gender\u0026#34;:\u0026#34;male\u0026#34;}`, nil) fmt.Println(\u0026#34;check got with gender field:\u0026#34;, ok) ok = t.JSON(got, `{\u0026#34;fullname\u0026#34;:\u0026#34;Bob\u0026#34;}`, nil) fmt.Println(\u0026#34;check got with fullname only:\u0026#34;, ok) ok = t.JSON(true, `true`, nil) fmt.Println(\u0026#34;check boolean got is true:\u0026#34;, ok) ok = t.JSON(42, `42`, nil) fmt.Println(\u0026#34;check numeric got is 42:\u0026#34;, ok) got = nil ok = t.JSON(got, `null`, nil) fmt.Println(\u0026#34;check nil got is null:\u0026#34;, ok) // Output: \t// check got with age then fullname: true \t// check got with fullname then age: true \t// check got with nicely formatted JSON: true \t// check got with gender field: false \t// check got with fullname only: false \t// check boolean got is true: true \t// check numeric got is 42: true \t// check nil got is null: true     Placeholders example   t := NewT(\u0026amp;testing.T{}) got := \u0026amp;struct { Fullname string `json:\u0026#34;fullname\u0026#34;` Age int `json:\u0026#34;age\u0026#34;` }{ Fullname: \u0026#34;Bob Foobar\u0026#34;, Age: 42, } ok := t.JSON(got, `{\u0026#34;age\u0026#34;: $1, \u0026#34;fullname\u0026#34;: $2}`, []interface{}{42, \u0026#34;Bob Foobar\u0026#34;}) fmt.Println(\u0026#34;check got with numeric placeholders without operators:\u0026#34;, ok) ok = t.JSON(got, `{\u0026#34;age\u0026#34;: $1, \u0026#34;fullname\u0026#34;: $2}`, []interface{}{Between(40, 45), HasSuffix(\u0026#34;Foobar\u0026#34;)}) fmt.Println(\u0026#34;check got with numeric placeholders:\u0026#34;, ok) ok = t.JSON(got, `{\u0026#34;age\u0026#34;: \u0026#34;$1\u0026#34;, \u0026#34;fullname\u0026#34;: \u0026#34;$2\u0026#34;}`, []interface{}{Between(40, 45), HasSuffix(\u0026#34;Foobar\u0026#34;)}) fmt.Println(\u0026#34;check got with double-quoted numeric placeholders:\u0026#34;, ok) ok = t.JSON(got, `{\u0026#34;age\u0026#34;: $age, \u0026#34;fullname\u0026#34;: $name}`, []interface{}{Tag(\u0026#34;age\u0026#34;, Between(40, 45)), Tag(\u0026#34;name\u0026#34;, HasSuffix(\u0026#34;Foobar\u0026#34;))}) fmt.Println(\u0026#34;check got with named placeholders:\u0026#34;, ok) // Output: \t// check got with numeric placeholders without operators: true \t// check got with numeric placeholders: true \t// check got with double-quoted numeric placeholders: true \t// check got with named placeholders: true     File example   t := NewT(\u0026amp;testing.T{}) got := \u0026amp;struct { Fullname string `json:\u0026#34;fullname\u0026#34;` Age int `json:\u0026#34;age\u0026#34;` Gender string `json:\u0026#34;gender\u0026#34;` }{ Fullname: \u0026#34;Bob Foobar\u0026#34;, Age: 42, Gender: \u0026#34;male\u0026#34;, } tmpDir, err := ioutil.TempDir(\u0026#34;\u0026#34;, \u0026#34;\u0026#34;) if err != nil { t.Fatal(err) } defer os.RemoveAll(tmpDir) // clean up  filename := tmpDir + \u0026#34;/test.json\u0026#34; if err = ioutil.WriteFile(filename, []byte(` { \u0026#34;fullname\u0026#34;: \u0026#34;$name\u0026#34;, \u0026#34;age\u0026#34;: \u0026#34;$age\u0026#34;, \u0026#34;gender\u0026#34;: \u0026#34;$gender\u0026#34; }`), 0644); err != nil { t.Fatal(err) } // OK let\u0026#39;s test with this file \tok := t.JSON(got, filename, []interface{}{Tag(\u0026#34;name\u0026#34;, HasPrefix(\u0026#34;Bob\u0026#34;)), Tag(\u0026#34;age\u0026#34;, Between(40, 45)), Tag(\u0026#34;gender\u0026#34;, Re(`^(male|female)\\z`))}) fmt.Println(\u0026#34;Full match from file name:\u0026#34;, ok) // When the file is already open \tfile, err := os.Open(filename) if err != nil { t.Fatal(err) } ok = t.JSON(got, file, []interface{}{Tag(\u0026#34;name\u0026#34;, HasPrefix(\u0026#34;Bob\u0026#34;)), Tag(\u0026#34;age\u0026#34;, Between(40, 45)), Tag(\u0026#34;gender\u0026#34;, Re(`^(male|female)\\z`))}) fmt.Println(\u0026#34;Full match from io.Reader:\u0026#34;, ok) // Output: \t// Full match from file name: true \t// Full match from io.Reader: true  \n"
},
{
	"uri": "https://go-testdeep.zetta.rocks/operators/keys/",
	"title": "Keys",
	"tags": [],
	"description": "",
	"content": " func Keys(val interface{}) TestDeep Keys is a smuggler operator. It takes a map and compares its ordered keys to val.\nval can be a slice of items of the same type as the map keys:\nKeys([]string{\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;}) as well as an other operator:\nKeys(Bag(\u0026#34;c\u0026#34;, \u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;))  See also  Keys godoc.\n Examples   Base example   t := \u0026amp;testing.T{} got := map[string]int{\u0026#34;foo\u0026#34;: 1, \u0026#34;bar\u0026#34;: 2, \u0026#34;zip\u0026#34;: 3} // Keys tests keys in an ordered manner \tok := Cmp(t, got, Keys([]string{\u0026#34;bar\u0026#34;, \u0026#34;foo\u0026#34;, \u0026#34;zip\u0026#34;})) fmt.Println(\u0026#34;All sorted keys are found:\u0026#34;, ok) // If the expected keys are not ordered, it fails \tok = Cmp(t, got, Keys([]string{\u0026#34;zip\u0026#34;, \u0026#34;bar\u0026#34;, \u0026#34;foo\u0026#34;})) fmt.Println(\u0026#34;All unsorted keys are found:\u0026#34;, ok) // To circumvent that, one can use Bag operator \tok = Cmp(t, got, Keys(Bag(\u0026#34;zip\u0026#34;, \u0026#34;bar\u0026#34;, \u0026#34;foo\u0026#34;))) fmt.Println(\u0026#34;All unsorted keys are found, with the help of Bag operator:\u0026#34;, ok) // Check that each key is 3 bytes long \tok = Cmp(t, got, Keys(ArrayEach(Len(3)))) fmt.Println(\u0026#34;Each key is 3 bytes long:\u0026#34;, ok) // Output: \t// All sorted keys are found: true \t// All unsorted keys are found: false \t// All unsorted keys are found, with the help of Bag operator: true \t// Each key is 3 bytes long: true   CmpKeys shortcut func CmpKeys(t TestingT, got interface{}, val interface{}, args ...interface{}) bool CmpKeys is a shortcut for:\nCmp(t, got, Keys(val), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also  CmpKeys godoc.\n Examples   Base example   t := \u0026amp;testing.T{} got := map[string]int{\u0026#34;foo\u0026#34;: 1, \u0026#34;bar\u0026#34;: 2, \u0026#34;zip\u0026#34;: 3} // Keys tests keys in an ordered manner \tok := CmpKeys(t, got, []string{\u0026#34;bar\u0026#34;, \u0026#34;foo\u0026#34;, \u0026#34;zip\u0026#34;}) fmt.Println(\u0026#34;All sorted keys are found:\u0026#34;, ok) // If the expected keys are not ordered, it fails \tok = CmpKeys(t, got, []string{\u0026#34;zip\u0026#34;, \u0026#34;bar\u0026#34;, \u0026#34;foo\u0026#34;}) fmt.Println(\u0026#34;All unsorted keys are found:\u0026#34;, ok) // To circumvent that, one can use Bag operator \tok = CmpKeys(t, got, Bag(\u0026#34;zip\u0026#34;, \u0026#34;bar\u0026#34;, \u0026#34;foo\u0026#34;)) fmt.Println(\u0026#34;All unsorted keys are found, with the help of Bag operator:\u0026#34;, ok) // Check that each key is 3 bytes long \tok = CmpKeys(t, got, ArrayEach(Len(3))) fmt.Println(\u0026#34;Each key is 3 bytes long:\u0026#34;, ok) // Output: \t// All sorted keys are found: true \t// All unsorted keys are found: false \t// All unsorted keys are found, with the help of Bag operator: true \t// Each key is 3 bytes long: true   T.Keys shortcut func (t *T) Keys(got interface{}, val interface{}, args ...interface{}) bool Keys is a shortcut for:\nt.Cmp(got, Keys(val), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also  T.Keys godoc.\n Examples   Base example   t := NewT(\u0026amp;testing.T{}) got := map[string]int{\u0026#34;foo\u0026#34;: 1, \u0026#34;bar\u0026#34;: 2, \u0026#34;zip\u0026#34;: 3} // Keys tests keys in an ordered manner \tok := t.Keys(got, []string{\u0026#34;bar\u0026#34;, \u0026#34;foo\u0026#34;, \u0026#34;zip\u0026#34;}) fmt.Println(\u0026#34;All sorted keys are found:\u0026#34;, ok) // If the expected keys are not ordered, it fails \tok = t.Keys(got, []string{\u0026#34;zip\u0026#34;, \u0026#34;bar\u0026#34;, \u0026#34;foo\u0026#34;}) fmt.Println(\u0026#34;All unsorted keys are found:\u0026#34;, ok) // To circumvent that, one can use Bag operator \tok = t.Keys(got, Bag(\u0026#34;zip\u0026#34;, \u0026#34;bar\u0026#34;, \u0026#34;foo\u0026#34;)) fmt.Println(\u0026#34;All unsorted keys are found, with the help of Bag operator:\u0026#34;, ok) // Check that each key is 3 bytes long \tok = t.Keys(got, ArrayEach(Len(3))) fmt.Println(\u0026#34;Each key is 3 bytes long:\u0026#34;, ok) // Output: \t// All sorted keys are found: true \t// All unsorted keys are found: false \t// All unsorted keys are found, with the help of Bag operator: true \t// Each key is 3 bytes long: true   "
},
{
	"uri": "https://go-testdeep.zetta.rocks/operators/lax/",
	"title": "Lax",
	"tags": [],
	"description": "",
	"content": " func Lax(expectedValue interface{}) TestDeep Lax is a smuggler operator, it temporarily enables the BeLax config flag before letting the comparison process continue its course.\nIt is more commonly used as CmpLax function than as an operator. It could be used when, for example, an operator is constructed once but applied to different, but compatible types as in:\nbw := Between(20, 30) intValue := 21 floatValue := 21.89 Cmp(t, intValue, bw) // no need to be lax here: same int types Cmp(t, floatValue, Lax(bw)) // be lax please, as float64 ≠ int Note that in the latter case, CmpLax() could be used as well:\nCmpLax(t, floatValue, bw) TypeBehind method returns the greatest convertible or more common reflect.Type of expectedValue if it is a base type (bool, int*, uint*, float*, complex*, string), the reflect.Type of expectedValue otherwise, except if expectedValue is a TestDeep operator. In this case, it delegates TypeBehind() to the operator.\n See also  Lax godoc.\n Examples   Base example   t := \u0026amp;testing.T{} gotInt64 := int64(1234) gotInt32 := int32(1235) type myInt uint16 gotMyInt := myInt(1236) expected := Between(1230, 1240) // int type here  ok := Cmp(t, gotInt64, Lax(expected)) fmt.Println(\u0026#34;int64 got between ints [1230 .. 1240]:\u0026#34;, ok) ok = Cmp(t, gotInt32, Lax(expected)) fmt.Println(\u0026#34;int32 got between ints [1230 .. 1240]:\u0026#34;, ok) ok = Cmp(t, gotMyInt, Lax(expected)) fmt.Println(\u0026#34;myInt got between ints [1230 .. 1240]:\u0026#34;, ok) // Output: \t// int64 got between ints [1230 .. 1240]: true \t// int32 got between ints [1230 .. 1240]: true \t// myInt got between ints [1230 .. 1240]: true   CmpLax shortcut func CmpLax(t TestingT, got interface{}, expectedValue interface{}, args ...interface{}) bool CmpLax is a shortcut for:\nCmp(t, got, Lax(expectedValue), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also  CmpLax godoc.\n Examples   Base example   t := \u0026amp;testing.T{} gotInt64 := int64(1234) gotInt32 := int32(1235) type myInt uint16 gotMyInt := myInt(1236) expected := Between(1230, 1240) // int type here  ok := CmpLax(t, gotInt64, expected) fmt.Println(\u0026#34;int64 got between ints [1230 .. 1240]:\u0026#34;, ok) ok = CmpLax(t, gotInt32, expected) fmt.Println(\u0026#34;int32 got between ints [1230 .. 1240]:\u0026#34;, ok) ok = CmpLax(t, gotMyInt, expected) fmt.Println(\u0026#34;myInt got between ints [1230 .. 1240]:\u0026#34;, ok) // Output: \t// int64 got between ints [1230 .. 1240]: true \t// int32 got between ints [1230 .. 1240]: true \t// myInt got between ints [1230 .. 1240]: true   T.CmpLax shortcut func (t *T) CmpLax(got interface{}, expectedValue interface{}, args ...interface{}) bool CmpLax is a shortcut for:\nt.Cmp(got, Lax(expectedValue), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also  T.CmpLax godoc.\n Examples   Base example   t := NewT(\u0026amp;testing.T{}) gotInt64 := int64(1234) gotInt32 := int32(1235) type myInt uint16 gotMyInt := myInt(1236) expected := Between(1230, 1240) // int type here  ok := t.CmpLax(gotInt64, expected) fmt.Println(\u0026#34;int64 got between ints [1230 .. 1240]:\u0026#34;, ok) ok = t.CmpLax(gotInt32, expected) fmt.Println(\u0026#34;int32 got between ints [1230 .. 1240]:\u0026#34;, ok) ok = t.CmpLax(gotMyInt, expected) fmt.Println(\u0026#34;myInt got between ints [1230 .. 1240]:\u0026#34;, ok) // Output: \t// int64 got between ints [1230 .. 1240]: true \t// int32 got between ints [1230 .. 1240]: true \t// myInt got between ints [1230 .. 1240]: true   "
},
{
	"uri": "https://go-testdeep.zetta.rocks/operators/len/",
	"title": "Len",
	"tags": [],
	"description": "",
	"content": " func Len(expectedLen interface{}) TestDeep Len is a smuggler operator. It takes data, applies len() function on it and compares its result to expectedLen. Of course, the compared value must be an array, a channel, a map, a slice or a string.\nexpectedLen can be an int value:\nCmp(t, gotSlice, Len(12)) as well as an other operator:\nCmp(t, gotSlice, Len(Between(3, 4)))  See also  Len godoc.\n Examples    Slice example   t := \u0026amp;testing.T{} got := []int{11, 22, 33} ok := Cmp(t, got, Len(3), \u0026#34;checks %v len is 3\u0026#34;, got) fmt.Println(ok) ok = Cmp(t, got, Len(0), \u0026#34;checks %v len is 0\u0026#34;, got) fmt.Println(ok) got = nil ok = Cmp(t, got, Len(0), \u0026#34;checks %v len is 0\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// false \t// true     Map example   t := \u0026amp;testing.T{} got := map[int]bool{11: true, 22: false, 33: false} ok := Cmp(t, got, Len(3), \u0026#34;checks %v len is 3\u0026#34;, got) fmt.Println(ok) ok = Cmp(t, got, Len(0), \u0026#34;checks %v len is 0\u0026#34;, got) fmt.Println(ok) got = nil ok = Cmp(t, got, Len(0), \u0026#34;checks %v len is 0\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// false \t// true     OperatorSlice example   t := \u0026amp;testing.T{} got := []int{11, 22, 33} ok := Cmp(t, got, Len(Between(3, 8)), \u0026#34;checks %v len is in [3 .. 8]\u0026#34;, got) fmt.Println(ok) ok = Cmp(t, got, Len(Lt(5)), \u0026#34;checks %v len is \u0026lt; 5\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// true     OperatorMap example   t := \u0026amp;testing.T{} got := map[int]bool{11: true, 22: false, 33: false} ok := Cmp(t, got, Len(Between(3, 8)), \u0026#34;checks %v len is in [3 .. 8]\u0026#34;, got) fmt.Println(ok) ok = Cmp(t, got, Len(Gte(3)), \u0026#34;checks %v len is ≥ 3\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// true  \nCmpLen shortcut func CmpLen(t TestingT, got interface{}, expectedLen interface{}, args ...interface{}) bool CmpLen is a shortcut for:\nCmp(t, got, Len(expectedLen), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also  CmpLen godoc.\n Examples    Slice example   t := \u0026amp;testing.T{} got := []int{11, 22, 33} ok := CmpLen(t, got, 3, \u0026#34;checks %v len is 3\u0026#34;, got) fmt.Println(ok) ok = CmpLen(t, got, 0, \u0026#34;checks %v len is 0\u0026#34;, got) fmt.Println(ok) got = nil ok = CmpLen(t, got, 0, \u0026#34;checks %v len is 0\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// false \t// true     Map example   t := \u0026amp;testing.T{} got := map[int]bool{11: true, 22: false, 33: false} ok := CmpLen(t, got, 3, \u0026#34;checks %v len is 3\u0026#34;, got) fmt.Println(ok) ok = CmpLen(t, got, 0, \u0026#34;checks %v len is 0\u0026#34;, got) fmt.Println(ok) got = nil ok = CmpLen(t, got, 0, \u0026#34;checks %v len is 0\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// false \t// true     OperatorSlice example   t := \u0026amp;testing.T{} got := []int{11, 22, 33} ok := CmpLen(t, got, Between(3, 8), \u0026#34;checks %v len is in [3 .. 8]\u0026#34;, got) fmt.Println(ok) ok = CmpLen(t, got, Lt(5), \u0026#34;checks %v len is \u0026lt; 5\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// true     OperatorMap example   t := \u0026amp;testing.T{} got := map[int]bool{11: true, 22: false, 33: false} ok := CmpLen(t, got, Between(3, 8), \u0026#34;checks %v len is in [3 .. 8]\u0026#34;, got) fmt.Println(ok) ok = CmpLen(t, got, Gte(3), \u0026#34;checks %v len is ≥ 3\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// true  \nT.Len shortcut func (t *T) Len(got interface{}, expectedLen interface{}, args ...interface{}) bool Len is a shortcut for:\nt.Cmp(got, Len(expectedLen), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also  T.Len godoc.\n Examples    Slice example   t := NewT(\u0026amp;testing.T{}) got := []int{11, 22, 33} ok := t.Len(got, 3, \u0026#34;checks %v len is 3\u0026#34;, got) fmt.Println(ok) ok = t.Len(got, 0, \u0026#34;checks %v len is 0\u0026#34;, got) fmt.Println(ok) got = nil ok = t.Len(got, 0, \u0026#34;checks %v len is 0\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// false \t// true     Map example   t := NewT(\u0026amp;testing.T{}) got := map[int]bool{11: true, 22: false, 33: false} ok := t.Len(got, 3, \u0026#34;checks %v len is 3\u0026#34;, got) fmt.Println(ok) ok = t.Len(got, 0, \u0026#34;checks %v len is 0\u0026#34;, got) fmt.Println(ok) got = nil ok = t.Len(got, 0, \u0026#34;checks %v len is 0\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// false \t// true     OperatorSlice example   t := NewT(\u0026amp;testing.T{}) got := []int{11, 22, 33} ok := t.Len(got, Between(3, 8), \u0026#34;checks %v len is in [3 .. 8]\u0026#34;, got) fmt.Println(ok) ok = t.Len(got, Lt(5), \u0026#34;checks %v len is \u0026lt; 5\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// true     OperatorMap example   t := NewT(\u0026amp;testing.T{}) got := map[int]bool{11: true, 22: false, 33: false} ok := t.Len(got, Between(3, 8), \u0026#34;checks %v len is in [3 .. 8]\u0026#34;, got) fmt.Println(ok) ok = t.Len(got, Gte(3), \u0026#34;checks %v len is ≥ 3\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// true  \n"
},
{
	"uri": "https://go-testdeep.zetta.rocks/operators/lt/",
	"title": "Lt",
	"tags": [],
	"description": "",
	"content": " func Lt(maxExpectedValue interface{}) TestDeep Lt operator checks that data is lesser than maxExpectedValue. maxExpectedValue can be any numeric or time.Time (or assignable) value. maxExpectedValue must be the same kind as the compared value if numeric, and the same type if time.Time (or assignable).\nTypeBehind method returns the reflect.Type of maxExpectedValue.\n See also  Lt godoc.\n Examples    Int example   t := \u0026amp;testing.T{} got := 156 ok := Cmp(t, got, Lt(157), \u0026#34;checks %v is \u0026lt; 157\u0026#34;, got) fmt.Println(ok) ok = Cmp(t, got, Lt(156), \u0026#34;checks %v is \u0026lt; 156\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// false     String example   t := \u0026amp;testing.T{} got := \u0026#34;abc\u0026#34; ok := Cmp(t, got, Lt(\u0026#34;abd\u0026#34;), `checks \u0026#34;%v\u0026#34; is \u0026lt; \u0026#34;abd\u0026#34;`, got) fmt.Println(ok) ok = Cmp(t, got, Lt(\u0026#34;abc\u0026#34;), `checks \u0026#34;%v\u0026#34; is \u0026lt; \u0026#34;abc\u0026#34;`, got) fmt.Println(ok) // Output: \t// true \t// false  \nCmpLt shortcut func CmpLt(t TestingT, got interface{}, maxExpectedValue interface{}, args ...interface{}) bool CmpLt is a shortcut for:\nCmp(t, got, Lt(maxExpectedValue), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also  CmpLt godoc.\n Examples    Int example   t := \u0026amp;testing.T{} got := 156 ok := CmpLt(t, got, 157, \u0026#34;checks %v is \u0026lt; 157\u0026#34;, got) fmt.Println(ok) ok = CmpLt(t, got, 156, \u0026#34;checks %v is \u0026lt; 156\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// false     String example   t := \u0026amp;testing.T{} got := \u0026#34;abc\u0026#34; ok := CmpLt(t, got, \u0026#34;abd\u0026#34;, `checks \u0026#34;%v\u0026#34; is \u0026lt; \u0026#34;abd\u0026#34;`, got) fmt.Println(ok) ok = CmpLt(t, got, \u0026#34;abc\u0026#34;, `checks \u0026#34;%v\u0026#34; is \u0026lt; \u0026#34;abc\u0026#34;`, got) fmt.Println(ok) // Output: \t// true \t// false  \nT.Lt shortcut func (t *T) Lt(got interface{}, maxExpectedValue interface{}, args ...interface{}) bool Lt is a shortcut for:\nt.Cmp(got, Lt(maxExpectedValue), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also  T.Lt godoc.\n Examples    Int example   t := NewT(\u0026amp;testing.T{}) got := 156 ok := t.Lt(got, 157, \u0026#34;checks %v is \u0026lt; 157\u0026#34;, got) fmt.Println(ok) ok = t.Lt(got, 156, \u0026#34;checks %v is \u0026lt; 156\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// false     String example   t := NewT(\u0026amp;testing.T{}) got := \u0026#34;abc\u0026#34; ok := t.Lt(got, \u0026#34;abd\u0026#34;, `checks \u0026#34;%v\u0026#34; is \u0026lt; \u0026#34;abd\u0026#34;`, got) fmt.Println(ok) ok = t.Lt(got, \u0026#34;abc\u0026#34;, `checks \u0026#34;%v\u0026#34; is \u0026lt; \u0026#34;abc\u0026#34;`, got) fmt.Println(ok) // Output: \t// true \t// false  \n"
},
{
	"uri": "https://go-testdeep.zetta.rocks/operators/lte/",
	"title": "Lte",
	"tags": [],
	"description": "",
	"content": " func Lte(maxExpectedValue interface{}) TestDeep Lte operator checks that data is lesser or equal than maxExpectedValue. maxExpectedValue can be any numeric or time.Time (or assignable) value. maxExpectedValue must be the same kind as the compared value if numeric, and the same type if time.Time (or assignable).\nTypeBehind method returns the reflect.Type of maxExpectedValue.\n See also  Lte godoc.\n Examples    Int example   t := \u0026amp;testing.T{} got := 156 ok := Cmp(t, got, Lte(156), \u0026#34;checks %v is ≤ 156\u0026#34;, got) fmt.Println(ok) ok = Cmp(t, got, Lte(157), \u0026#34;checks %v is ≤ 157\u0026#34;, got) fmt.Println(ok) ok = Cmp(t, got, Lte(155), \u0026#34;checks %v is ≤ 155\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// true \t// false     String example   t := \u0026amp;testing.T{} got := \u0026#34;abc\u0026#34; ok := Cmp(t, got, Lte(\u0026#34;abc\u0026#34;), `checks \u0026#34;%v\u0026#34; is ≤ \u0026#34;abc\u0026#34;`, got) fmt.Println(ok) ok = Cmp(t, got, Lte(\u0026#34;abd\u0026#34;), `checks \u0026#34;%v\u0026#34; is ≤ \u0026#34;abd\u0026#34;`, got) fmt.Println(ok) ok = Cmp(t, got, Lte(\u0026#34;abb\u0026#34;), `checks \u0026#34;%v\u0026#34; is ≤ \u0026#34;abb\u0026#34;`, got) fmt.Println(ok) // Output: \t// true \t// true \t// false  \nCmpLte shortcut func CmpLte(t TestingT, got interface{}, maxExpectedValue interface{}, args ...interface{}) bool CmpLte is a shortcut for:\nCmp(t, got, Lte(maxExpectedValue), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also  CmpLte godoc.\n Examples    Int example   t := \u0026amp;testing.T{} got := 156 ok := CmpLte(t, got, 156, \u0026#34;checks %v is ≤ 156\u0026#34;, got) fmt.Println(ok) ok = CmpLte(t, got, 157, \u0026#34;checks %v is ≤ 157\u0026#34;, got) fmt.Println(ok) ok = CmpLte(t, got, 155, \u0026#34;checks %v is ≤ 155\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// true \t// false     String example   t := \u0026amp;testing.T{} got := \u0026#34;abc\u0026#34; ok := CmpLte(t, got, \u0026#34;abc\u0026#34;, `checks \u0026#34;%v\u0026#34; is ≤ \u0026#34;abc\u0026#34;`, got) fmt.Println(ok) ok = CmpLte(t, got, \u0026#34;abd\u0026#34;, `checks \u0026#34;%v\u0026#34; is ≤ \u0026#34;abd\u0026#34;`, got) fmt.Println(ok) ok = CmpLte(t, got, \u0026#34;abb\u0026#34;, `checks \u0026#34;%v\u0026#34; is ≤ \u0026#34;abb\u0026#34;`, got) fmt.Println(ok) // Output: \t// true \t// true \t// false  \nT.Lte shortcut func (t *T) Lte(got interface{}, maxExpectedValue interface{}, args ...interface{}) bool Lte is a shortcut for:\nt.Cmp(got, Lte(maxExpectedValue), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also  T.Lte godoc.\n Examples    Int example   t := NewT(\u0026amp;testing.T{}) got := 156 ok := t.Lte(got, 156, \u0026#34;checks %v is ≤ 156\u0026#34;, got) fmt.Println(ok) ok = t.Lte(got, 157, \u0026#34;checks %v is ≤ 157\u0026#34;, got) fmt.Println(ok) ok = t.Lte(got, 155, \u0026#34;checks %v is ≤ 155\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// true \t// false     String example   t := NewT(\u0026amp;testing.T{}) got := \u0026#34;abc\u0026#34; ok := t.Lte(got, \u0026#34;abc\u0026#34;, `checks \u0026#34;%v\u0026#34; is ≤ \u0026#34;abc\u0026#34;`, got) fmt.Println(ok) ok = t.Lte(got, \u0026#34;abd\u0026#34;, `checks \u0026#34;%v\u0026#34; is ≤ \u0026#34;abd\u0026#34;`, got) fmt.Println(ok) ok = t.Lte(got, \u0026#34;abb\u0026#34;, `checks \u0026#34;%v\u0026#34; is ≤ \u0026#34;abb\u0026#34;`, got) fmt.Println(ok) // Output: \t// true \t// true \t// false  \n"
},
{
	"uri": "https://go-testdeep.zetta.rocks/operators/map/",
	"title": "Map",
	"tags": [],
	"description": "",
	"content": " func Map(model interface{}, expectedEntries MapEntries) TestDeep Map operator compares the contents of a map against the non-zero values of model (if any) and the values of expectedEntries.\nmodel must be the same type as compared data.\nexpectedEntries can be nil, if no zero entries are expected and no TestDeep operator are involved.\nDuring a match, all expected entries must be found and all data entries must be expected to succeed.\nTypeBehind method returns the reflect.Type of model.\n See also  Map godoc.\n Examples    Map example   t := \u0026amp;testing.T{} got := map[string]int{\u0026#34;foo\u0026#34;: 12, \u0026#34;bar\u0026#34;: 42, \u0026#34;zip\u0026#34;: 89} ok := Cmp(t, got, Map(map[string]int{\u0026#34;bar\u0026#34;: 42}, MapEntries{\u0026#34;foo\u0026#34;: Lt(15), \u0026#34;zip\u0026#34;: Ignore()}), \u0026#34;checks map %v\u0026#34;, got) fmt.Println(ok) ok = Cmp(t, got, Map(map[string]int{}, MapEntries{\u0026#34;bar\u0026#34;: 42, \u0026#34;foo\u0026#34;: Lt(15), \u0026#34;zip\u0026#34;: Ignore()}), \u0026#34;checks map %v\u0026#34;, got) fmt.Println(ok) ok = Cmp(t, got, Map((map[string]int)(nil), MapEntries{\u0026#34;bar\u0026#34;: 42, \u0026#34;foo\u0026#34;: Lt(15), \u0026#34;zip\u0026#34;: Ignore()}), \u0026#34;checks map %v\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// true \t// true     TypedMap example   t := \u0026amp;testing.T{} type MyMap map[string]int got := MyMap{\u0026#34;foo\u0026#34;: 12, \u0026#34;bar\u0026#34;: 42, \u0026#34;zip\u0026#34;: 89} ok := Cmp(t, got, Map(MyMap{\u0026#34;bar\u0026#34;: 42}, MapEntries{\u0026#34;foo\u0026#34;: Lt(15), \u0026#34;zip\u0026#34;: Ignore()}), \u0026#34;checks typed map %v\u0026#34;, got) fmt.Println(ok) ok = Cmp(t, \u0026amp;got, Map(\u0026amp;MyMap{\u0026#34;bar\u0026#34;: 42}, MapEntries{\u0026#34;foo\u0026#34;: Lt(15), \u0026#34;zip\u0026#34;: Ignore()}), \u0026#34;checks pointer on typed map %v\u0026#34;, got) fmt.Println(ok) ok = Cmp(t, \u0026amp;got, Map(\u0026amp;MyMap{}, MapEntries{\u0026#34;bar\u0026#34;: 42, \u0026#34;foo\u0026#34;: Lt(15), \u0026#34;zip\u0026#34;: Ignore()}), \u0026#34;checks pointer on typed map %v\u0026#34;, got) fmt.Println(ok) ok = Cmp(t, \u0026amp;got, Map((*MyMap)(nil), MapEntries{\u0026#34;bar\u0026#34;: 42, \u0026#34;foo\u0026#34;: Lt(15), \u0026#34;zip\u0026#34;: Ignore()}), \u0026#34;checks pointer on typed map %v\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// true \t// true \t// true  \nCmpMap shortcut func CmpMap(t TestingT, got interface{}, model interface{}, expectedEntries MapEntries, args ...interface{}) bool CmpMap is a shortcut for:\nCmp(t, got, Map(model, expectedEntries), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also  CmpMap godoc.\n Examples    Map example   t := \u0026amp;testing.T{} got := map[string]int{\u0026#34;foo\u0026#34;: 12, \u0026#34;bar\u0026#34;: 42, \u0026#34;zip\u0026#34;: 89} ok := CmpMap(t, got, map[string]int{\u0026#34;bar\u0026#34;: 42}, MapEntries{\u0026#34;foo\u0026#34;: Lt(15), \u0026#34;zip\u0026#34;: Ignore()}, \u0026#34;checks map %v\u0026#34;, got) fmt.Println(ok) ok = CmpMap(t, got, map[string]int{}, MapEntries{\u0026#34;bar\u0026#34;: 42, \u0026#34;foo\u0026#34;: Lt(15), \u0026#34;zip\u0026#34;: Ignore()}, \u0026#34;checks map %v\u0026#34;, got) fmt.Println(ok) ok = CmpMap(t, got, (map[string]int)(nil), MapEntries{\u0026#34;bar\u0026#34;: 42, \u0026#34;foo\u0026#34;: Lt(15), \u0026#34;zip\u0026#34;: Ignore()}, \u0026#34;checks map %v\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// true \t// true     TypedMap example   t := \u0026amp;testing.T{} type MyMap map[string]int got := MyMap{\u0026#34;foo\u0026#34;: 12, \u0026#34;bar\u0026#34;: 42, \u0026#34;zip\u0026#34;: 89} ok := CmpMap(t, got, MyMap{\u0026#34;bar\u0026#34;: 42}, MapEntries{\u0026#34;foo\u0026#34;: Lt(15), \u0026#34;zip\u0026#34;: Ignore()}, \u0026#34;checks typed map %v\u0026#34;, got) fmt.Println(ok) ok = CmpMap(t, \u0026amp;got, \u0026amp;MyMap{\u0026#34;bar\u0026#34;: 42}, MapEntries{\u0026#34;foo\u0026#34;: Lt(15), \u0026#34;zip\u0026#34;: Ignore()}, \u0026#34;checks pointer on typed map %v\u0026#34;, got) fmt.Println(ok) ok = CmpMap(t, \u0026amp;got, \u0026amp;MyMap{}, MapEntries{\u0026#34;bar\u0026#34;: 42, \u0026#34;foo\u0026#34;: Lt(15), \u0026#34;zip\u0026#34;: Ignore()}, \u0026#34;checks pointer on typed map %v\u0026#34;, got) fmt.Println(ok) ok = CmpMap(t, \u0026amp;got, (*MyMap)(nil), MapEntries{\u0026#34;bar\u0026#34;: 42, \u0026#34;foo\u0026#34;: Lt(15), \u0026#34;zip\u0026#34;: Ignore()}, \u0026#34;checks pointer on typed map %v\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// true \t// true \t// true  \nT.Map shortcut func (t *T) Map(got interface{}, model interface{}, expectedEntries MapEntries, args ...interface{}) bool Map is a shortcut for:\nt.Cmp(got, Map(model, expectedEntries), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also  T.Map godoc.\n Examples    Map example   t := NewT(\u0026amp;testing.T{}) got := map[string]int{\u0026#34;foo\u0026#34;: 12, \u0026#34;bar\u0026#34;: 42, \u0026#34;zip\u0026#34;: 89} ok := t.Map(got, map[string]int{\u0026#34;bar\u0026#34;: 42}, MapEntries{\u0026#34;foo\u0026#34;: Lt(15), \u0026#34;zip\u0026#34;: Ignore()}, \u0026#34;checks map %v\u0026#34;, got) fmt.Println(ok) ok = t.Map(got, map[string]int{}, MapEntries{\u0026#34;bar\u0026#34;: 42, \u0026#34;foo\u0026#34;: Lt(15), \u0026#34;zip\u0026#34;: Ignore()}, \u0026#34;checks map %v\u0026#34;, got) fmt.Println(ok) ok = t.Map(got, (map[string]int)(nil), MapEntries{\u0026#34;bar\u0026#34;: 42, \u0026#34;foo\u0026#34;: Lt(15), \u0026#34;zip\u0026#34;: Ignore()}, \u0026#34;checks map %v\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// true \t// true     TypedMap example   t := NewT(\u0026amp;testing.T{}) type MyMap map[string]int got := MyMap{\u0026#34;foo\u0026#34;: 12, \u0026#34;bar\u0026#34;: 42, \u0026#34;zip\u0026#34;: 89} ok := t.Map(got, MyMap{\u0026#34;bar\u0026#34;: 42}, MapEntries{\u0026#34;foo\u0026#34;: Lt(15), \u0026#34;zip\u0026#34;: Ignore()}, \u0026#34;checks typed map %v\u0026#34;, got) fmt.Println(ok) ok = t.Map(\u0026amp;got, \u0026amp;MyMap{\u0026#34;bar\u0026#34;: 42}, MapEntries{\u0026#34;foo\u0026#34;: Lt(15), \u0026#34;zip\u0026#34;: Ignore()}, \u0026#34;checks pointer on typed map %v\u0026#34;, got) fmt.Println(ok) ok = t.Map(\u0026amp;got, \u0026amp;MyMap{}, MapEntries{\u0026#34;bar\u0026#34;: 42, \u0026#34;foo\u0026#34;: Lt(15), \u0026#34;zip\u0026#34;: Ignore()}, \u0026#34;checks pointer on typed map %v\u0026#34;, got) fmt.Println(ok) ok = t.Map(\u0026amp;got, (*MyMap)(nil), MapEntries{\u0026#34;bar\u0026#34;: 42, \u0026#34;foo\u0026#34;: Lt(15), \u0026#34;zip\u0026#34;: Ignore()}, \u0026#34;checks pointer on typed map %v\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// true \t// true \t// true  \n"
},
{
	"uri": "https://go-testdeep.zetta.rocks/operators/mapeach/",
	"title": "MapEach",
	"tags": [],
	"description": "",
	"content": " func MapEach(expectedValue interface{}) TestDeep MapEach operator has to be applied on maps. It compares each value of data map against expected value. During a match, all values have to match to succeed.\n See also  MapEach godoc.\n Examples    Map example   t := \u0026amp;testing.T{} got := map[string]int{\u0026#34;foo\u0026#34;: 12, \u0026#34;bar\u0026#34;: 42, \u0026#34;zip\u0026#34;: 89} ok := Cmp(t, got, MapEach(Between(10, 90)), \u0026#34;checks each value of map %v is in [10 .. 90]\u0026#34;, got) fmt.Println(ok) // Output: \t// true     TypedMap example   t := \u0026amp;testing.T{} type MyMap map[string]int got := MyMap{\u0026#34;foo\u0026#34;: 12, \u0026#34;bar\u0026#34;: 42, \u0026#34;zip\u0026#34;: 89} ok := Cmp(t, got, MapEach(Between(10, 90)), \u0026#34;checks each value of typed map %v is in [10 .. 90]\u0026#34;, got) fmt.Println(ok) ok = Cmp(t, \u0026amp;got, MapEach(Between(10, 90)), \u0026#34;checks each value of typed map pointer %v is in [10 .. 90]\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// true  \nCmpMapEach shortcut func CmpMapEach(t TestingT, got interface{}, expectedValue interface{}, args ...interface{}) bool CmpMapEach is a shortcut for:\nCmp(t, got, MapEach(expectedValue), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also  CmpMapEach godoc.\n Examples    Map example   t := \u0026amp;testing.T{} got := map[string]int{\u0026#34;foo\u0026#34;: 12, \u0026#34;bar\u0026#34;: 42, \u0026#34;zip\u0026#34;: 89} ok := CmpMapEach(t, got, Between(10, 90), \u0026#34;checks each value of map %v is in [10 .. 90]\u0026#34;, got) fmt.Println(ok) // Output: \t// true     TypedMap example   t := \u0026amp;testing.T{} type MyMap map[string]int got := MyMap{\u0026#34;foo\u0026#34;: 12, \u0026#34;bar\u0026#34;: 42, \u0026#34;zip\u0026#34;: 89} ok := CmpMapEach(t, got, Between(10, 90), \u0026#34;checks each value of typed map %v is in [10 .. 90]\u0026#34;, got) fmt.Println(ok) ok = CmpMapEach(t, \u0026amp;got, Between(10, 90), \u0026#34;checks each value of typed map pointer %v is in [10 .. 90]\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// true  \nT.MapEach shortcut func (t *T) MapEach(got interface{}, expectedValue interface{}, args ...interface{}) bool MapEach is a shortcut for:\nt.Cmp(got, MapEach(expectedValue), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also  T.MapEach godoc.\n Examples    Map example   t := NewT(\u0026amp;testing.T{}) got := map[string]int{\u0026#34;foo\u0026#34;: 12, \u0026#34;bar\u0026#34;: 42, \u0026#34;zip\u0026#34;: 89} ok := t.MapEach(got, Between(10, 90), \u0026#34;checks each value of map %v is in [10 .. 90]\u0026#34;, got) fmt.Println(ok) // Output: \t// true     TypedMap example   t := NewT(\u0026amp;testing.T{}) type MyMap map[string]int got := MyMap{\u0026#34;foo\u0026#34;: 12, \u0026#34;bar\u0026#34;: 42, \u0026#34;zip\u0026#34;: 89} ok := t.MapEach(got, Between(10, 90), \u0026#34;checks each value of typed map %v is in [10 .. 90]\u0026#34;, got) fmt.Println(ok) ok = t.MapEach(\u0026amp;got, Between(10, 90), \u0026#34;checks each value of typed map pointer %v is in [10 .. 90]\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// true  \n"
},
{
	"uri": "https://go-testdeep.zetta.rocks/operators/n/",
	"title": "N",
	"tags": [],
	"description": "",
	"content": " func N(num interface{}, tolerance ...interface{}) TestDeep N operator compares a numeric data against num ± tolerance. If tolerance is missing, it defaults to 0. num and tolerance must be the same kind as the compared value.\nTypeBehind method returns the reflect.Type of num.\n See also  N godoc.\n Examples   Base example   t := \u0026amp;testing.T{} got := 1.12345 ok := Cmp(t, got, N(1.1234, 0.00006), \u0026#34;checks %v = 1.1234 ± 0.00006\u0026#34;, got) fmt.Println(ok) // Output: \t// true   CmpN shortcut func CmpN(t TestingT, got interface{}, num interface{}, tolerance interface{}, args ...interface{}) bool CmpN is a shortcut for:\nCmp(t, got, N(num, tolerance), args...) See above for details.\nN() optional parameter tolerance is here mandatory. 0 value should be passed to mimic its absence in original N() call.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also  CmpN godoc.\n Examples   Base example   t := \u0026amp;testing.T{} got := 1.12345 ok := CmpN(t, got, 1.1234, 0.00006, \u0026#34;checks %v = 1.1234 ± 0.00006\u0026#34;, got) fmt.Println(ok) // Output: \t// true   T.N shortcut func (t *T) N(got interface{}, num interface{}, tolerance interface{}, args ...interface{}) bool N is a shortcut for:\nt.Cmp(got, N(num, tolerance), args...) See above for details.\nN() optional parameter tolerance is here mandatory. 0 value should be passed to mimic its absence in original N() call.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also  T.N godoc.\n Examples   Base example   t := NewT(\u0026amp;testing.T{}) got := 1.12345 ok := t.N(got, 1.1234, 0.00006, \u0026#34;checks %v = 1.1234 ± 0.00006\u0026#34;, got) fmt.Println(ok) // Output: \t// true   "
},
{
	"uri": "https://go-testdeep.zetta.rocks/operators/nan/",
	"title": "NaN",
	"tags": [],
	"description": "",
	"content": " func NaN() TestDeep NaN operator checks that data is a float and is not-a-number.\n See also  NaN godoc.\n Examples    Float32 example   t := \u0026amp;testing.T{} got := float32(math.NaN()) ok := Cmp(t, got, NaN(), \u0026#34;checks %v is not-a-number\u0026#34;, got) fmt.Println(\u0026#34;float32(math.NaN()) is float32 not-a-number:\u0026#34;, ok) got = 12 ok = Cmp(t, got, NaN(), \u0026#34;checks %v is not-a-number\u0026#34;, got) fmt.Println(\u0026#34;float32(12) is float32 not-a-number:\u0026#34;, ok) // Output: \t// float32(math.NaN()) is float32 not-a-number: true \t// float32(12) is float32 not-a-number: false     Float64 example   t := \u0026amp;testing.T{} got := math.NaN() ok := Cmp(t, got, NaN(), \u0026#34;checks %v is not-a-number\u0026#34;, got) fmt.Println(\u0026#34;math.NaN() is not-a-number:\u0026#34;, ok) got = 12 ok = Cmp(t, got, NaN(), \u0026#34;checks %v is not-a-number\u0026#34;, got) fmt.Println(\u0026#34;float64(12) is not-a-number:\u0026#34;, ok) // math.NaN() is not-a-number: true \t// float64(12) is not-a-number: false  \nCmpNaN shortcut func CmpNaN(t TestingT, got interface{}, args ...interface{}) bool CmpNaN is a shortcut for:\nCmp(t, got, NaN(), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also  CmpNaN godoc.\n Examples    Float32 example   t := \u0026amp;testing.T{} got := float32(math.NaN()) ok := CmpNaN(t, got, \u0026#34;checks %v is not-a-number\u0026#34;, got) fmt.Println(\u0026#34;float32(math.NaN()) is float32 not-a-number:\u0026#34;, ok) got = 12 ok = CmpNaN(t, got, \u0026#34;checks %v is not-a-number\u0026#34;, got) fmt.Println(\u0026#34;float32(12) is float32 not-a-number:\u0026#34;, ok) // Output: \t// float32(math.NaN()) is float32 not-a-number: true \t// float32(12) is float32 not-a-number: false     Float64 example   t := \u0026amp;testing.T{} got := math.NaN() ok := CmpNaN(t, got, \u0026#34;checks %v is not-a-number\u0026#34;, got) fmt.Println(\u0026#34;math.NaN() is not-a-number:\u0026#34;, ok) got = 12 ok = CmpNaN(t, got, \u0026#34;checks %v is not-a-number\u0026#34;, got) fmt.Println(\u0026#34;float64(12) is not-a-number:\u0026#34;, ok) // math.NaN() is not-a-number: true \t// float64(12) is not-a-number: false  \nT.NaN shortcut func (t *T) NaN(got interface{}, args ...interface{}) bool NaN is a shortcut for:\nt.Cmp(got, NaN(), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also  T.NaN godoc.\n Examples    Float32 example   t := NewT(\u0026amp;testing.T{}) got := float32(math.NaN()) ok := t.NaN(got, \u0026#34;checks %v is not-a-number\u0026#34;, got) fmt.Println(\u0026#34;float32(math.NaN()) is float32 not-a-number:\u0026#34;, ok) got = 12 ok = t.NaN(got, \u0026#34;checks %v is not-a-number\u0026#34;, got) fmt.Println(\u0026#34;float32(12) is float32 not-a-number:\u0026#34;, ok) // Output: \t// float32(math.NaN()) is float32 not-a-number: true \t// float32(12) is float32 not-a-number: false     Float64 example   t := NewT(\u0026amp;testing.T{}) got := math.NaN() ok := t.NaN(got, \u0026#34;checks %v is not-a-number\u0026#34;, got) fmt.Println(\u0026#34;math.NaN() is not-a-number:\u0026#34;, ok) got = 12 ok = t.NaN(got, \u0026#34;checks %v is not-a-number\u0026#34;, got) fmt.Println(\u0026#34;float64(12) is not-a-number:\u0026#34;, ok) // math.NaN() is not-a-number: true \t// float64(12) is not-a-number: false  \n"
},
{
	"uri": "https://go-testdeep.zetta.rocks/operators/nil/",
	"title": "Nil",
	"tags": [],
	"description": "",
	"content": " func Nil() TestDeep Nil operator checks that data is nil (or is a non-nil interface, but containing a nil pointer.)\n See also  Nil godoc.\n Examples   Base example   t := \u0026amp;testing.T{} var got fmt.Stringer // interface  // nil value can be compared directly with nil, no need of Nil() here \tok := Cmp(t, got, nil) fmt.Println(ok) // But it works with Nil() anyway \tok = Cmp(t, got, Nil()) fmt.Println(ok) got = (*bytes.Buffer)(nil) // In the case of an interface containing a nil pointer, comparing \t// with nil fails, as the interface is not nil \tok = Cmp(t, got, nil) fmt.Println(ok) // In this case Nil() succeed \tok = Cmp(t, got, Nil()) fmt.Println(ok) // Output: \t// true \t// true \t// false \t// true   CmpNil shortcut func CmpNil(t TestingT, got interface{}, args ...interface{}) bool CmpNil is a shortcut for:\nCmp(t, got, Nil(), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also  CmpNil godoc.\n Examples   Base example   t := \u0026amp;testing.T{} var got fmt.Stringer // interface  // nil value can be compared directly with nil, no need of Nil() here \tok := Cmp(t, got, nil) fmt.Println(ok) // But it works with Nil() anyway \tok = CmpNil(t, got) fmt.Println(ok) got = (*bytes.Buffer)(nil) // In the case of an interface containing a nil pointer, comparing \t// with nil fails, as the interface is not nil \tok = Cmp(t, got, nil) fmt.Println(ok) // In this case Nil() succeed \tok = CmpNil(t, got) fmt.Println(ok) // Output: \t// true \t// true \t// false \t// true   T.Nil shortcut func (t *T) Nil(got interface{}, args ...interface{}) bool Nil is a shortcut for:\nt.Cmp(got, Nil(), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also  T.Nil godoc.\n Examples   Base example   t := NewT(\u0026amp;testing.T{}) var got fmt.Stringer // interface  // nil value can be compared directly with nil, no need of Nil() here \tok := t.Cmp(got, nil) fmt.Println(ok) // But it works with Nil() anyway \tok = t.Nil(got) fmt.Println(ok) got = (*bytes.Buffer)(nil) // In the case of an interface containing a nil pointer, comparing \t// with nil fails, as the interface is not nil \tok = t.Cmp(got, nil) fmt.Println(ok) // In this case Nil() succeed \tok = t.Nil(got) fmt.Println(ok) // Output: \t// true \t// true \t// false \t// true   "
},
{
	"uri": "https://go-testdeep.zetta.rocks/operators/none/",
	"title": "None",
	"tags": [],
	"description": "",
	"content": " func None(notExpectedValues ...interface{}) TestDeep None operator compares data against several not expected values. During a match, none of them have to match to succeed.\n See also  None godoc.\n Examples   Base example   t := \u0026amp;testing.T{} got := 18 ok := Cmp(t, got, None(0, 10, 20, 30, Between(100, 199)), \u0026#34;checks %v is non-null, and ≠ 10, 20 \u0026amp; 30, and not in [100-199]\u0026#34;, got) fmt.Println(ok) got = 20 ok = Cmp(t, got, None(0, 10, 20, 30, Between(100, 199)), \u0026#34;checks %v is non-null, and ≠ 10, 20 \u0026amp; 30, and not in [100-199]\u0026#34;, got) fmt.Println(ok) got = 142 ok = Cmp(t, got, None(0, 10, 20, 30, Between(100, 199)), \u0026#34;checks %v is non-null, and ≠ 10, 20 \u0026amp; 30, and not in [100-199]\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// false \t// false   CmpNone shortcut func CmpNone(t TestingT, got interface{}, notExpectedValues []interface{}, args ...interface{}) bool CmpNone is a shortcut for:\nCmp(t, got, None(notExpectedValues...), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also  CmpNone godoc.\n Examples   Base example   t := \u0026amp;testing.T{} got := 18 ok := CmpNone(t, got, []interface{}{0, 10, 20, 30, Between(100, 199)}, \u0026#34;checks %v is non-null, and ≠ 10, 20 \u0026amp; 30, and not in [100-199]\u0026#34;, got) fmt.Println(ok) got = 20 ok = CmpNone(t, got, []interface{}{0, 10, 20, 30, Between(100, 199)}, \u0026#34;checks %v is non-null, and ≠ 10, 20 \u0026amp; 30, and not in [100-199]\u0026#34;, got) fmt.Println(ok) got = 142 ok = CmpNone(t, got, []interface{}{0, 10, 20, 30, Between(100, 199)}, \u0026#34;checks %v is non-null, and ≠ 10, 20 \u0026amp; 30, and not in [100-199]\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// false \t// false   T.None shortcut func (t *T) None(got interface{}, notExpectedValues []interface{}, args ...interface{}) bool None is a shortcut for:\nt.Cmp(got, None(notExpectedValues...), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also  T.None godoc.\n Examples   Base example   t := NewT(\u0026amp;testing.T{}) got := 18 ok := t.None(got, []interface{}{0, 10, 20, 30, Between(100, 199)}, \u0026#34;checks %v is non-null, and ≠ 10, 20 \u0026amp; 30, and not in [100-199]\u0026#34;, got) fmt.Println(ok) got = 20 ok = t.None(got, []interface{}{0, 10, 20, 30, Between(100, 199)}, \u0026#34;checks %v is non-null, and ≠ 10, 20 \u0026amp; 30, and not in [100-199]\u0026#34;, got) fmt.Println(ok) got = 142 ok = t.None(got, []interface{}{0, 10, 20, 30, Between(100, 199)}, \u0026#34;checks %v is non-null, and ≠ 10, 20 \u0026amp; 30, and not in [100-199]\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// false \t// false   "
},
{
	"uri": "https://go-testdeep.zetta.rocks/operators/not/",
	"title": "Not",
	"tags": [],
	"description": "",
	"content": " func Not(notExpected interface{}) TestDeep Not operator compares data against the not expected value. During a match, it must not match to succeed.\nNot is the same operator as None() with only one argument. It is provided as a more readable function when only one argument is needed.\n See also  Not godoc.\n Examples   Base example   t := \u0026amp;testing.T{} got := 42 ok := Cmp(t, got, Not(0), \u0026#34;checks %v is non-null\u0026#34;, got) fmt.Println(ok) ok = Cmp(t, got, Not(Between(10, 30)), \u0026#34;checks %v is not in [10 .. 30]\u0026#34;, got) fmt.Println(ok) got = 0 ok = Cmp(t, got, Not(0), \u0026#34;checks %v is non-null\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// true \t// false   CmpNot shortcut func CmpNot(t TestingT, got interface{}, notExpected interface{}, args ...interface{}) bool CmpNot is a shortcut for:\nCmp(t, got, Not(notExpected), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also  CmpNot godoc.\n Examples   Base example   t := \u0026amp;testing.T{} got := 42 ok := CmpNot(t, got, 0, \u0026#34;checks %v is non-null\u0026#34;, got) fmt.Println(ok) ok = CmpNot(t, got, Between(10, 30), \u0026#34;checks %v is not in [10 .. 30]\u0026#34;, got) fmt.Println(ok) got = 0 ok = CmpNot(t, got, 0, \u0026#34;checks %v is non-null\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// true \t// false   T.Not shortcut func (t *T) Not(got interface{}, notExpected interface{}, args ...interface{}) bool Not is a shortcut for:\nt.Cmp(got, Not(notExpected), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also  T.Not godoc.\n Examples   Base example   t := NewT(\u0026amp;testing.T{}) got := 42 ok := t.Not(got, 0, \u0026#34;checks %v is non-null\u0026#34;, got) fmt.Println(ok) ok = t.Not(got, Between(10, 30), \u0026#34;checks %v is not in [10 .. 30]\u0026#34;, got) fmt.Println(ok) got = 0 ok = t.Not(got, 0, \u0026#34;checks %v is non-null\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// true \t// false   "
},
{
	"uri": "https://go-testdeep.zetta.rocks/operators/notany/",
	"title": "NotAny",
	"tags": [],
	"description": "",
	"content": " func NotAny(expectedItems ...interface{}) TestDeep NotAny operator checks that the contents of an array or a slice (or a pointer on array/slice) does not contain any of expectedItems.\nCmp(t, []int{1}, NotAny(1, 2, 3)) // fails Cmp(t, []int{5}, NotAny(1, 2, 3)) // succeeds  See also  NotAny godoc.\n Examples   Base example   t := \u0026amp;testing.T{} got := []int{4, 5, 9, 42} ok := Cmp(t, got, NotAny(3, 6, 8, 41, 43), \u0026#34;checks %v contains no item listed in NotAny()\u0026#34;, got) fmt.Println(ok) ok = Cmp(t, got, NotAny(3, 6, 8, 42, 43), \u0026#34;checks %v contains no item listed in NotAny()\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// false   CmpNotAny shortcut func CmpNotAny(t TestingT, got interface{}, expectedItems []interface{}, args ...interface{}) bool CmpNotAny is a shortcut for:\nCmp(t, got, NotAny(expectedItems...), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also  CmpNotAny godoc.\n Examples   Base example   t := \u0026amp;testing.T{} got := []int{4, 5, 9, 42} ok := CmpNotAny(t, got, []interface{}{3, 6, 8, 41, 43}, \u0026#34;checks %v contains no item listed in NotAny()\u0026#34;, got) fmt.Println(ok) ok = CmpNotAny(t, got, []interface{}{3, 6, 8, 42, 43}, \u0026#34;checks %v contains no item listed in NotAny()\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// false   T.NotAny shortcut func (t *T) NotAny(got interface{}, expectedItems []interface{}, args ...interface{}) bool NotAny is a shortcut for:\nt.Cmp(got, NotAny(expectedItems...), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also  T.NotAny godoc.\n Examples   Base example   t := NewT(\u0026amp;testing.T{}) got := []int{4, 5, 9, 42} ok := t.NotAny(got, []interface{}{3, 6, 8, 41, 43}, \u0026#34;checks %v contains no item listed in NotAny()\u0026#34;, got) fmt.Println(ok) ok = t.NotAny(got, []interface{}{3, 6, 8, 42, 43}, \u0026#34;checks %v contains no item listed in NotAny()\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// false   "
},
{
	"uri": "https://go-testdeep.zetta.rocks/operators/notempty/",
	"title": "NotEmpty",
	"tags": [],
	"description": "",
	"content": " func NotEmpty() TestDeep NotEmpty operator checks that an array, a channel, a map, a slice or a string is not empty. As a special case (non-typed) nil, as well as nil channel, map or slice are considered empty.\nNote that the compared data can be a pointer (of pointer of pointer etc.) on an array, a channel, a map, a slice or a string.\n See also  NotEmpty godoc.\n Examples    Base example   t := \u0026amp;testing.T{} ok := Cmp(t, nil, NotEmpty()) // fails, as nil is considered empty \tfmt.Println(ok) ok = Cmp(t, \u0026#34;foobar\u0026#34;, NotEmpty()) fmt.Println(ok) // Fails as 0 is a number, so not empty. Use NotZero() instead \tok = Cmp(t, 0, NotEmpty()) fmt.Println(ok) ok = Cmp(t, map[string]int{\u0026#34;foobar\u0026#34;: 42}, NotEmpty()) fmt.Println(ok) ok = Cmp(t, []int{1}, NotEmpty()) fmt.Println(ok) ok = Cmp(t, [3]int{}, NotEmpty()) // succeeds, NotEmpty() is not NotZero()! \tfmt.Println(ok) // Output: \t// false \t// true \t// false \t// true \t// true \t// true     Pointers example   t := \u0026amp;testing.T{} type MySlice []int ok := Cmp(t, MySlice{12}, NotEmpty()) fmt.Println(ok) ok = Cmp(t, \u0026amp;MySlice{12}, NotEmpty()) // Ptr() not needed \tfmt.Println(ok) l1 := \u0026amp;MySlice{12} l2 := \u0026amp;l1 l3 := \u0026amp;l2 ok = Cmp(t, \u0026amp;l3, NotEmpty()) fmt.Println(ok) // Works the same for array, map, channel and string  // But not for others types as: \ttype MyStruct struct { Value int } ok = Cmp(t, \u0026amp;MyStruct{}, NotEmpty()) // fails, use NotZero() instead \tfmt.Println(ok) // Output: \t// true \t// true \t// true \t// false  \nCmpNotEmpty shortcut func CmpNotEmpty(t TestingT, got interface{}, args ...interface{}) bool CmpNotEmpty is a shortcut for:\nCmp(t, got, NotEmpty(), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also  CmpNotEmpty godoc.\n Examples    Base example   t := \u0026amp;testing.T{} ok := CmpNotEmpty(t, nil) // fails, as nil is considered empty \tfmt.Println(ok) ok = CmpNotEmpty(t, \u0026#34;foobar\u0026#34;) fmt.Println(ok) // Fails as 0 is a number, so not empty. Use NotZero() instead \tok = CmpNotEmpty(t, 0) fmt.Println(ok) ok = CmpNotEmpty(t, map[string]int{\u0026#34;foobar\u0026#34;: 42}) fmt.Println(ok) ok = CmpNotEmpty(t, []int{1}) fmt.Println(ok) ok = CmpNotEmpty(t, [3]int{}) // succeeds, NotEmpty() is not NotZero()! \tfmt.Println(ok) // Output: \t// false \t// true \t// false \t// true \t// true \t// true     Pointers example   t := \u0026amp;testing.T{} type MySlice []int ok := CmpNotEmpty(t, MySlice{12}) fmt.Println(ok) ok = CmpNotEmpty(t, \u0026amp;MySlice{12}) // Ptr() not needed \tfmt.Println(ok) l1 := \u0026amp;MySlice{12} l2 := \u0026amp;l1 l3 := \u0026amp;l2 ok = CmpNotEmpty(t, \u0026amp;l3) fmt.Println(ok) // Works the same for array, map, channel and string  // But not for others types as: \ttype MyStruct struct { Value int } ok = CmpNotEmpty(t, \u0026amp;MyStruct{}) // fails, use NotZero() instead \tfmt.Println(ok) // Output: \t// true \t// true \t// true \t// false  \nT.NotEmpty shortcut func (t *T) NotEmpty(got interface{}, args ...interface{}) bool NotEmpty is a shortcut for:\nt.Cmp(got, NotEmpty(), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also  T.NotEmpty godoc.\n Examples    Base example   t := NewT(\u0026amp;testing.T{}) ok := t.NotEmpty(nil) // fails, as nil is considered empty \tfmt.Println(ok) ok = t.NotEmpty(\u0026#34;foobar\u0026#34;) fmt.Println(ok) // Fails as 0 is a number, so not empty. Use NotZero() instead \tok = t.NotEmpty(0) fmt.Println(ok) ok = t.NotEmpty(map[string]int{\u0026#34;foobar\u0026#34;: 42}) fmt.Println(ok) ok = t.NotEmpty([]int{1}) fmt.Println(ok) ok = t.NotEmpty([3]int{}) // succeeds, NotEmpty() is not NotZero()! \tfmt.Println(ok) // Output: \t// false \t// true \t// false \t// true \t// true \t// true     Pointers example   t := NewT(\u0026amp;testing.T{}) type MySlice []int ok := t.NotEmpty(MySlice{12}) fmt.Println(ok) ok = t.NotEmpty(\u0026amp;MySlice{12}) // Ptr() not needed \tfmt.Println(ok) l1 := \u0026amp;MySlice{12} l2 := \u0026amp;l1 l3 := \u0026amp;l2 ok = t.NotEmpty(\u0026amp;l3) fmt.Println(ok) // Works the same for array, map, channel and string  // But not for others types as: \ttype MyStruct struct { Value int } ok = t.NotEmpty(\u0026amp;MyStruct{}) // fails, use NotZero() instead \tfmt.Println(ok) // Output: \t// true \t// true \t// true \t// false  \n"
},
{
	"uri": "https://go-testdeep.zetta.rocks/operators/notnan/",
	"title": "NotNaN",
	"tags": [],
	"description": "",
	"content": " func NotNaN() TestDeep NotNaN operator checks that data is a float and is not not-a-number.\n See also  NotNaN godoc.\n Examples    Float32 example   t := \u0026amp;testing.T{} got := float32(math.NaN()) ok := Cmp(t, got, NotNaN(), \u0026#34;checks %v is not-a-number\u0026#34;, got) fmt.Println(\u0026#34;float32(math.NaN()) is NOT float32 not-a-number:\u0026#34;, ok) got = 12 ok = Cmp(t, got, NotNaN(), \u0026#34;checks %v is not-a-number\u0026#34;, got) fmt.Println(\u0026#34;float32(12) is NOT float32 not-a-number:\u0026#34;, ok) // Output: \t// float32(math.NaN()) is NOT float32 not-a-number: false \t// float32(12) is NOT float32 not-a-number: true     Float64 example   t := \u0026amp;testing.T{} got := math.NaN() ok := Cmp(t, got, NotNaN(), \u0026#34;checks %v is not-a-number\u0026#34;, got) fmt.Println(\u0026#34;math.NaN() is not-a-number:\u0026#34;, ok) got = 12 ok = Cmp(t, got, NotNaN(), \u0026#34;checks %v is not-a-number\u0026#34;, got) fmt.Println(\u0026#34;float64(12) is not-a-number:\u0026#34;, ok) // math.NaN() is NOT not-a-number: false \t// float64(12) is NOT not-a-number: true  \nCmpNotNaN shortcut func CmpNotNaN(t TestingT, got interface{}, args ...interface{}) bool CmpNotNaN is a shortcut for:\nCmp(t, got, NotNaN(), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also  CmpNotNaN godoc.\n Examples    Float32 example   t := \u0026amp;testing.T{} got := float32(math.NaN()) ok := CmpNotNaN(t, got, \u0026#34;checks %v is not-a-number\u0026#34;, got) fmt.Println(\u0026#34;float32(math.NaN()) is NOT float32 not-a-number:\u0026#34;, ok) got = 12 ok = CmpNotNaN(t, got, \u0026#34;checks %v is not-a-number\u0026#34;, got) fmt.Println(\u0026#34;float32(12) is NOT float32 not-a-number:\u0026#34;, ok) // Output: \t// float32(math.NaN()) is NOT float32 not-a-number: false \t// float32(12) is NOT float32 not-a-number: true     Float64 example   t := \u0026amp;testing.T{} got := math.NaN() ok := CmpNotNaN(t, got, \u0026#34;checks %v is not-a-number\u0026#34;, got) fmt.Println(\u0026#34;math.NaN() is not-a-number:\u0026#34;, ok) got = 12 ok = CmpNotNaN(t, got, \u0026#34;checks %v is not-a-number\u0026#34;, got) fmt.Println(\u0026#34;float64(12) is not-a-number:\u0026#34;, ok) // math.NaN() is NOT not-a-number: false \t// float64(12) is NOT not-a-number: true  \nT.NotNaN shortcut func (t *T) NotNaN(got interface{}, args ...interface{}) bool NotNaN is a shortcut for:\nt.Cmp(got, NotNaN(), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also  T.NotNaN godoc.\n Examples    Float32 example   t := NewT(\u0026amp;testing.T{}) got := float32(math.NaN()) ok := t.NotNaN(got, \u0026#34;checks %v is not-a-number\u0026#34;, got) fmt.Println(\u0026#34;float32(math.NaN()) is NOT float32 not-a-number:\u0026#34;, ok) got = 12 ok = t.NotNaN(got, \u0026#34;checks %v is not-a-number\u0026#34;, got) fmt.Println(\u0026#34;float32(12) is NOT float32 not-a-number:\u0026#34;, ok) // Output: \t// float32(math.NaN()) is NOT float32 not-a-number: false \t// float32(12) is NOT float32 not-a-number: true     Float64 example   t := NewT(\u0026amp;testing.T{}) got := math.NaN() ok := t.NotNaN(got, \u0026#34;checks %v is not-a-number\u0026#34;, got) fmt.Println(\u0026#34;math.NaN() is not-a-number:\u0026#34;, ok) got = 12 ok = t.NotNaN(got, \u0026#34;checks %v is not-a-number\u0026#34;, got) fmt.Println(\u0026#34;float64(12) is not-a-number:\u0026#34;, ok) // math.NaN() is NOT not-a-number: false \t// float64(12) is NOT not-a-number: true  \n"
},
{
	"uri": "https://go-testdeep.zetta.rocks/operators/notnil/",
	"title": "NotNil",
	"tags": [],
	"description": "",
	"content": " func NotNil() TestDeep NotNil operator checks that data is not nil (or is a non-nil interface, containing a non-nil pointer.)\n See also  NotNil godoc.\n Examples   Base example   t := \u0026amp;testing.T{} var got fmt.Stringer = \u0026amp;bytes.Buffer{} // nil value can be compared directly with Not(nil), no need of NotNil() here \tok := Cmp(t, got, Not(nil)) fmt.Println(ok) // But it works with NotNil() anyway \tok = Cmp(t, got, NotNil()) fmt.Println(ok) got = (*bytes.Buffer)(nil) // In the case of an interface containing a nil pointer, comparing \t// with Not(nil) succeeds, as the interface is not nil \tok = Cmp(t, got, Not(nil)) fmt.Println(ok) // In this case NotNil() fails \tok = Cmp(t, got, NotNil()) fmt.Println(ok) // Output: \t// true \t// true \t// true \t// false   CmpNotNil shortcut func CmpNotNil(t TestingT, got interface{}, args ...interface{}) bool CmpNotNil is a shortcut for:\nCmp(t, got, NotNil(), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also  CmpNotNil godoc.\n Examples   Base example   t := \u0026amp;testing.T{} var got fmt.Stringer = \u0026amp;bytes.Buffer{} // nil value can be compared directly with Not(nil), no need of NotNil() here \tok := Cmp(t, got, Not(nil)) fmt.Println(ok) // But it works with NotNil() anyway \tok = CmpNotNil(t, got) fmt.Println(ok) got = (*bytes.Buffer)(nil) // In the case of an interface containing a nil pointer, comparing \t// with Not(nil) succeeds, as the interface is not nil \tok = Cmp(t, got, Not(nil)) fmt.Println(ok) // In this case NotNil() fails \tok = CmpNotNil(t, got) fmt.Println(ok) // Output: \t// true \t// true \t// true \t// false   T.NotNil shortcut func (t *T) NotNil(got interface{}, args ...interface{}) bool NotNil is a shortcut for:\nt.Cmp(got, NotNil(), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also  T.NotNil godoc.\n Examples   Base example   t := NewT(\u0026amp;testing.T{}) var got fmt.Stringer = \u0026amp;bytes.Buffer{} // nil value can be compared directly with Not(nil), no need of NotNil() here \tok := t.Cmp(got, Not(nil)) fmt.Println(ok) // But it works with NotNil() anyway \tok = t.NotNil(got) fmt.Println(ok) got = (*bytes.Buffer)(nil) // In the case of an interface containing a nil pointer, comparing \t// with Not(nil) succeeds, as the interface is not nil \tok = t.Cmp(got, Not(nil)) fmt.Println(ok) // In this case NotNil() fails \tok = t.NotNil(got) fmt.Println(ok) // Output: \t// true \t// true \t// true \t// false   "
},
{
	"uri": "https://go-testdeep.zetta.rocks/operators/notzero/",
	"title": "NotZero",
	"tags": [],
	"description": "",
	"content": " func NotZero() TestDeep NotZero operator checks that data is not zero regarding its type.\n nil is the zero value of pointers, maps, slices, channels and functions; 0 is the zero value of numbers; \u0026rdquo;\u0026rdquo; is the 0 value of strings; false is the zero value of booleans; zero value of structs is the struct with no fields initialized.  Beware that:\nCmp(t, AnyStruct{}, NotZero()) // is false Cmp(t, \u0026amp;AnyStruct{}, NotZero()) // is true, coz pointer ≠ nil Cmp(t, \u0026amp;AnyStruct{}, Ptr(NotZero())) // is false  See also  NotZero godoc.\n Examples   Base example   t := \u0026amp;testing.T{} ok := Cmp(t, 0, NotZero()) // fails \tfmt.Println(ok) ok = Cmp(t, float64(0), NotZero()) // fails \tfmt.Println(ok) ok = Cmp(t, 12, NotZero()) fmt.Println(ok) ok = Cmp(t, (map[string]int)(nil), NotZero()) // fails, as nil \tfmt.Println(ok) ok = Cmp(t, map[string]int{}, NotZero()) // succeeds, as not nil \tfmt.Println(ok) ok = Cmp(t, ([]int)(nil), NotZero()) // fails, as nil \tfmt.Println(ok) ok = Cmp(t, []int{}, NotZero()) // succeeds, as not nil \tfmt.Println(ok) ok = Cmp(t, [3]int{}, NotZero()) // fails \tfmt.Println(ok) ok = Cmp(t, [3]int{0, 1}, NotZero()) // succeeds, DATA[1] is not 0 \tfmt.Println(ok) ok = Cmp(t, bytes.Buffer{}, NotZero()) // fails \tfmt.Println(ok) ok = Cmp(t, \u0026amp;bytes.Buffer{}, NotZero()) // succeeds, as pointer not nil \tfmt.Println(ok) ok = Cmp(t, \u0026amp;bytes.Buffer{}, Ptr(NotZero())) // fails as deref by Ptr() \tfmt.Println(ok) // Output: \t// false \t// false \t// true \t// false \t// true \t// false \t// true \t// false \t// true \t// false \t// true \t// false   CmpNotZero shortcut func CmpNotZero(t TestingT, got interface{}, args ...interface{}) bool CmpNotZero is a shortcut for:\nCmp(t, got, NotZero(), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also  CmpNotZero godoc.\n Examples   Base example   t := \u0026amp;testing.T{} ok := CmpNotZero(t, 0) // fails \tfmt.Println(ok) ok = CmpNotZero(t, float64(0)) // fails \tfmt.Println(ok) ok = CmpNotZero(t, 12) fmt.Println(ok) ok = CmpNotZero(t, (map[string]int)(nil)) // fails, as nil \tfmt.Println(ok) ok = CmpNotZero(t, map[string]int{}) // succeeds, as not nil \tfmt.Println(ok) ok = CmpNotZero(t, ([]int)(nil)) // fails, as nil \tfmt.Println(ok) ok = CmpNotZero(t, []int{}) // succeeds, as not nil \tfmt.Println(ok) ok = CmpNotZero(t, [3]int{}) // fails \tfmt.Println(ok) ok = CmpNotZero(t, [3]int{0, 1}) // succeeds, DATA[1] is not 0 \tfmt.Println(ok) ok = CmpNotZero(t, bytes.Buffer{}) // fails \tfmt.Println(ok) ok = CmpNotZero(t, \u0026amp;bytes.Buffer{}) // succeeds, as pointer not nil \tfmt.Println(ok) ok = Cmp(t, \u0026amp;bytes.Buffer{}, Ptr(NotZero())) // fails as deref by Ptr() \tfmt.Println(ok) // Output: \t// false \t// false \t// true \t// false \t// true \t// false \t// true \t// false \t// true \t// false \t// true \t// false   T.NotZero shortcut func (t *T) NotZero(got interface{}, args ...interface{}) bool NotZero is a shortcut for:\nt.Cmp(got, NotZero(), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also  T.NotZero godoc.\n Examples   Base example   t := NewT(\u0026amp;testing.T{}) ok := t.NotZero(0) // fails \tfmt.Println(ok) ok = t.NotZero(float64(0)) // fails \tfmt.Println(ok) ok = t.NotZero(12) fmt.Println(ok) ok = t.NotZero((map[string]int)(nil)) // fails, as nil \tfmt.Println(ok) ok = t.NotZero(map[string]int{}) // succeeds, as not nil \tfmt.Println(ok) ok = t.NotZero(([]int)(nil)) // fails, as nil \tfmt.Println(ok) ok = t.NotZero([]int{}) // succeeds, as not nil \tfmt.Println(ok) ok = t.NotZero([3]int{}) // fails \tfmt.Println(ok) ok = t.NotZero([3]int{0, 1}) // succeeds, DATA[1] is not 0 \tfmt.Println(ok) ok = t.NotZero(bytes.Buffer{}) // fails \tfmt.Println(ok) ok = t.NotZero(\u0026amp;bytes.Buffer{}) // succeeds, as pointer not nil \tfmt.Println(ok) ok = t.Cmp(\u0026amp;bytes.Buffer{}, Ptr(NotZero())) // fails as deref by Ptr() \tfmt.Println(ok) // Output: \t// false \t// false \t// true \t// false \t// true \t// false \t// true \t// false \t// true \t// false \t// true \t// false   "
},
{
	"uri": "https://go-testdeep.zetta.rocks/operators/pptr/",
	"title": "PPtr",
	"tags": [],
	"description": "",
	"content": " func PPtr(val interface{}) TestDeep PPtr is a smuggler operator. It takes the address of the address of data and compares it to val.\nval depends on data type. For example, if the compared data is an **int, one can have:\nPPtr(12) as well as an other operator:\nPPtr(Between(3, 4)) It is more efficient and shorter to write than:\nPtr(Ptr(val)) TypeBehind method returns the reflect.Type of a pointer on a pointer on val, except if val is a TestDeep operator. In this case, it delegates TypeBehind() to the operator and returns the reflect.Type of a pointer on a pointer on the returned value (if non-nil of course).\n See also  PPtr godoc.\n Examples   Base example   t := \u0026amp;testing.T{} num := 12 got := \u0026amp;num ok := Cmp(t, \u0026amp;got, PPtr(12)) fmt.Println(ok) ok = Cmp(t, \u0026amp;got, PPtr(Between(4, 15))) fmt.Println(ok) // Output: \t// true \t// true   CmpPPtr shortcut func CmpPPtr(t TestingT, got interface{}, val interface{}, args ...interface{}) bool CmpPPtr is a shortcut for:\nCmp(t, got, PPtr(val), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also  CmpPPtr godoc.\n Examples   Base example   t := \u0026amp;testing.T{} num := 12 got := \u0026amp;num ok := CmpPPtr(t, \u0026amp;got, 12) fmt.Println(ok) ok = CmpPPtr(t, \u0026amp;got, Between(4, 15)) fmt.Println(ok) // Output: \t// true \t// true   T.PPtr shortcut func (t *T) PPtr(got interface{}, val interface{}, args ...interface{}) bool PPtr is a shortcut for:\nt.Cmp(got, PPtr(val), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also  T.PPtr godoc.\n Examples   Base example   t := NewT(\u0026amp;testing.T{}) num := 12 got := \u0026amp;num ok := t.PPtr(\u0026amp;got, 12) fmt.Println(ok) ok = t.PPtr(\u0026amp;got, Between(4, 15)) fmt.Println(ok) // Output: \t// true \t// true   "
},
{
	"uri": "https://go-testdeep.zetta.rocks/operators/ptr/",
	"title": "Ptr",
	"tags": [],
	"description": "",
	"content": " func Ptr(val interface{}) TestDeep Ptr is a smuggler operator. It takes the address of data and compares it to val.\nval depends on data type. For example, if the compared data is an *int, one can have:\nPtr(12) as well as an other operator:\nPtr(Between(3, 4)) TypeBehind method returns the reflect.Type of a pointer on val, except if val is a TestDeep operator. In this case, it delegates TypeBehind() to the operator and returns the reflect.Type of a pointer on the returned value (if non-nil of course).\n See also  Ptr godoc.\n Examples   Base example   t := \u0026amp;testing.T{} got := 12 ok := Cmp(t, \u0026amp;got, Ptr(12)) fmt.Println(ok) ok = Cmp(t, \u0026amp;got, Ptr(Between(4, 15))) fmt.Println(ok) // Output: \t// true \t// true   CmpPtr shortcut func CmpPtr(t TestingT, got interface{}, val interface{}, args ...interface{}) bool CmpPtr is a shortcut for:\nCmp(t, got, Ptr(val), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also  CmpPtr godoc.\n Examples   Base example   t := \u0026amp;testing.T{} got := 12 ok := CmpPtr(t, \u0026amp;got, 12) fmt.Println(ok) ok = CmpPtr(t, \u0026amp;got, Between(4, 15)) fmt.Println(ok) // Output: \t// true \t// true   T.Ptr shortcut func (t *T) Ptr(got interface{}, val interface{}, args ...interface{}) bool Ptr is a shortcut for:\nt.Cmp(got, Ptr(val), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also  T.Ptr godoc.\n Examples   Base example   t := NewT(\u0026amp;testing.T{}) got := 12 ok := t.Ptr(\u0026amp;got, 12) fmt.Println(ok) ok = t.Ptr(\u0026amp;got, Between(4, 15)) fmt.Println(ok) // Output: \t// true \t// true   "
},
{
	"uri": "https://go-testdeep.zetta.rocks/operators/re/",
	"title": "Re",
	"tags": [],
	"description": "",
	"content": " func Re(reg interface{}, capture ...interface{}) TestDeep Re operator allows to apply a regexp on a string (or convertible), []byte, error or fmt.Stringer interface (error interface is tested before fmt.Stringer.)\nreg is the regexp. It can be a string that is automatically compiled using regexp.MustCompile, or a *regexp.Regexp.\nOptional capture parameter can be used to match the contents of regexp groups. Groups are presented as a []string or [][]byte depending the original matched data. Note that an other operator can be used here.\nCmp(t, \u0026#34;foobar zip!\u0026#34;, Re(`^foobar`)) // succeeds Cmp(t, \u0026#34;John Doe\u0026#34;, Re(`^(\\w+) (\\w+)`, []string{\u0026#34;John\u0026#34;, \u0026#34;Doe\u0026#34;})) // succeeds Cmp(t, \u0026#34;John Doe\u0026#34;, Re(`^(\\w+) (\\w+)`, Bag(\u0026#34;Doe\u0026#34;, \u0026#34;John\u0026#34;)) // succeeds  See also  Re godoc.\n Examples    Base example   t := \u0026amp;testing.T{} got := \u0026#34;foo bar\u0026#34; ok := Cmp(t, got, Re(\u0026#34;(zip|bar)$\u0026#34;), \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) got = \u0026#34;bar foo\u0026#34; ok = Cmp(t, got, Re(\u0026#34;(zip|bar)$\u0026#34;), \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// false     Stringer example   t := \u0026amp;testing.T{} // bytes.Buffer implements fmt.Stringer \tgot := bytes.NewBufferString(\u0026#34;foo bar\u0026#34;) ok := Cmp(t, got, Re(\u0026#34;(zip|bar)$\u0026#34;), \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) // Output: \t// true     Error example   t := \u0026amp;testing.T{} got := errors.New(\u0026#34;foo bar\u0026#34;) ok := Cmp(t, got, Re(\u0026#34;(zip|bar)$\u0026#34;), \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) // Output: \t// true     Capture example   t := \u0026amp;testing.T{} got := \u0026#34;foo bar biz\u0026#34; ok := Cmp(t, got, Re(`^(\\w+) (\\w+) (\\w+)$`, Set(\u0026#34;biz\u0026#34;, \u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;)), \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) got = \u0026#34;foo bar! biz\u0026#34; ok = Cmp(t, got, Re(`^(\\w+) (\\w+) (\\w+)$`, Set(\u0026#34;biz\u0026#34;, \u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;)), \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// false     Compiled example   t := \u0026amp;testing.T{} expected := regexp.MustCompile(\u0026#34;(zip|bar)$\u0026#34;) got := \u0026#34;foo bar\u0026#34; ok := Cmp(t, got, Re(expected), \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) got = \u0026#34;bar foo\u0026#34; ok = Cmp(t, got, Re(expected), \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// false     CompiledStringer example   t := \u0026amp;testing.T{} expected := regexp.MustCompile(\u0026#34;(zip|bar)$\u0026#34;) // bytes.Buffer implements fmt.Stringer \tgot := bytes.NewBufferString(\u0026#34;foo bar\u0026#34;) ok := Cmp(t, got, Re(expected), \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) // Output: \t// true     CompiledError example   t := \u0026amp;testing.T{} expected := regexp.MustCompile(\u0026#34;(zip|bar)$\u0026#34;) got := errors.New(\u0026#34;foo bar\u0026#34;) ok := Cmp(t, got, Re(expected), \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) // Output: \t// true     CompiledCapture example   t := \u0026amp;testing.T{} expected := regexp.MustCompile(`^(\\w+) (\\w+) (\\w+)$`) got := \u0026#34;foo bar biz\u0026#34; ok := Cmp(t, got, Re(expected, Set(\u0026#34;biz\u0026#34;, \u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;)), \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) got = \u0026#34;foo bar! biz\u0026#34; ok = Cmp(t, got, Re(expected, Set(\u0026#34;biz\u0026#34;, \u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;)), \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// false  \nCmpRe shortcut func CmpRe(t TestingT, got interface{}, reg interface{}, capture interface{}, args ...interface{}) bool CmpRe is a shortcut for:\nCmp(t, got, Re(reg, capture), args...) See above for details.\nRe() optional parameter capture is here mandatory. nil value should be passed to mimic its absence in original Re() call.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also  CmpRe godoc.\n Examples    Base example   t := \u0026amp;testing.T{} got := \u0026#34;foo bar\u0026#34; ok := CmpRe(t, got, \u0026#34;(zip|bar)$\u0026#34;, nil, \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) got = \u0026#34;bar foo\u0026#34; ok = CmpRe(t, got, \u0026#34;(zip|bar)$\u0026#34;, nil, \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// false     Stringer example   t := \u0026amp;testing.T{} // bytes.Buffer implements fmt.Stringer \tgot := bytes.NewBufferString(\u0026#34;foo bar\u0026#34;) ok := CmpRe(t, got, \u0026#34;(zip|bar)$\u0026#34;, nil, \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) // Output: \t// true     Error example   t := \u0026amp;testing.T{} got := errors.New(\u0026#34;foo bar\u0026#34;) ok := CmpRe(t, got, \u0026#34;(zip|bar)$\u0026#34;, nil, \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) // Output: \t// true     Capture example   t := \u0026amp;testing.T{} got := \u0026#34;foo bar biz\u0026#34; ok := CmpRe(t, got, `^(\\w+) (\\w+) (\\w+)$`, Set(\u0026#34;biz\u0026#34;, \u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;), \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) got = \u0026#34;foo bar! biz\u0026#34; ok = CmpRe(t, got, `^(\\w+) (\\w+) (\\w+)$`, Set(\u0026#34;biz\u0026#34;, \u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;), \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// false     Compiled example   t := \u0026amp;testing.T{} expected := regexp.MustCompile(\u0026#34;(zip|bar)$\u0026#34;) got := \u0026#34;foo bar\u0026#34; ok := CmpRe(t, got, expected, nil, \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) got = \u0026#34;bar foo\u0026#34; ok = CmpRe(t, got, expected, nil, \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// false     CompiledStringer example   t := \u0026amp;testing.T{} expected := regexp.MustCompile(\u0026#34;(zip|bar)$\u0026#34;) // bytes.Buffer implements fmt.Stringer \tgot := bytes.NewBufferString(\u0026#34;foo bar\u0026#34;) ok := CmpRe(t, got, expected, nil, \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) // Output: \t// true     CompiledError example   t := \u0026amp;testing.T{} expected := regexp.MustCompile(\u0026#34;(zip|bar)$\u0026#34;) got := errors.New(\u0026#34;foo bar\u0026#34;) ok := CmpRe(t, got, expected, nil, \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) // Output: \t// true     CompiledCapture example   t := \u0026amp;testing.T{} expected := regexp.MustCompile(`^(\\w+) (\\w+) (\\w+)$`) got := \u0026#34;foo bar biz\u0026#34; ok := CmpRe(t, got, expected, Set(\u0026#34;biz\u0026#34;, \u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;), \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) got = \u0026#34;foo bar! biz\u0026#34; ok = CmpRe(t, got, expected, Set(\u0026#34;biz\u0026#34;, \u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;), \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// false  \nT.Re shortcut func (t *T) Re(got interface{}, reg interface{}, capture interface{}, args ...interface{}) bool Re is a shortcut for:\nt.Cmp(got, Re(reg, capture), args...) See above for details.\nRe() optional parameter capture is here mandatory. nil value should be passed to mimic its absence in original Re() call.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also  T.Re godoc.\n Examples    Base example   t := NewT(\u0026amp;testing.T{}) got := \u0026#34;foo bar\u0026#34; ok := t.Re(got, \u0026#34;(zip|bar)$\u0026#34;, nil, \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) got = \u0026#34;bar foo\u0026#34; ok = t.Re(got, \u0026#34;(zip|bar)$\u0026#34;, nil, \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// false     Stringer example   t := NewT(\u0026amp;testing.T{}) // bytes.Buffer implements fmt.Stringer \tgot := bytes.NewBufferString(\u0026#34;foo bar\u0026#34;) ok := t.Re(got, \u0026#34;(zip|bar)$\u0026#34;, nil, \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) // Output: \t// true     Error example   t := NewT(\u0026amp;testing.T{}) got := errors.New(\u0026#34;foo bar\u0026#34;) ok := t.Re(got, \u0026#34;(zip|bar)$\u0026#34;, nil, \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) // Output: \t// true     Capture example   t := NewT(\u0026amp;testing.T{}) got := \u0026#34;foo bar biz\u0026#34; ok := t.Re(got, `^(\\w+) (\\w+) (\\w+)$`, Set(\u0026#34;biz\u0026#34;, \u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;), \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) got = \u0026#34;foo bar! biz\u0026#34; ok = t.Re(got, `^(\\w+) (\\w+) (\\w+)$`, Set(\u0026#34;biz\u0026#34;, \u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;), \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// false     Compiled example   t := NewT(\u0026amp;testing.T{}) expected := regexp.MustCompile(\u0026#34;(zip|bar)$\u0026#34;) got := \u0026#34;foo bar\u0026#34; ok := t.Re(got, expected, nil, \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) got = \u0026#34;bar foo\u0026#34; ok = t.Re(got, expected, nil, \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// false     CompiledStringer example   t := NewT(\u0026amp;testing.T{}) expected := regexp.MustCompile(\u0026#34;(zip|bar)$\u0026#34;) // bytes.Buffer implements fmt.Stringer \tgot := bytes.NewBufferString(\u0026#34;foo bar\u0026#34;) ok := t.Re(got, expected, nil, \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) // Output: \t// true     CompiledError example   t := NewT(\u0026amp;testing.T{}) expected := regexp.MustCompile(\u0026#34;(zip|bar)$\u0026#34;) got := errors.New(\u0026#34;foo bar\u0026#34;) ok := t.Re(got, expected, nil, \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) // Output: \t// true     CompiledCapture example   t := NewT(\u0026amp;testing.T{}) expected := regexp.MustCompile(`^(\\w+) (\\w+) (\\w+)$`) got := \u0026#34;foo bar biz\u0026#34; ok := t.Re(got, expected, Set(\u0026#34;biz\u0026#34;, \u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;), \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) got = \u0026#34;foo bar! biz\u0026#34; ok = t.Re(got, expected, Set(\u0026#34;biz\u0026#34;, \u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;), \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// false  \n"
},
{
	"uri": "https://go-testdeep.zetta.rocks/operators/reall/",
	"title": "ReAll",
	"tags": [],
	"description": "",
	"content": " func ReAll(reg interface{}, capture interface{}) TestDeep ReAll operator allows to successively apply a regexp on a string (or convertible), []byte, error or fmt.Stringer interface (error interface is tested before fmt.Stringer) and to match its groups contents.\nreg is the regexp. It can be a string that is automatically compiled using regexp.MustCompile, or a *regexp.Regexp.\ncapture is used to match the contents of regexp groups. Groups are presented as a []string or [][]byte depending the original matched data. Note that an other operator can be used here.\nCmp(t, \u0026#34;John Doe\u0026#34;, ReAll(`(\\w+)(?: |\\z)`, []string{\u0026#34;John\u0026#34;, \u0026#34;Doe\u0026#34;})) // succeeds Cmp(t, \u0026#34;John Doe\u0026#34;, ReAll(`(\\w+)(?: |\\z)`, Bag(\u0026#34;Doe\u0026#34;, \u0026#34;John\u0026#34;)) // succeeds  See also  ReAll godoc.\n Examples    Capture example   t := \u0026amp;testing.T{} got := \u0026#34;foo bar biz\u0026#34; ok := Cmp(t, got, ReAll(`(\\w+)`, Set(\u0026#34;biz\u0026#34;, \u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;)), \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) // Matches, but all catured groups do not match Set \tgot = \u0026#34;foo BAR biz\u0026#34; ok = Cmp(t, got, ReAll(`(\\w+)`, Set(\u0026#34;biz\u0026#34;, \u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;)), \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// false     CaptureComplex example   t := \u0026amp;testing.T{} got := \u0026#34;11 45 23 56 85 96\u0026#34; ok := Cmp(t, got, ReAll(`(\\d+)`, ArrayEach(Code(func(num string) bool { n, err := strconv.Atoi(num) return err == nil \u0026amp;\u0026amp; n \u0026gt; 10 \u0026amp;\u0026amp; n \u0026lt; 100 }))), \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) // Matches, but 11 is not greater than 20 \tok = Cmp(t, got, ReAll(`(\\d+)`, ArrayEach(Code(func(num string) bool { n, err := strconv.Atoi(num) return err == nil \u0026amp;\u0026amp; n \u0026gt; 20 \u0026amp;\u0026amp; n \u0026lt; 100 }))), \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// false     CompiledCapture example   t := \u0026amp;testing.T{} expected := regexp.MustCompile(`(\\w+)`) got := \u0026#34;foo bar biz\u0026#34; ok := Cmp(t, got, ReAll(expected, Set(\u0026#34;biz\u0026#34;, \u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;)), \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) // Matches, but all catured groups do not match Set \tgot = \u0026#34;foo BAR biz\u0026#34; ok = Cmp(t, got, ReAll(expected, Set(\u0026#34;biz\u0026#34;, \u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;)), \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// false     CompiledCaptureComplex example   t := \u0026amp;testing.T{} expected := regexp.MustCompile(`(\\d+)`) got := \u0026#34;11 45 23 56 85 96\u0026#34; ok := Cmp(t, got, ReAll(expected, ArrayEach(Code(func(num string) bool { n, err := strconv.Atoi(num) return err == nil \u0026amp;\u0026amp; n \u0026gt; 10 \u0026amp;\u0026amp; n \u0026lt; 100 }))), \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) // Matches, but 11 is not greater than 20 \tok = Cmp(t, got, ReAll(expected, ArrayEach(Code(func(num string) bool { n, err := strconv.Atoi(num) return err == nil \u0026amp;\u0026amp; n \u0026gt; 20 \u0026amp;\u0026amp; n \u0026lt; 100 }))), \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// false  \nCmpReAll shortcut func CmpReAll(t TestingT, got interface{}, reg interface{}, capture interface{}, args ...interface{}) bool CmpReAll is a shortcut for:\nCmp(t, got, ReAll(reg, capture), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also  CmpReAll godoc.\n Examples    Capture example   t := \u0026amp;testing.T{} got := \u0026#34;foo bar biz\u0026#34; ok := CmpReAll(t, got, `(\\w+)`, Set(\u0026#34;biz\u0026#34;, \u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;), \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) // Matches, but all catured groups do not match Set \tgot = \u0026#34;foo BAR biz\u0026#34; ok = CmpReAll(t, got, `(\\w+)`, Set(\u0026#34;biz\u0026#34;, \u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;), \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// false     CaptureComplex example   t := \u0026amp;testing.T{} got := \u0026#34;11 45 23 56 85 96\u0026#34; ok := CmpReAll(t, got, `(\\d+)`, ArrayEach(Code(func(num string) bool { n, err := strconv.Atoi(num) return err == nil \u0026amp;\u0026amp; n \u0026gt; 10 \u0026amp;\u0026amp; n \u0026lt; 100 })), \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) // Matches, but 11 is not greater than 20 \tok = CmpReAll(t, got, `(\\d+)`, ArrayEach(Code(func(num string) bool { n, err := strconv.Atoi(num) return err == nil \u0026amp;\u0026amp; n \u0026gt; 20 \u0026amp;\u0026amp; n \u0026lt; 100 })), \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// false     CompiledCapture example   t := \u0026amp;testing.T{} expected := regexp.MustCompile(`(\\w+)`) got := \u0026#34;foo bar biz\u0026#34; ok := CmpReAll(t, got, expected, Set(\u0026#34;biz\u0026#34;, \u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;), \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) // Matches, but all catured groups do not match Set \tgot = \u0026#34;foo BAR biz\u0026#34; ok = CmpReAll(t, got, expected, Set(\u0026#34;biz\u0026#34;, \u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;), \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// false     CompiledCaptureComplex example   t := \u0026amp;testing.T{} expected := regexp.MustCompile(`(\\d+)`) got := \u0026#34;11 45 23 56 85 96\u0026#34; ok := CmpReAll(t, got, expected, ArrayEach(Code(func(num string) bool { n, err := strconv.Atoi(num) return err == nil \u0026amp;\u0026amp; n \u0026gt; 10 \u0026amp;\u0026amp; n \u0026lt; 100 })), \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) // Matches, but 11 is not greater than 20 \tok = CmpReAll(t, got, expected, ArrayEach(Code(func(num string) bool { n, err := strconv.Atoi(num) return err == nil \u0026amp;\u0026amp; n \u0026gt; 20 \u0026amp;\u0026amp; n \u0026lt; 100 })), \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// false  \nT.ReAll shortcut func (t *T) ReAll(got interface{}, reg interface{}, capture interface{}, args ...interface{}) bool ReAll is a shortcut for:\nt.Cmp(got, ReAll(reg, capture), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also  T.ReAll godoc.\n Examples    Capture example   t := NewT(\u0026amp;testing.T{}) got := \u0026#34;foo bar biz\u0026#34; ok := t.ReAll(got, `(\\w+)`, Set(\u0026#34;biz\u0026#34;, \u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;), \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) // Matches, but all catured groups do not match Set \tgot = \u0026#34;foo BAR biz\u0026#34; ok = t.ReAll(got, `(\\w+)`, Set(\u0026#34;biz\u0026#34;, \u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;), \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// false     CaptureComplex example   t := NewT(\u0026amp;testing.T{}) got := \u0026#34;11 45 23 56 85 96\u0026#34; ok := t.ReAll(got, `(\\d+)`, ArrayEach(Code(func(num string) bool { n, err := strconv.Atoi(num) return err == nil \u0026amp;\u0026amp; n \u0026gt; 10 \u0026amp;\u0026amp; n \u0026lt; 100 })), \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) // Matches, but 11 is not greater than 20 \tok = t.ReAll(got, `(\\d+)`, ArrayEach(Code(func(num string) bool { n, err := strconv.Atoi(num) return err == nil \u0026amp;\u0026amp; n \u0026gt; 20 \u0026amp;\u0026amp; n \u0026lt; 100 })), \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// false     CompiledCapture example   t := NewT(\u0026amp;testing.T{}) expected := regexp.MustCompile(`(\\w+)`) got := \u0026#34;foo bar biz\u0026#34; ok := t.ReAll(got, expected, Set(\u0026#34;biz\u0026#34;, \u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;), \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) // Matches, but all catured groups do not match Set \tgot = \u0026#34;foo BAR biz\u0026#34; ok = t.ReAll(got, expected, Set(\u0026#34;biz\u0026#34;, \u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;), \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// false     CompiledCaptureComplex example   t := NewT(\u0026amp;testing.T{}) expected := regexp.MustCompile(`(\\d+)`) got := \u0026#34;11 45 23 56 85 96\u0026#34; ok := t.ReAll(got, expected, ArrayEach(Code(func(num string) bool { n, err := strconv.Atoi(num) return err == nil \u0026amp;\u0026amp; n \u0026gt; 10 \u0026amp;\u0026amp; n \u0026lt; 100 })), \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) // Matches, but 11 is not greater than 20 \tok = t.ReAll(got, expected, ArrayEach(Code(func(num string) bool { n, err := strconv.Atoi(num) return err == nil \u0026amp;\u0026amp; n \u0026gt; 20 \u0026amp;\u0026amp; n \u0026lt; 100 })), \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// false  \n"
},
{
	"uri": "https://go-testdeep.zetta.rocks/operators/set/",
	"title": "Set",
	"tags": [],
	"description": "",
	"content": " func Set(expectedItems ...interface{}) TestDeep Set operator compares the contents of an array or a slice (or a pointer on array/slice) ignoring duplicates and without taking care of the order of items.\nDuring a match, each expected item should match in the compared array/slice, and each array/slice item should be matched by an expected item to succeed.\nCmp(t, []int{1, 1, 2}, Set(1, 2)) // succeeds Cmp(t, []int{1, 1, 2}, Set(2, 1)) // succeeds Cmp(t, []int{1, 1, 2}, Set(1, 2, 3)) // fails, 3 is missing  See also  Set godoc.\n Examples   Base example   t := \u0026amp;testing.T{} got := []int{1, 3, 5, 8, 8, 1, 2} // Matches as all items are present, ignoring duplicates \tok := Cmp(t, got, Set(1, 2, 3, 5, 8), \u0026#34;checks all items are present, in any order\u0026#34;) fmt.Println(ok) // Duplicates are ignored in a Set \tok = Cmp(t, got, Set(1, 2, 2, 2, 2, 2, 3, 5, 8), \u0026#34;checks all items are present, in any order\u0026#34;) fmt.Println(ok) // Tries its best to not raise an error when a value can be matched \t// by several Set entries \tok = Cmp(t, got, Set(Between(1, 4), 3, Between(2, 10)), \u0026#34;checks all items are present, in any order\u0026#34;) fmt.Println(ok) // Output: \t// true \t// true \t// true   CmpSet shortcut func CmpSet(t TestingT, got interface{}, expectedItems []interface{}, args ...interface{}) bool CmpSet is a shortcut for:\nCmp(t, got, Set(expectedItems...), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also  CmpSet godoc.\n Examples   Base example   t := \u0026amp;testing.T{} got := []int{1, 3, 5, 8, 8, 1, 2} // Matches as all items are present, ignoring duplicates \tok := CmpSet(t, got, []interface{}{1, 2, 3, 5, 8}, \u0026#34;checks all items are present, in any order\u0026#34;) fmt.Println(ok) // Duplicates are ignored in a Set \tok = CmpSet(t, got, []interface{}{1, 2, 2, 2, 2, 2, 3, 5, 8}, \u0026#34;checks all items are present, in any order\u0026#34;) fmt.Println(ok) // Tries its best to not raise an error when a value can be matched \t// by several Set entries \tok = CmpSet(t, got, []interface{}{Between(1, 4), 3, Between(2, 10)}, \u0026#34;checks all items are present, in any order\u0026#34;) fmt.Println(ok) // Output: \t// true \t// true \t// true   T.Set shortcut func (t *T) Set(got interface{}, expectedItems []interface{}, args ...interface{}) bool Set is a shortcut for:\nt.Cmp(got, Set(expectedItems...), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also  T.Set godoc.\n Examples   Base example   t := NewT(\u0026amp;testing.T{}) got := []int{1, 3, 5, 8, 8, 1, 2} // Matches as all items are present, ignoring duplicates \tok := t.Set(got, []interface{}{1, 2, 3, 5, 8}, \u0026#34;checks all items are present, in any order\u0026#34;) fmt.Println(ok) // Duplicates are ignored in a Set \tok = t.Set(got, []interface{}{1, 2, 2, 2, 2, 2, 3, 5, 8}, \u0026#34;checks all items are present, in any order\u0026#34;) fmt.Println(ok) // Tries its best to not raise an error when a value can be matched \t// by several Set entries \tok = t.Set(got, []interface{}{Between(1, 4), 3, Between(2, 10)}, \u0026#34;checks all items are present, in any order\u0026#34;) fmt.Println(ok) // Output: \t// true \t// true \t// true   "
},
{
	"uri": "https://go-testdeep.zetta.rocks/operators/shallow/",
	"title": "Shallow",
	"tags": [],
	"description": "",
	"content": " func Shallow(expectedPtr interface{}) TestDeep Shallow operator compares pointers only, not their contents. It applies on channels, functions (with some restrictions), maps, pointers, slices and strings.\nDuring a match, the compared data must be the same as expectedPtr to succeed.\na, b := 123, 123 Cmp(t, \u0026amp;a, Shallow(\u0026amp;a)) // succeeds Cmp(t, \u0026amp;a, Shallow(\u0026amp;b)) // fails even if a == b as \u0026amp;a != \u0026amp;b  back := \u0026#34;foobarfoobar\u0026#34; a, b := back[:6], back[6:] // a == b but... Cmp(t, \u0026amp;a, Shallow(\u0026amp;b)) // fails Be careful for slices and strings! Shallow can succeed but the slices/strings not be identical because of their different lengths. For example:\na := \u0026#34;foobar yes!\u0026#34; b := a[:1] // aka. \u0026#34;f\u0026#34; Cmp(t, \u0026amp;a, Shallow(\u0026amp;b)) // succeeds as both strings point to the same area, even if len() differ The same behavior occurs for slices:\na := []int{1, 2, 3, 4, 5, 6} b := a[:2] // aka. []int{1, 2} Cmp(t, \u0026amp;a, Shallow(\u0026amp;b)) // succeeds as both slices point to the same area, even if len() differ  See also  Shallow godoc.\n Examples    Base example   t := \u0026amp;testing.T{} type MyStruct struct { Value int } data := MyStruct{Value: 12} got := \u0026amp;data ok := Cmp(t, got, Shallow(\u0026amp;data), \u0026#34;checks pointers only, not contents\u0026#34;) fmt.Println(ok) // Same contents, but not same pointer \tok = Cmp(t, got, Shallow(\u0026amp;MyStruct{Value: 12}), \u0026#34;checks pointers only, not contents\u0026#34;) fmt.Println(ok) // Output: \t// true \t// false     Slice example   t := \u0026amp;testing.T{} back := []int{1, 2, 3, 1, 2, 3} a := back[:3] b := back[3:] ok := Cmp(t, a, Shallow(back)) fmt.Println(\u0026#34;are ≠ but share the same area:\u0026#34;, ok) ok = Cmp(t, b, Shallow(back)) fmt.Println(\u0026#34;are = but do not point to same area:\u0026#34;, ok) // Output: \t// are ≠ but share the same area: true \t// are = but do not point to same area: false     String example   t := \u0026amp;testing.T{} back := \u0026#34;foobarfoobar\u0026#34; a := back[:6] b := back[6:] ok := Cmp(t, a, Shallow(back)) fmt.Println(\u0026#34;are ≠ but share the same area:\u0026#34;, ok) ok = Cmp(t, b, Shallow(a)) fmt.Println(\u0026#34;are = but do not point to same area:\u0026#34;, ok) // Output: \t// are ≠ but share the same area: true \t// are = but do not point to same area: false  \nCmpShallow shortcut func CmpShallow(t TestingT, got interface{}, expectedPtr interface{}, args ...interface{}) bool CmpShallow is a shortcut for:\nCmp(t, got, Shallow(expectedPtr), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also  CmpShallow godoc.\n Examples    Base example   t := \u0026amp;testing.T{} type MyStruct struct { Value int } data := MyStruct{Value: 12} got := \u0026amp;data ok := CmpShallow(t, got, \u0026amp;data, \u0026#34;checks pointers only, not contents\u0026#34;) fmt.Println(ok) // Same contents, but not same pointer \tok = CmpShallow(t, got, \u0026amp;MyStruct{Value: 12}, \u0026#34;checks pointers only, not contents\u0026#34;) fmt.Println(ok) // Output: \t// true \t// false     Slice example   t := \u0026amp;testing.T{} back := []int{1, 2, 3, 1, 2, 3} a := back[:3] b := back[3:] ok := CmpShallow(t, a, back) fmt.Println(\u0026#34;are ≠ but share the same area:\u0026#34;, ok) ok = CmpShallow(t, b, back) fmt.Println(\u0026#34;are = but do not point to same area:\u0026#34;, ok) // Output: \t// are ≠ but share the same area: true \t// are = but do not point to same area: false     String example   t := \u0026amp;testing.T{} back := \u0026#34;foobarfoobar\u0026#34; a := back[:6] b := back[6:] ok := CmpShallow(t, a, back) fmt.Println(\u0026#34;are ≠ but share the same area:\u0026#34;, ok) ok = CmpShallow(t, b, a) fmt.Println(\u0026#34;are = but do not point to same area:\u0026#34;, ok) // Output: \t// are ≠ but share the same area: true \t// are = but do not point to same area: false  \nT.Shallow shortcut func (t *T) Shallow(got interface{}, expectedPtr interface{}, args ...interface{}) bool Shallow is a shortcut for:\nt.Cmp(got, Shallow(expectedPtr), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also  T.Shallow godoc.\n Examples    Base example   t := NewT(\u0026amp;testing.T{}) type MyStruct struct { Value int } data := MyStruct{Value: 12} got := \u0026amp;data ok := t.Shallow(got, \u0026amp;data, \u0026#34;checks pointers only, not contents\u0026#34;) fmt.Println(ok) // Same contents, but not same pointer \tok = t.Shallow(got, \u0026amp;MyStruct{Value: 12}, \u0026#34;checks pointers only, not contents\u0026#34;) fmt.Println(ok) // Output: \t// true \t// false     Slice example   t := NewT(\u0026amp;testing.T{}) back := []int{1, 2, 3, 1, 2, 3} a := back[:3] b := back[3:] ok := t.Shallow(a, back) fmt.Println(\u0026#34;are ≠ but share the same area:\u0026#34;, ok) ok = t.Shallow(b, back) fmt.Println(\u0026#34;are = but do not point to same area:\u0026#34;, ok) // Output: \t// are ≠ but share the same area: true \t// are = but do not point to same area: false     String example   t := NewT(\u0026amp;testing.T{}) back := \u0026#34;foobarfoobar\u0026#34; a := back[:6] b := back[6:] ok := t.Shallow(a, back) fmt.Println(\u0026#34;are ≠ but share the same area:\u0026#34;, ok) ok = t.Shallow(b, a) fmt.Println(\u0026#34;are = but do not point to same area:\u0026#34;, ok) // Output: \t// are ≠ but share the same area: true \t// are = but do not point to same area: false  \n"
},
{
	"uri": "https://go-testdeep.zetta.rocks/operators/slice/",
	"title": "Slice",
	"tags": [],
	"description": "",
	"content": " func Slice(model interface{}, expectedEntries ArrayEntries) TestDeep Slice operator compares the contents of a slice or a pointer on a slice against the non-zero values of model (if any) and the values of expectedEntries.\nmodel must be the same type as compared data.\nexpectedEntries can be nil, if no zero entries are expected and no TestDeep operator are involved.\nTypeBehind method returns the reflect.Type of model.\n See also  Slice godoc.\n Examples    Slice example   t := \u0026amp;testing.T{} got := []int{42, 58, 26} ok := Cmp(t, got, Slice([]int{42}, ArrayEntries{1: 58, 2: Ignore()}), \u0026#34;checks slice %v\u0026#34;, got) fmt.Println(ok) ok = Cmp(t, got, Slice([]int{}, ArrayEntries{0: 42, 1: 58, 2: Ignore()}), \u0026#34;checks slice %v\u0026#34;, got) fmt.Println(ok) ok = Cmp(t, got, Slice(([]int)(nil), ArrayEntries{0: 42, 1: 58, 2: Ignore()}), \u0026#34;checks slice %v\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// true \t// true     TypedSlice example   t := \u0026amp;testing.T{} type MySlice []int got := MySlice{42, 58, 26} ok := Cmp(t, got, Slice(MySlice{42}, ArrayEntries{1: 58, 2: Ignore()}), \u0026#34;checks typed slice %v\u0026#34;, got) fmt.Println(ok) ok = Cmp(t, \u0026amp;got, Slice(\u0026amp;MySlice{42}, ArrayEntries{1: 58, 2: Ignore()}), \u0026#34;checks pointer on typed slice %v\u0026#34;, got) fmt.Println(ok) ok = Cmp(t, \u0026amp;got, Slice(\u0026amp;MySlice{}, ArrayEntries{0: 42, 1: 58, 2: Ignore()}), \u0026#34;checks pointer on typed slice %v\u0026#34;, got) fmt.Println(ok) ok = Cmp(t, \u0026amp;got, Slice((*MySlice)(nil), ArrayEntries{0: 42, 1: 58, 2: Ignore()}), \u0026#34;checks pointer on typed slice %v\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// true \t// true \t// true  \nCmpSlice shortcut func CmpSlice(t TestingT, got interface{}, model interface{}, expectedEntries ArrayEntries, args ...interface{}) bool CmpSlice is a shortcut for:\nCmp(t, got, Slice(model, expectedEntries), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also  CmpSlice godoc.\n Examples    Slice example   t := \u0026amp;testing.T{} got := []int{42, 58, 26} ok := CmpSlice(t, got, []int{42}, ArrayEntries{1: 58, 2: Ignore()}, \u0026#34;checks slice %v\u0026#34;, got) fmt.Println(ok) ok = CmpSlice(t, got, []int{}, ArrayEntries{0: 42, 1: 58, 2: Ignore()}, \u0026#34;checks slice %v\u0026#34;, got) fmt.Println(ok) ok = CmpSlice(t, got, ([]int)(nil), ArrayEntries{0: 42, 1: 58, 2: Ignore()}, \u0026#34;checks slice %v\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// true \t// true     TypedSlice example   t := \u0026amp;testing.T{} type MySlice []int got := MySlice{42, 58, 26} ok := CmpSlice(t, got, MySlice{42}, ArrayEntries{1: 58, 2: Ignore()}, \u0026#34;checks typed slice %v\u0026#34;, got) fmt.Println(ok) ok = CmpSlice(t, \u0026amp;got, \u0026amp;MySlice{42}, ArrayEntries{1: 58, 2: Ignore()}, \u0026#34;checks pointer on typed slice %v\u0026#34;, got) fmt.Println(ok) ok = CmpSlice(t, \u0026amp;got, \u0026amp;MySlice{}, ArrayEntries{0: 42, 1: 58, 2: Ignore()}, \u0026#34;checks pointer on typed slice %v\u0026#34;, got) fmt.Println(ok) ok = CmpSlice(t, \u0026amp;got, (*MySlice)(nil), ArrayEntries{0: 42, 1: 58, 2: Ignore()}, \u0026#34;checks pointer on typed slice %v\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// true \t// true \t// true  \nT.Slice shortcut func (t *T) Slice(got interface{}, model interface{}, expectedEntries ArrayEntries, args ...interface{}) bool Slice is a shortcut for:\nt.Cmp(got, Slice(model, expectedEntries), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also  T.Slice godoc.\n Examples    Slice example   t := NewT(\u0026amp;testing.T{}) got := []int{42, 58, 26} ok := t.Slice(got, []int{42}, ArrayEntries{1: 58, 2: Ignore()}, \u0026#34;checks slice %v\u0026#34;, got) fmt.Println(ok) ok = t.Slice(got, []int{}, ArrayEntries{0: 42, 1: 58, 2: Ignore()}, \u0026#34;checks slice %v\u0026#34;, got) fmt.Println(ok) ok = t.Slice(got, ([]int)(nil), ArrayEntries{0: 42, 1: 58, 2: Ignore()}, \u0026#34;checks slice %v\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// true \t// true     TypedSlice example   t := NewT(\u0026amp;testing.T{}) type MySlice []int got := MySlice{42, 58, 26} ok := t.Slice(got, MySlice{42}, ArrayEntries{1: 58, 2: Ignore()}, \u0026#34;checks typed slice %v\u0026#34;, got) fmt.Println(ok) ok = t.Slice(\u0026amp;got, \u0026amp;MySlice{42}, ArrayEntries{1: 58, 2: Ignore()}, \u0026#34;checks pointer on typed slice %v\u0026#34;, got) fmt.Println(ok) ok = t.Slice(\u0026amp;got, \u0026amp;MySlice{}, ArrayEntries{0: 42, 1: 58, 2: Ignore()}, \u0026#34;checks pointer on typed slice %v\u0026#34;, got) fmt.Println(ok) ok = t.Slice(\u0026amp;got, (*MySlice)(nil), ArrayEntries{0: 42, 1: 58, 2: Ignore()}, \u0026#34;checks pointer on typed slice %v\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// true \t// true \t// true  \n"
},
{
	"uri": "https://go-testdeep.zetta.rocks/operators/smuggle/",
	"title": "Smuggle",
	"tags": [],
	"description": "",
	"content": " func Smuggle(fn interface{}, expectedValue interface{}) TestDeep Smuggle operator allows to change data contents or mutate it into another type before stepping down in favor of generic comparison process. Of course it is a smuggler operator. So fn is a function that must take one parameter whose type must be convertible to the type of the compared value (as a convenient shortcut, fn can be a string specifying a fields-path through structs, see below for details).\nfn must return at least one value. These value will be compared as is to expectedValue, here integer 28:\nSmuggle(func (value string) int { num, _ := strconv.Atoi(value) return num }, 28) or using an other TestDeep operator, here Between(28, 30):\nSmuggle(func (value string) int { num, _ := strconv.Atoi(value) return num }, Between(28, 30)) fn can return a second boolean value, used to tell that a problem occurred and so stop the comparison:\nSmuggle(func (value string) (int, bool) { num, err := strconv.Atoi(value) return num, err == nil }, Between(28, 30)) fn can return a third string value which is used to describe the test when a problem occurred (false second boolean value):\nSmuggle(func (value string) (int, bool, string) { num, err := strconv.Atoi(value) if err != nil { return 0, false, \u0026#34;string must contain a number\u0026#34; } return num, true, \u0026#34;\u0026#34; }, Between(28, 30)) Instead of returning (X, bool) or (X, bool, string), fn can return (X, error). When a problem occurs, the returned error is non-nil, as in:\nSmuggle(func (value string) (int, error) { num, err := strconv.Atoi(value) return num, err }, Between(28, 30)) Which can be simplified to:\nSmuggle(strconv.Atoi, Between(28, 30)) Imagine you want to compare that the Year of a date is between 2010 and 2020:\nSmuggle(func (date time.Time) int { return date.Year() }, Between(2010, 2020)) In this case the data location forwarded to next test will be something like \u0026ldquo;DATA.MyTimeField\u0026rdquo;, but you can act on it too by returning a SmuggledGot struct (by value or by address):\nSmuggle(func (date time.Time) SmuggledGot { return SmuggledGot{ Name: \u0026#34;Year\u0026#34;, Got: date.Year(), } }, Between(2010, 2020)) then the data location forwarded to next test will be something like \u0026ldquo;DATA.MyTimeField.Year\u0026rdquo;. The \u0026ldquo;.\u0026rdquo; between the current path (here \u0026ldquo;DATA.MyTimeField\u0026rdquo;) and the returned Name \u0026ldquo;Year\u0026rdquo; is automatically added when Name starts with a Letter.\nNote that SmuggledGot and *SmuggledGot returns are treated equally, and they are only used when fn has only one returned value or when the second boolean returned value is true.\nOf course, all cases can go together:\n// Accepts a \u0026#34;YYYY/mm/DD HH:MM:SS\u0026#34; string to produce a time.Time and tests // whether this date is contained between 2 hours before now and now. Smuggle(func (date string) (*SmuggledGot, bool, string) { date, err := time.Parse(\u0026#34;2006/01/02 15:04:05\u0026#34;, date) if err != nil { return nil, false, `date must conform to \u0026#34;YYYY/mm/DD HH:MM:SS\u0026#34; format` } return \u0026amp;SmuggledGot{ Name: \u0026#34;Date\u0026#34;, Got: date, }, true, \u0026#34;\u0026#34; }, Between(time.Now().Add(-2*time.Hour), time.Now())) or:\n// Accepts a \u0026#34;YYYY/mm/DD HH:MM:SS\u0026#34; string to produce a time.Time and tests // whether this date is contained between 2 hours before now and now. Smuggle(func (date string) (*SmuggledGot, error) { date, err := time.Parse(\u0026#34;2006/01/02 15:04:05\u0026#34;, date) if err != nil { return nil, err } return \u0026amp;SmuggledGot{ Name: \u0026#34;Date\u0026#34;, Got: date, }, nil }, Between(time.Now().Add(-2*time.Hour), time.Now())) Smuggle can also be used to access a struct field embedded in several struct layers.\ntype A struct { Num int } type B struct { A *A } type C struct { B B } got := C{B: B{A: \u0026amp;A{Num: 12}}} // Tests that got.B.A.Num is 12 Cmp(t, got, Smuggle(func (c C) int { return c.B.A.Num }, 12)) As brought up above, a field-path can be passed as fn value instead of a function pointer. Using this feature, the Cmp call in the above example can be rewritten as follows:\n// Tests that got.B.A.Num is 12 Cmp(t, got, Smuggle(\u0026#34;B.A.Num\u0026#34;, 12)) Behind the scenes, a temporary function is automatically created to achieve the same goal, but add some checks against nil values and auto-dereference interfaces and pointers.\nThe difference between Smuggle and Code operators is that Code is used to do a final comparison while Smuggle transforms the data and then steps down in favor of generic comparison process. Moreover, the type accepted as input for the function is more lax to facilitate the tests writing (eg. the function can accept a float64 and the got value be an int). See examples. On the other hand, the output type is strict and must match exactly the expected value type. The fields-path string fn shortcut is not available with Code operator.\nTypeBehind method returns the reflect.Type of only parameter of fn. For the case where fn is a fields-path, it is always interface{}, as the type can not be known in advance.\n See also  Smuggle godoc.\n Examples    Convert example   t := \u0026amp;testing.T{} got := int64(123) ok := Cmp(t, got, Smuggle(func(n int64) int { return int(n) }, 123), \u0026#34;checks int64 got against an int value\u0026#34;) fmt.Println(ok) ok = Cmp(t, \u0026#34;123\u0026#34;, Smuggle( func(numStr string) (int, bool) { n, err := strconv.Atoi(numStr) return n, err == nil }, Between(120, 130)), \u0026#34;checks that number in %#v is in [120 .. 130]\u0026#34;) fmt.Println(ok) ok = Cmp(t, \u0026#34;123\u0026#34;, Smuggle( func(numStr string) (int, bool, string) { n, err := strconv.Atoi(numStr) if err != nil { return 0, false, \u0026#34;string must contain a number\u0026#34; } return n, true, \u0026#34;\u0026#34; }, Between(120, 130)), \u0026#34;checks that number in %#v is in [120 .. 130]\u0026#34;) fmt.Println(ok) ok = Cmp(t, \u0026#34;123\u0026#34;, Smuggle( func(numStr string) (int, error) { return strconv.Atoi(numStr) }, Between(120, 130)), \u0026#34;checks that number in %#v is in [120 .. 130]\u0026#34;) fmt.Println(ok) // Short version :) \tok = Cmp(t, \u0026#34;123\u0026#34;, Smuggle(strconv.Atoi, Between(120, 130)), \u0026#34;checks that number in %#v is in [120 .. 130]\u0026#34;) fmt.Println(ok) // Output: \t// true \t// true \t// true \t// true \t// true     Lax example   t := \u0026amp;testing.T{} // got is an int16 and Smuggle func input is an int64: it is OK \tgot := int(123) ok := Cmp(t, got, Smuggle(func(n int64) uint32 { return uint32(n) }, uint32(123))) fmt.Println(\u0026#34;got int16(123) → smuggle via int64 → uint32(123):\u0026#34;, ok) // Output: \t// got int16(123) → smuggle via int64 → uint32(123): true     Auto_unmarshal example   t := \u0026amp;testing.T{} // Automatically json.Unmarshal to compare \tgot := []byte(`{\u0026#34;a\u0026#34;:1,\u0026#34;b\u0026#34;:2}`) ok := Cmp(t, got, Smuggle( func(b json.RawMessage) (r map[string]int, err error) { err = json.Unmarshal(b, \u0026amp;r) return }, map[string]int{ \u0026#34;a\u0026#34;: 1, \u0026#34;b\u0026#34;: 2, })) fmt.Println(\u0026#34;JSON contents is OK:\u0026#34;, ok) // Output: \t// JSON contents is OK: true     Complex example   t := \u0026amp;testing.T{} // No end date but a start date and a duration \ttype StartDuration struct { StartDate time.Time Duration time.Duration } // Checks that end date is between 17th and 19th February both at 0h \t// for each of these durations in hours  for _, duration := range []time.Duration{48, 72, 96} { got := StartDuration{ StartDate: time.Date(2018, time.February, 14, 12, 13, 14, 0, time.UTC), Duration: duration * time.Hour, } // Simplest way, but in case of Between() failure, error will be bound \t// to DATA\u0026lt;smuggled\u0026gt;, not very clear... \tok := Cmp(t, got, Smuggle( func(sd StartDuration) time.Time { return sd.StartDate.Add(sd.Duration) }, Between( time.Date(2018, time.February, 17, 0, 0, 0, 0, time.UTC), time.Date(2018, time.February, 19, 0, 0, 0, 0, time.UTC)))) fmt.Println(ok) // Name the computed value \u0026#34;ComputedEndDate\u0026#34; to render a Between() failure \t// more understandable, so error will be bound to DATA.ComputedEndDate \tok = Cmp(t, got, Smuggle( func(sd StartDuration) SmuggledGot { return SmuggledGot{ Name: \u0026#34;ComputedEndDate\u0026#34;, Got: sd.StartDate.Add(sd.Duration), } }, Between( time.Date(2018, time.February, 17, 0, 0, 0, 0, time.UTC), time.Date(2018, time.February, 19, 0, 0, 0, 0, time.UTC)))) fmt.Println(ok) } // Output: \t// false \t// false \t// true \t// true \t// true \t// true     Interface example   t := \u0026amp;testing.T{} gotTime, err := time.Parse(time.RFC3339, \u0026#34;2018-05-23T12:13:14Z\u0026#34;) if err != nil { t.Fatal(err) } // Do not check the struct itself, but its stringified form \tok := Cmp(t, gotTime, Smuggle(func(s fmt.Stringer) string { return s.String() }, \u0026#34;2018-05-23 12:13:14 +0000 UTC\u0026#34;)) fmt.Println(\u0026#34;stringified time.Time OK:\u0026#34;, ok) // If got does not implement the fmt.Stringer interface, it fails \t// without calling the Smuggle func \ttype MyTime time.Time ok = Cmp(t, MyTime(gotTime), Smuggle(func(s fmt.Stringer) string { fmt.Println(\u0026#34;Smuggle func called!\u0026#34;) return s.String() }, \u0026#34;2018-05-23 12:13:14 +0000 UTC\u0026#34;)) fmt.Println(\u0026#34;stringified MyTime OK:\u0026#34;, ok) // Output \t// stringified time.Time OK: true \t// stringified MyTime OK: false     Field_path example   t := \u0026amp;testing.T{} type Body struct { Name string Value interface{} } type Request struct { Body *Body } type Transaction struct { Request } type ValueNum struct { Num int } got := \u0026amp;Transaction{ Request: Request{ Body: \u0026amp;Body{ Name: \u0026#34;test\u0026#34;, Value: \u0026amp;ValueNum{Num: 123}, }, }, } // Want to check whether Num is between 100 and 200? \tok := Cmp(t, got, Smuggle( func(t *Transaction) (int, error) { if t.Request.Body == nil || t.Request.Body.Value == nil { return 0, errors.New(\u0026#34;Request.Body or Request.Body.Value is nil\u0026#34;) } if v, ok := t.Request.Body.Value.(*ValueNum); ok \u0026amp;\u0026amp; v != nil { return v.Num, nil } return 0, errors.New(\u0026#34;Request.Body.Value isn\u0026#39;t *ValueNum or nil\u0026#34;) }, Between(100, 200))) fmt.Println(\u0026#34;check Num by hand:\u0026#34;, ok) // Same, but automagically generated... \tok = Cmp(t, got, Smuggle(\u0026#34;Request.Body.Value.Num\u0026#34;, Between(100, 200))) fmt.Println(\u0026#34;check Num using a fields-path:\u0026#34;, ok) // And as Request is an anonymous field, can be simplified further \t// as it can be omitted \tok = Cmp(t, got, Smuggle(\u0026#34;Body.Value.Num\u0026#34;, Between(100, 200))) fmt.Println(\u0026#34;check Num using an other fields-path:\u0026#34;, ok) // Output: \t// check Num by hand: true \t// check Num using a fields-path: true \t// check Num using an other fields-path: true  \nCmpSmuggle shortcut func CmpSmuggle(t TestingT, got interface{}, fn interface{}, expectedValue interface{}, args ...interface{}) bool CmpSmuggle is a shortcut for:\nCmp(t, got, Smuggle(fn, expectedValue), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also  CmpSmuggle godoc.\n Examples    Convert example   t := \u0026amp;testing.T{} got := int64(123) ok := CmpSmuggle(t, got, func(n int64) int { return int(n) }, 123, \u0026#34;checks int64 got against an int value\u0026#34;) fmt.Println(ok) ok = CmpSmuggle(t, \u0026#34;123\u0026#34;, func(numStr string) (int, bool) { n, err := strconv.Atoi(numStr) return n, err == nil }, Between(120, 130), \u0026#34;checks that number in %#v is in [120 .. 130]\u0026#34;) fmt.Println(ok) ok = CmpSmuggle(t, \u0026#34;123\u0026#34;, func(numStr string) (int, bool, string) { n, err := strconv.Atoi(numStr) if err != nil { return 0, false, \u0026#34;string must contain a number\u0026#34; } return n, true, \u0026#34;\u0026#34; }, Between(120, 130), \u0026#34;checks that number in %#v is in [120 .. 130]\u0026#34;) fmt.Println(ok) ok = CmpSmuggle(t, \u0026#34;123\u0026#34;, func(numStr string) (int, error) { return strconv.Atoi(numStr) }, Between(120, 130), \u0026#34;checks that number in %#v is in [120 .. 130]\u0026#34;) fmt.Println(ok) // Short version :) \tok = CmpSmuggle(t, \u0026#34;123\u0026#34;, strconv.Atoi, Between(120, 130), \u0026#34;checks that number in %#v is in [120 .. 130]\u0026#34;) fmt.Println(ok) // Output: \t// true \t// true \t// true \t// true \t// true     Lax example   t := \u0026amp;testing.T{} // got is an int16 and Smuggle func input is an int64: it is OK \tgot := int(123) ok := CmpSmuggle(t, got, func(n int64) uint32 { return uint32(n) }, uint32(123)) fmt.Println(\u0026#34;got int16(123) → smuggle via int64 → uint32(123):\u0026#34;, ok) // Output: \t// got int16(123) → smuggle via int64 → uint32(123): true     Auto_unmarshal example   t := \u0026amp;testing.T{} // Automatically json.Unmarshal to compare \tgot := []byte(`{\u0026#34;a\u0026#34;:1,\u0026#34;b\u0026#34;:2}`) ok := CmpSmuggle(t, got, func(b json.RawMessage) (r map[string]int, err error) { err = json.Unmarshal(b, \u0026amp;r) return }, map[string]int{ \u0026#34;a\u0026#34;: 1, \u0026#34;b\u0026#34;: 2, }) fmt.Println(\u0026#34;JSON contents is OK:\u0026#34;, ok) // Output: \t// JSON contents is OK: true     Complex example   t := \u0026amp;testing.T{} // No end date but a start date and a duration \ttype StartDuration struct { StartDate time.Time Duration time.Duration } // Checks that end date is between 17th and 19th February both at 0h \t// for each of these durations in hours  for _, duration := range []time.Duration{48, 72, 96} { got := StartDuration{ StartDate: time.Date(2018, time.February, 14, 12, 13, 14, 0, time.UTC), Duration: duration * time.Hour, } // Simplest way, but in case of Between() failure, error will be bound \t// to DATA\u0026lt;smuggled\u0026gt;, not very clear... \tok := CmpSmuggle(t, got, func(sd StartDuration) time.Time { return sd.StartDate.Add(sd.Duration) }, Between( time.Date(2018, time.February, 17, 0, 0, 0, 0, time.UTC), time.Date(2018, time.February, 19, 0, 0, 0, 0, time.UTC))) fmt.Println(ok) // Name the computed value \u0026#34;ComputedEndDate\u0026#34; to render a Between() failure \t// more understandable, so error will be bound to DATA.ComputedEndDate \tok = CmpSmuggle(t, got, func(sd StartDuration) SmuggledGot { return SmuggledGot{ Name: \u0026#34;ComputedEndDate\u0026#34;, Got: sd.StartDate.Add(sd.Duration), } }, Between( time.Date(2018, time.February, 17, 0, 0, 0, 0, time.UTC), time.Date(2018, time.February, 19, 0, 0, 0, 0, time.UTC))) fmt.Println(ok) } // Output: \t// false \t// false \t// true \t// true \t// true \t// true     Interface example   t := \u0026amp;testing.T{} gotTime, err := time.Parse(time.RFC3339, \u0026#34;2018-05-23T12:13:14Z\u0026#34;) if err != nil { t.Fatal(err) } // Do not check the struct itself, but its stringified form \tok := CmpSmuggle(t, gotTime, func(s fmt.Stringer) string { return s.String() }, \u0026#34;2018-05-23 12:13:14 +0000 UTC\u0026#34;) fmt.Println(\u0026#34;stringified time.Time OK:\u0026#34;, ok) // If got does not implement the fmt.Stringer interface, it fails \t// without calling the Smuggle func \ttype MyTime time.Time ok = CmpSmuggle(t, MyTime(gotTime), func(s fmt.Stringer) string { fmt.Println(\u0026#34;Smuggle func called!\u0026#34;) return s.String() }, \u0026#34;2018-05-23 12:13:14 +0000 UTC\u0026#34;) fmt.Println(\u0026#34;stringified MyTime OK:\u0026#34;, ok) // Output \t// stringified time.Time OK: true \t// stringified MyTime OK: false     Field_path example   t := \u0026amp;testing.T{} type Body struct { Name string Value interface{} } type Request struct { Body *Body } type Transaction struct { Request } type ValueNum struct { Num int } got := \u0026amp;Transaction{ Request: Request{ Body: \u0026amp;Body{ Name: \u0026#34;test\u0026#34;, Value: \u0026amp;ValueNum{Num: 123}, }, }, } // Want to check whether Num is between 100 and 200? \tok := CmpSmuggle(t, got, func(t *Transaction) (int, error) { if t.Request.Body == nil || t.Request.Body.Value == nil { return 0, errors.New(\u0026#34;Request.Body or Request.Body.Value is nil\u0026#34;) } if v, ok := t.Request.Body.Value.(*ValueNum); ok \u0026amp;\u0026amp; v != nil { return v.Num, nil } return 0, errors.New(\u0026#34;Request.Body.Value isn\u0026#39;t *ValueNum or nil\u0026#34;) }, Between(100, 200)) fmt.Println(\u0026#34;check Num by hand:\u0026#34;, ok) // Same, but automagically generated... \tok = CmpSmuggle(t, got, \u0026#34;Request.Body.Value.Num\u0026#34;, Between(100, 200)) fmt.Println(\u0026#34;check Num using a fields-path:\u0026#34;, ok) // And as Request is an anonymous field, can be simplified further \t// as it can be omitted \tok = CmpSmuggle(t, got, \u0026#34;Body.Value.Num\u0026#34;, Between(100, 200)) fmt.Println(\u0026#34;check Num using an other fields-path:\u0026#34;, ok) // Output: \t// check Num by hand: true \t// check Num using a fields-path: true \t// check Num using an other fields-path: true  \nT.Smuggle shortcut func (t *T) Smuggle(got interface{}, fn interface{}, expectedValue interface{}, args ...interface{}) bool Smuggle is a shortcut for:\nt.Cmp(got, Smuggle(fn, expectedValue), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also  T.Smuggle godoc.\n Examples    Convert example   t := NewT(\u0026amp;testing.T{}) got := int64(123) ok := t.Smuggle(got, func(n int64) int { return int(n) }, 123, \u0026#34;checks int64 got against an int value\u0026#34;) fmt.Println(ok) ok = t.Smuggle(\u0026#34;123\u0026#34;, func(numStr string) (int, bool) { n, err := strconv.Atoi(numStr) return n, err == nil }, Between(120, 130), \u0026#34;checks that number in %#v is in [120 .. 130]\u0026#34;) fmt.Println(ok) ok = t.Smuggle(\u0026#34;123\u0026#34;, func(numStr string) (int, bool, string) { n, err := strconv.Atoi(numStr) if err != nil { return 0, false, \u0026#34;string must contain a number\u0026#34; } return n, true, \u0026#34;\u0026#34; }, Between(120, 130), \u0026#34;checks that number in %#v is in [120 .. 130]\u0026#34;) fmt.Println(ok) ok = t.Smuggle(\u0026#34;123\u0026#34;, func(numStr string) (int, error) { return strconv.Atoi(numStr) }, Between(120, 130), \u0026#34;checks that number in %#v is in [120 .. 130]\u0026#34;) fmt.Println(ok) // Short version :) \tok = t.Smuggle(\u0026#34;123\u0026#34;, strconv.Atoi, Between(120, 130), \u0026#34;checks that number in %#v is in [120 .. 130]\u0026#34;) fmt.Println(ok) // Output: \t// true \t// true \t// true \t// true \t// true     Lax example   t := NewT(\u0026amp;testing.T{}) // got is an int16 and Smuggle func input is an int64: it is OK \tgot := int(123) ok := t.Smuggle(got, func(n int64) uint32 { return uint32(n) }, uint32(123)) fmt.Println(\u0026#34;got int16(123) → smuggle via int64 → uint32(123):\u0026#34;, ok) // Output: \t// got int16(123) → smuggle via int64 → uint32(123): true     Auto_unmarshal example   t := NewT(\u0026amp;testing.T{}) // Automatically json.Unmarshal to compare \tgot := []byte(`{\u0026#34;a\u0026#34;:1,\u0026#34;b\u0026#34;:2}`) ok := t.Smuggle(got, func(b json.RawMessage) (r map[string]int, err error) { err = json.Unmarshal(b, \u0026amp;r) return }, map[string]int{ \u0026#34;a\u0026#34;: 1, \u0026#34;b\u0026#34;: 2, }) fmt.Println(\u0026#34;JSON contents is OK:\u0026#34;, ok) // Output: \t// JSON contents is OK: true     Complex example   t := NewT(\u0026amp;testing.T{}) // No end date but a start date and a duration \ttype StartDuration struct { StartDate time.Time Duration time.Duration } // Checks that end date is between 17th and 19th February both at 0h \t// for each of these durations in hours  for _, duration := range []time.Duration{48, 72, 96} { got := StartDuration{ StartDate: time.Date(2018, time.February, 14, 12, 13, 14, 0, time.UTC), Duration: duration * time.Hour, } // Simplest way, but in case of Between() failure, error will be bound \t// to DATA\u0026lt;smuggled\u0026gt;, not very clear... \tok := t.Smuggle(got, func(sd StartDuration) time.Time { return sd.StartDate.Add(sd.Duration) }, Between( time.Date(2018, time.February, 17, 0, 0, 0, 0, time.UTC), time.Date(2018, time.February, 19, 0, 0, 0, 0, time.UTC))) fmt.Println(ok) // Name the computed value \u0026#34;ComputedEndDate\u0026#34; to render a Between() failure \t// more understandable, so error will be bound to DATA.ComputedEndDate \tok = t.Smuggle(got, func(sd StartDuration) SmuggledGot { return SmuggledGot{ Name: \u0026#34;ComputedEndDate\u0026#34;, Got: sd.StartDate.Add(sd.Duration), } }, Between( time.Date(2018, time.February, 17, 0, 0, 0, 0, time.UTC), time.Date(2018, time.February, 19, 0, 0, 0, 0, time.UTC))) fmt.Println(ok) } // Output: \t// false \t// false \t// true \t// true \t// true \t// true     Interface example   t := NewT(\u0026amp;testing.T{}) gotTime, err := time.Parse(time.RFC3339, \u0026#34;2018-05-23T12:13:14Z\u0026#34;) if err != nil { t.Fatal(err) } // Do not check the struct itself, but its stringified form \tok := t.Smuggle(gotTime, func(s fmt.Stringer) string { return s.String() }, \u0026#34;2018-05-23 12:13:14 +0000 UTC\u0026#34;) fmt.Println(\u0026#34;stringified time.Time OK:\u0026#34;, ok) // If got does not implement the fmt.Stringer interface, it fails \t// without calling the Smuggle func \ttype MyTime time.Time ok = t.Smuggle(MyTime(gotTime), func(s fmt.Stringer) string { fmt.Println(\u0026#34;Smuggle func called!\u0026#34;) return s.String() }, \u0026#34;2018-05-23 12:13:14 +0000 UTC\u0026#34;) fmt.Println(\u0026#34;stringified MyTime OK:\u0026#34;, ok) // Output \t// stringified time.Time OK: true \t// stringified MyTime OK: false     Field_path example   t := NewT(\u0026amp;testing.T{}) type Body struct { Name string Value interface{} } type Request struct { Body *Body } type Transaction struct { Request } type ValueNum struct { Num int } got := \u0026amp;Transaction{ Request: Request{ Body: \u0026amp;Body{ Name: \u0026#34;test\u0026#34;, Value: \u0026amp;ValueNum{Num: 123}, }, }, } // Want to check whether Num is between 100 and 200? \tok := t.Smuggle(got, func(t *Transaction) (int, error) { if t.Request.Body == nil || t.Request.Body.Value == nil { return 0, errors.New(\u0026#34;Request.Body or Request.Body.Value is nil\u0026#34;) } if v, ok := t.Request.Body.Value.(*ValueNum); ok \u0026amp;\u0026amp; v != nil { return v.Num, nil } return 0, errors.New(\u0026#34;Request.Body.Value isn\u0026#39;t *ValueNum or nil\u0026#34;) }, Between(100, 200)) fmt.Println(\u0026#34;check Num by hand:\u0026#34;, ok) // Same, but automagically generated... \tok = t.Smuggle(got, \u0026#34;Request.Body.Value.Num\u0026#34;, Between(100, 200)) fmt.Println(\u0026#34;check Num using a fields-path:\u0026#34;, ok) // And as Request is an anonymous field, can be simplified further \t// as it can be omitted \tok = t.Smuggle(got, \u0026#34;Body.Value.Num\u0026#34;, Between(100, 200)) fmt.Println(\u0026#34;check Num using an other fields-path:\u0026#34;, ok) // Output: \t// check Num by hand: true \t// check Num using a fields-path: true \t// check Num using an other fields-path: true  \n"
},
{
	"uri": "https://go-testdeep.zetta.rocks/operators/string/",
	"title": "String",
	"tags": [],
	"description": "",
	"content": " func String(expected string) TestDeep String operator allows to compare a string (or convertible), error or fmt.Stringer interface (error interface is tested before fmt.Stringer.)\nerr := errors.New(\u0026#34;error!\u0026#34;) Cmp(t, err, String(\u0026#34;error!\u0026#34;)) // succeeds  bstr := bytes.NewBufferString(\u0026#34;fmt.Stringer!\u0026#34;) Cmp(t, bstr, String(\u0026#34;fmt.Stringer!\u0026#34;)) // succeeds  See also  String godoc.\n Examples    Base example   t := \u0026amp;testing.T{} got := \u0026#34;foobar\u0026#34; ok := Cmp(t, got, String(\u0026#34;foobar\u0026#34;), \u0026#34;checks %s\u0026#34;, got) fmt.Println(ok) // Output: \t// true     Stringer example   t := \u0026amp;testing.T{} // bytes.Buffer implements fmt.Stringer \tgot := bytes.NewBufferString(\u0026#34;foobar\u0026#34;) ok := Cmp(t, got, String(\u0026#34;foobar\u0026#34;), \u0026#34;checks %s\u0026#34;, got) fmt.Println(ok) // Output: \t// true     Error example   t := \u0026amp;testing.T{} got := errors.New(\u0026#34;foobar\u0026#34;) ok := Cmp(t, got, String(\u0026#34;foobar\u0026#34;), \u0026#34;checks %s\u0026#34;, got) fmt.Println(ok) // Output: \t// true  \nCmpString shortcut func CmpString(t TestingT, got interface{}, expected string, args ...interface{}) bool CmpString is a shortcut for:\nCmp(t, got, String(expected), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also  CmpString godoc.\n Examples    Base example   t := \u0026amp;testing.T{} got := \u0026#34;foobar\u0026#34; ok := CmpString(t, got, \u0026#34;foobar\u0026#34;, \u0026#34;checks %s\u0026#34;, got) fmt.Println(ok) // Output: \t// true     Stringer example   t := \u0026amp;testing.T{} // bytes.Buffer implements fmt.Stringer \tgot := bytes.NewBufferString(\u0026#34;foobar\u0026#34;) ok := CmpString(t, got, \u0026#34;foobar\u0026#34;, \u0026#34;checks %s\u0026#34;, got) fmt.Println(ok) // Output: \t// true     Error example   t := \u0026amp;testing.T{} got := errors.New(\u0026#34;foobar\u0026#34;) ok := CmpString(t, got, \u0026#34;foobar\u0026#34;, \u0026#34;checks %s\u0026#34;, got) fmt.Println(ok) // Output: \t// true  \nT.String shortcut func (t *T) String(got interface{}, expected string, args ...interface{}) bool String is a shortcut for:\nt.Cmp(got, String(expected), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also  T.String godoc.\n Examples    Base example   t := NewT(\u0026amp;testing.T{}) got := \u0026#34;foobar\u0026#34; ok := t.String(got, \u0026#34;foobar\u0026#34;, \u0026#34;checks %s\u0026#34;, got) fmt.Println(ok) // Output: \t// true     Stringer example   t := NewT(\u0026amp;testing.T{}) // bytes.Buffer implements fmt.Stringer \tgot := bytes.NewBufferString(\u0026#34;foobar\u0026#34;) ok := t.String(got, \u0026#34;foobar\u0026#34;, \u0026#34;checks %s\u0026#34;, got) fmt.Println(ok) // Output: \t// true     Error example   t := NewT(\u0026amp;testing.T{}) got := errors.New(\u0026#34;foobar\u0026#34;) ok := t.String(got, \u0026#34;foobar\u0026#34;, \u0026#34;checks %s\u0026#34;, got) fmt.Println(ok) // Output: \t// true  \n"
},
{
	"uri": "https://go-testdeep.zetta.rocks/operators/struct/",
	"title": "Struct",
	"tags": [],
	"description": "",
	"content": " func Struct(model interface{}, expectedFields StructFields) TestDeep Struct operator compares the contents of a struct or a pointer on a struct against the non-zero values of model (if any) and the values of expectedFields.\nmodel must be the same type as compared data.\nexpectedFields can be nil, if no zero entries are expected and no TestDeep operator are involved.\nDuring a match, all expected fields must be found to succeed. Non-expected fields are ignored.\nTypeBehind method returns the reflect.Type of model.\n See also  Struct godoc.\n Examples   Base example   t := \u0026amp;testing.T{} type Person struct { Name string Age int NumChildren int } got := Person{ Name: \u0026#34;Foobar\u0026#34;, Age: 42, NumChildren: 3, } // As NumChildren is zero in Struct() call, it is not checked \tok := Cmp(t, got, Struct(Person{Name: \u0026#34;Foobar\u0026#34;}, StructFields{ \u0026#34;Age\u0026#34;: Between(40, 50), }), \u0026#34;checks %v is the right Person\u0026#34;) fmt.Println(ok) // Model can be empty \tok = Cmp(t, got, Struct(Person{}, StructFields{ \u0026#34;Name\u0026#34;: \u0026#34;Foobar\u0026#34;, \u0026#34;Age\u0026#34;: Between(40, 50), \u0026#34;NumChildren\u0026#34;: Not(0), }), \u0026#34;checks %v is the right Person\u0026#34;) fmt.Println(ok) // Works with pointers too \tok = Cmp(t, \u0026amp;got, Struct(\u0026amp;Person{}, StructFields{ \u0026#34;Name\u0026#34;: \u0026#34;Foobar\u0026#34;, \u0026#34;Age\u0026#34;: Between(40, 50), \u0026#34;NumChildren\u0026#34;: Not(0), }), \u0026#34;checks %v is the right Person\u0026#34;) fmt.Println(ok) // Model does not need to be instanciated \tok = Cmp(t, \u0026amp;got, Struct((*Person)(nil), StructFields{ \u0026#34;Name\u0026#34;: \u0026#34;Foobar\u0026#34;, \u0026#34;Age\u0026#34;: Between(40, 50), \u0026#34;NumChildren\u0026#34;: Not(0), }), \u0026#34;checks %v is the right Person\u0026#34;) fmt.Println(ok) // Output: \t// true \t// true \t// true \t// true   CmpStruct shortcut func CmpStruct(t TestingT, got interface{}, model interface{}, expectedFields StructFields, args ...interface{}) bool CmpStruct is a shortcut for:\nCmp(t, got, Struct(model, expectedFields), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also  CmpStruct godoc.\n Examples   Base example   t := \u0026amp;testing.T{} type Person struct { Name string Age int NumChildren int } got := Person{ Name: \u0026#34;Foobar\u0026#34;, Age: 42, NumChildren: 3, } // As NumChildren is zero in Struct() call, it is not checked \tok := CmpStruct(t, got, Person{Name: \u0026#34;Foobar\u0026#34;}, StructFields{ \u0026#34;Age\u0026#34;: Between(40, 50), }, \u0026#34;checks %v is the right Person\u0026#34;) fmt.Println(ok) // Model can be empty \tok = CmpStruct(t, got, Person{}, StructFields{ \u0026#34;Name\u0026#34;: \u0026#34;Foobar\u0026#34;, \u0026#34;Age\u0026#34;: Between(40, 50), \u0026#34;NumChildren\u0026#34;: Not(0), }, \u0026#34;checks %v is the right Person\u0026#34;) fmt.Println(ok) // Works with pointers too \tok = CmpStruct(t, \u0026amp;got, \u0026amp;Person{}, StructFields{ \u0026#34;Name\u0026#34;: \u0026#34;Foobar\u0026#34;, \u0026#34;Age\u0026#34;: Between(40, 50), \u0026#34;NumChildren\u0026#34;: Not(0), }, \u0026#34;checks %v is the right Person\u0026#34;) fmt.Println(ok) // Model does not need to be instanciated \tok = CmpStruct(t, \u0026amp;got, (*Person)(nil), StructFields{ \u0026#34;Name\u0026#34;: \u0026#34;Foobar\u0026#34;, \u0026#34;Age\u0026#34;: Between(40, 50), \u0026#34;NumChildren\u0026#34;: Not(0), }, \u0026#34;checks %v is the right Person\u0026#34;) fmt.Println(ok) // Output: \t// true \t// true \t// true \t// true   T.Struct shortcut func (t *T) Struct(got interface{}, model interface{}, expectedFields StructFields, args ...interface{}) bool Struct is a shortcut for:\nt.Cmp(got, Struct(model, expectedFields), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also  T.Struct godoc.\n Examples   Base example   t := NewT(\u0026amp;testing.T{}) type Person struct { Name string Age int NumChildren int } got := Person{ Name: \u0026#34;Foobar\u0026#34;, Age: 42, NumChildren: 3, } // As NumChildren is zero in Struct() call, it is not checked \tok := t.Struct(got, Person{Name: \u0026#34;Foobar\u0026#34;}, StructFields{ \u0026#34;Age\u0026#34;: Between(40, 50), }, \u0026#34;checks %v is the right Person\u0026#34;) fmt.Println(ok) // Model can be empty \tok = t.Struct(got, Person{}, StructFields{ \u0026#34;Name\u0026#34;: \u0026#34;Foobar\u0026#34;, \u0026#34;Age\u0026#34;: Between(40, 50), \u0026#34;NumChildren\u0026#34;: Not(0), }, \u0026#34;checks %v is the right Person\u0026#34;) fmt.Println(ok) // Works with pointers too \tok = t.Struct(\u0026amp;got, \u0026amp;Person{}, StructFields{ \u0026#34;Name\u0026#34;: \u0026#34;Foobar\u0026#34;, \u0026#34;Age\u0026#34;: Between(40, 50), \u0026#34;NumChildren\u0026#34;: Not(0), }, \u0026#34;checks %v is the right Person\u0026#34;) fmt.Println(ok) // Model does not need to be instanciated \tok = t.Struct(\u0026amp;got, (*Person)(nil), StructFields{ \u0026#34;Name\u0026#34;: \u0026#34;Foobar\u0026#34;, \u0026#34;Age\u0026#34;: Between(40, 50), \u0026#34;NumChildren\u0026#34;: Not(0), }, \u0026#34;checks %v is the right Person\u0026#34;) fmt.Println(ok) // Output: \t// true \t// true \t// true \t// true   "
},
{
	"uri": "https://go-testdeep.zetta.rocks/operators/subbagof/",
	"title": "SubBagOf",
	"tags": [],
	"description": "",
	"content": " func SubBagOf(expectedItems ...interface{}) TestDeep SubBagOf operator compares the contents of an array or a slice (or a pointer on array/slice) without taking care of the order of items.\nDuring a match, each array/slice item should be matched by an expected item to succeed. But some expected items can be missing from the compared array/slice.\nCmp(t, []int{1}, SubBagOf(1, 1, 2)) // succeeds Cmp(t, []int{1, 1, 1}, SubBagOf(1, 1, 2)) // fails, one 1 is an extra item  See also  SubBagOf godoc.\n Examples   Base example   t := \u0026amp;testing.T{} got := []int{1, 3, 5, 8, 8, 1, 2} ok := Cmp(t, got, SubBagOf(0, 0, 1, 1, 2, 2, 3, 3, 5, 5, 8, 8, 9, 9), \u0026#34;checks at least all items are present, in any order\u0026#34;) fmt.Println(ok) // got contains one 8 too many \tok = Cmp(t, got, SubBagOf(0, 0, 1, 1, 2, 2, 3, 3, 5, 5, 8, 9, 9), \u0026#34;checks at least all items are present, in any order\u0026#34;) fmt.Println(ok) got = []int{1, 3, 5, 2} ok = Cmp(t, got, SubBagOf( Between(0, 3), Between(0, 3), Between(0, 3), Between(0, 3), Gt(4), Gt(4)), \u0026#34;checks at least all items match, in any order with TestDeep operators\u0026#34;) fmt.Println(ok) // Output: \t// true \t// false \t// true   CmpSubBagOf shortcut func CmpSubBagOf(t TestingT, got interface{}, expectedItems []interface{}, args ...interface{}) bool CmpSubBagOf is a shortcut for:\nCmp(t, got, SubBagOf(expectedItems...), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also  CmpSubBagOf godoc.\n Examples   Base example   t := \u0026amp;testing.T{} got := []int{1, 3, 5, 8, 8, 1, 2} ok := CmpSubBagOf(t, got, []interface{}{0, 0, 1, 1, 2, 2, 3, 3, 5, 5, 8, 8, 9, 9}, \u0026#34;checks at least all items are present, in any order\u0026#34;) fmt.Println(ok) // got contains one 8 too many \tok = CmpSubBagOf(t, got, []interface{}{0, 0, 1, 1, 2, 2, 3, 3, 5, 5, 8, 9, 9}, \u0026#34;checks at least all items are present, in any order\u0026#34;) fmt.Println(ok) got = []int{1, 3, 5, 2} ok = CmpSubBagOf(t, got, []interface{}{Between(0, 3), Between(0, 3), Between(0, 3), Between(0, 3), Gt(4), Gt(4)}, \u0026#34;checks at least all items match, in any order with TestDeep operators\u0026#34;) fmt.Println(ok) // Output: \t// true \t// false \t// true   T.SubBagOf shortcut func (t *T) SubBagOf(got interface{}, expectedItems []interface{}, args ...interface{}) bool SubBagOf is a shortcut for:\nt.Cmp(got, SubBagOf(expectedItems...), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also  T.SubBagOf godoc.\n Examples   Base example   t := NewT(\u0026amp;testing.T{}) got := []int{1, 3, 5, 8, 8, 1, 2} ok := t.SubBagOf(got, []interface{}{0, 0, 1, 1, 2, 2, 3, 3, 5, 5, 8, 8, 9, 9}, \u0026#34;checks at least all items are present, in any order\u0026#34;) fmt.Println(ok) // got contains one 8 too many \tok = t.SubBagOf(got, []interface{}{0, 0, 1, 1, 2, 2, 3, 3, 5, 5, 8, 9, 9}, \u0026#34;checks at least all items are present, in any order\u0026#34;) fmt.Println(ok) got = []int{1, 3, 5, 2} ok = t.SubBagOf(got, []interface{}{Between(0, 3), Between(0, 3), Between(0, 3), Between(0, 3), Gt(4), Gt(4)}, \u0026#34;checks at least all items match, in any order with TestDeep operators\u0026#34;) fmt.Println(ok) // Output: \t// true \t// false \t// true   "
},
{
	"uri": "https://go-testdeep.zetta.rocks/operators/submapof/",
	"title": "SubMapOf",
	"tags": [],
	"description": "",
	"content": " func SubMapOf(model interface{}, expectedEntries MapEntries) TestDeep SubMapOf operator compares the contents of a map against the non-zero values of model (if any) and the values of expectedEntries.\nmodel must be the same type as compared data.\nexpectedEntries can be nil, if no zero entries are expected and no TestDeep operator are involved.\nDuring a match, each map entry should be matched by an expected entry to succeed. But some expected entries can be missing from the compared map.\nCmp(t, map[string]int{\u0026#34;a\u0026#34;: 1}, SubMapOf(map[string]int{\u0026#34;a\u0026#34;: 1, \u0026#34;b\u0026#34;: 2}, nil) // succeeds  Cmp(t, map[string]int{\u0026#34;a\u0026#34;: 1, \u0026#34;c\u0026#34;: 3}, SubMapOf(map[string]int{\u0026#34;a\u0026#34;: 1, \u0026#34;b\u0026#34;: 2}, nil) // fails, extra {\u0026#34;c\u0026#34;: 3} TypeBehind method returns the reflect.Type of model.\n See also  SubMapOf godoc.\n Examples    Map example   t := \u0026amp;testing.T{} got := map[string]int{\u0026#34;foo\u0026#34;: 12, \u0026#34;bar\u0026#34;: 42} ok := Cmp(t, got, SubMapOf(map[string]int{\u0026#34;bar\u0026#34;: 42}, MapEntries{\u0026#34;foo\u0026#34;: Lt(15), \u0026#34;zip\u0026#34;: 666}), \u0026#34;checks map %v is included in expected keys/values\u0026#34;, got) fmt.Println(ok) // Output: \t// true     TypedMap example   t := \u0026amp;testing.T{} type MyMap map[string]int got := MyMap{\u0026#34;foo\u0026#34;: 12, \u0026#34;bar\u0026#34;: 42} ok := Cmp(t, got, SubMapOf(MyMap{\u0026#34;bar\u0026#34;: 42}, MapEntries{\u0026#34;foo\u0026#34;: Lt(15), \u0026#34;zip\u0026#34;: 666}), \u0026#34;checks typed map %v is included in expected keys/values\u0026#34;, got) fmt.Println(ok) ok = Cmp(t, \u0026amp;got, SubMapOf(\u0026amp;MyMap{\u0026#34;bar\u0026#34;: 42}, MapEntries{\u0026#34;foo\u0026#34;: Lt(15), \u0026#34;zip\u0026#34;: 666}), \u0026#34;checks pointed typed map %v is included in expected keys/values\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// true  \nCmpSubMapOf shortcut func CmpSubMapOf(t TestingT, got interface{}, model interface{}, expectedEntries MapEntries, args ...interface{}) bool CmpSubMapOf is a shortcut for:\nCmp(t, got, SubMapOf(model, expectedEntries), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also  CmpSubMapOf godoc.\n Examples    Map example   t := \u0026amp;testing.T{} got := map[string]int{\u0026#34;foo\u0026#34;: 12, \u0026#34;bar\u0026#34;: 42} ok := CmpSubMapOf(t, got, map[string]int{\u0026#34;bar\u0026#34;: 42}, MapEntries{\u0026#34;foo\u0026#34;: Lt(15), \u0026#34;zip\u0026#34;: 666}, \u0026#34;checks map %v is included in expected keys/values\u0026#34;, got) fmt.Println(ok) // Output: \t// true     TypedMap example   t := \u0026amp;testing.T{} type MyMap map[string]int got := MyMap{\u0026#34;foo\u0026#34;: 12, \u0026#34;bar\u0026#34;: 42} ok := CmpSubMapOf(t, got, MyMap{\u0026#34;bar\u0026#34;: 42}, MapEntries{\u0026#34;foo\u0026#34;: Lt(15), \u0026#34;zip\u0026#34;: 666}, \u0026#34;checks typed map %v is included in expected keys/values\u0026#34;, got) fmt.Println(ok) ok = CmpSubMapOf(t, \u0026amp;got, \u0026amp;MyMap{\u0026#34;bar\u0026#34;: 42}, MapEntries{\u0026#34;foo\u0026#34;: Lt(15), \u0026#34;zip\u0026#34;: 666}, \u0026#34;checks pointed typed map %v is included in expected keys/values\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// true  \nT.SubMapOf shortcut func (t *T) SubMapOf(got interface{}, model interface{}, expectedEntries MapEntries, args ...interface{}) bool SubMapOf is a shortcut for:\nt.Cmp(got, SubMapOf(model, expectedEntries), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also  T.SubMapOf godoc.\n Examples    Map example   t := NewT(\u0026amp;testing.T{}) got := map[string]int{\u0026#34;foo\u0026#34;: 12, \u0026#34;bar\u0026#34;: 42} ok := t.SubMapOf(got, map[string]int{\u0026#34;bar\u0026#34;: 42}, MapEntries{\u0026#34;foo\u0026#34;: Lt(15), \u0026#34;zip\u0026#34;: 666}, \u0026#34;checks map %v is included in expected keys/values\u0026#34;, got) fmt.Println(ok) // Output: \t// true     TypedMap example   t := NewT(\u0026amp;testing.T{}) type MyMap map[string]int got := MyMap{\u0026#34;foo\u0026#34;: 12, \u0026#34;bar\u0026#34;: 42} ok := t.SubMapOf(got, MyMap{\u0026#34;bar\u0026#34;: 42}, MapEntries{\u0026#34;foo\u0026#34;: Lt(15), \u0026#34;zip\u0026#34;: 666}, \u0026#34;checks typed map %v is included in expected keys/values\u0026#34;, got) fmt.Println(ok) ok = t.SubMapOf(\u0026amp;got, \u0026amp;MyMap{\u0026#34;bar\u0026#34;: 42}, MapEntries{\u0026#34;foo\u0026#34;: Lt(15), \u0026#34;zip\u0026#34;: 666}, \u0026#34;checks pointed typed map %v is included in expected keys/values\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// true  \n"
},
{
	"uri": "https://go-testdeep.zetta.rocks/operators/subsetof/",
	"title": "SubSetOf",
	"tags": [],
	"description": "",
	"content": " func SubSetOf(expectedItems ...interface{}) TestDeep SubSetOf operator compares the contents of an array or a slice (or a pointer on array/slice) ignoring duplicates and without taking care of the order of items.\nDuring a match, each array/slice item should be matched by an expected item to succeed. But some expected items can be missing from the compared array/slice.\nCmp(t, []int{1, 1}, SubSetOf(1, 2)) // succeeds Cmp(t, []int{1, 1, 2}, SubSetOf(1, 3)) // fails, 2 is an extra item  See also  SubSetOf godoc.\n Examples   Base example   t := \u0026amp;testing.T{} got := []int{1, 3, 5, 8, 8, 1, 2} // Matches as all items are expected, ignoring duplicates \tok := Cmp(t, got, SubSetOf(1, 2, 3, 4, 5, 6, 7, 8), \u0026#34;checks at least all items are present, in any order, ignoring duplicates\u0026#34;) fmt.Println(ok) // Tries its best to not raise an error when a value can be matched \t// by several SubSetOf entries \tok = Cmp(t, got, SubSetOf(Between(1, 4), 3, Between(2, 10), Gt(100)), \u0026#34;checks at least all items are present, in any order, ignoring duplicates\u0026#34;) fmt.Println(ok) // Output: \t// true \t// true   CmpSubSetOf shortcut func CmpSubSetOf(t TestingT, got interface{}, expectedItems []interface{}, args ...interface{}) bool CmpSubSetOf is a shortcut for:\nCmp(t, got, SubSetOf(expectedItems...), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also  CmpSubSetOf godoc.\n Examples   Base example   t := \u0026amp;testing.T{} got := []int{1, 3, 5, 8, 8, 1, 2} // Matches as all items are expected, ignoring duplicates \tok := CmpSubSetOf(t, got, []interface{}{1, 2, 3, 4, 5, 6, 7, 8}, \u0026#34;checks at least all items are present, in any order, ignoring duplicates\u0026#34;) fmt.Println(ok) // Tries its best to not raise an error when a value can be matched \t// by several SubSetOf entries \tok = CmpSubSetOf(t, got, []interface{}{Between(1, 4), 3, Between(2, 10), Gt(100)}, \u0026#34;checks at least all items are present, in any order, ignoring duplicates\u0026#34;) fmt.Println(ok) // Output: \t// true \t// true   T.SubSetOf shortcut func (t *T) SubSetOf(got interface{}, expectedItems []interface{}, args ...interface{}) bool SubSetOf is a shortcut for:\nt.Cmp(got, SubSetOf(expectedItems...), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also  T.SubSetOf godoc.\n Examples   Base example   t := NewT(\u0026amp;testing.T{}) got := []int{1, 3, 5, 8, 8, 1, 2} // Matches as all items are expected, ignoring duplicates \tok := t.SubSetOf(got, []interface{}{1, 2, 3, 4, 5, 6, 7, 8}, \u0026#34;checks at least all items are present, in any order, ignoring duplicates\u0026#34;) fmt.Println(ok) // Tries its best to not raise an error when a value can be matched \t// by several SubSetOf entries \tok = t.SubSetOf(got, []interface{}{Between(1, 4), 3, Between(2, 10), Gt(100)}, \u0026#34;checks at least all items are present, in any order, ignoring duplicates\u0026#34;) fmt.Println(ok) // Output: \t// true \t// true   "
},
{
	"uri": "https://go-testdeep.zetta.rocks/operators/superbagof/",
	"title": "SuperBagOf",
	"tags": [],
	"description": "",
	"content": " func SuperBagOf(expectedItems ...interface{}) TestDeep SuperBagOf operator compares the contents of an array or a slice (or a pointer on array/slice) without taking care of the order of items.\nDuring a match, each expected item should match in the compared array/slice. But some items in the compared array/slice may not be expected.\nCmp(t, []int{1, 1, 2}, SuperBagOf(1)) // succeeds Cmp(t, []int{1, 1, 2}, SuperBagOf(1, 1, 1)) // fails, one 1 is missing  See also  SuperBagOf godoc.\n Examples   Base example   t := \u0026amp;testing.T{} got := []int{1, 3, 5, 8, 8, 1, 2} ok := Cmp(t, got, SuperBagOf(8, 5, 8), \u0026#34;checks the items are present, in any order\u0026#34;) fmt.Println(ok) ok = Cmp(t, got, SuperBagOf(Gt(5), Lte(2)), \u0026#34;checks at least 2 items of %v match\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// true   CmpSuperBagOf shortcut func CmpSuperBagOf(t TestingT, got interface{}, expectedItems []interface{}, args ...interface{}) bool CmpSuperBagOf is a shortcut for:\nCmp(t, got, SuperBagOf(expectedItems...), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also  CmpSuperBagOf godoc.\n Examples   Base example   t := \u0026amp;testing.T{} got := []int{1, 3, 5, 8, 8, 1, 2} ok := CmpSuperBagOf(t, got, []interface{}{8, 5, 8}, \u0026#34;checks the items are present, in any order\u0026#34;) fmt.Println(ok) ok = CmpSuperBagOf(t, got, []interface{}{Gt(5), Lte(2)}, \u0026#34;checks at least 2 items of %v match\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// true   T.SuperBagOf shortcut func (t *T) SuperBagOf(got interface{}, expectedItems []interface{}, args ...interface{}) bool SuperBagOf is a shortcut for:\nt.Cmp(got, SuperBagOf(expectedItems...), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also  T.SuperBagOf godoc.\n Examples   Base example   t := NewT(\u0026amp;testing.T{}) got := []int{1, 3, 5, 8, 8, 1, 2} ok := t.SuperBagOf(got, []interface{}{8, 5, 8}, \u0026#34;checks the items are present, in any order\u0026#34;) fmt.Println(ok) ok = t.SuperBagOf(got, []interface{}{Gt(5), Lte(2)}, \u0026#34;checks at least 2 items of %v match\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// true   "
},
{
	"uri": "https://go-testdeep.zetta.rocks/operators/supermapof/",
	"title": "SuperMapOf",
	"tags": [],
	"description": "",
	"content": " func SuperMapOf(model interface{}, expectedEntries MapEntries) TestDeep SuperMapOf operator compares the contents of a map against the non-zero values of model (if any) and the values of expectedEntries.\nmodel must be the same type as compared data.\nexpectedEntries can be nil, if no zero entries are expected and no TestDeep operator are involved.\nDuring a match, each expected entry should match in the compared map. But some entries in the compared map may not be expected.\nCmp(t, map[string]int{\u0026#34;a\u0026#34;: 1, \u0026#34;b\u0026#34;: 2}, SuperMapOf(map[string]int{\u0026#34;a\u0026#34;: 1}, nil) // succeeds  Cmp(t, map[string]int{\u0026#34;a\u0026#34;: 1, \u0026#34;c\u0026#34;: 3}, SuperMapOf(map[string]int{\u0026#34;a\u0026#34;: 1, \u0026#34;b\u0026#34;: 2}, nil) // fails, missing {\u0026#34;b\u0026#34;: 2} TypeBehind method returns the reflect.Type of model.\n See also  SuperMapOf godoc.\n Examples    Map example   t := \u0026amp;testing.T{} got := map[string]int{\u0026#34;foo\u0026#34;: 12, \u0026#34;bar\u0026#34;: 42, \u0026#34;zip\u0026#34;: 89} ok := Cmp(t, got, SuperMapOf(map[string]int{\u0026#34;bar\u0026#34;: 42}, MapEntries{\u0026#34;foo\u0026#34;: Lt(15)}), \u0026#34;checks map %v contains at leat all expected keys/values\u0026#34;, got) fmt.Println(ok) // Output: \t// true     TypedMap example   t := \u0026amp;testing.T{} type MyMap map[string]int got := MyMap{\u0026#34;foo\u0026#34;: 12, \u0026#34;bar\u0026#34;: 42, \u0026#34;zip\u0026#34;: 89} ok := Cmp(t, got, SuperMapOf(MyMap{\u0026#34;bar\u0026#34;: 42}, MapEntries{\u0026#34;foo\u0026#34;: Lt(15)}), \u0026#34;checks typed map %v contains at leat all expected keys/values\u0026#34;, got) fmt.Println(ok) ok = Cmp(t, \u0026amp;got, SuperMapOf(\u0026amp;MyMap{\u0026#34;bar\u0026#34;: 42}, MapEntries{\u0026#34;foo\u0026#34;: Lt(15)}), \u0026#34;checks pointed typed map %v contains at leat all expected keys/values\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// true  \nCmpSuperMapOf shortcut func CmpSuperMapOf(t TestingT, got interface{}, model interface{}, expectedEntries MapEntries, args ...interface{}) bool CmpSuperMapOf is a shortcut for:\nCmp(t, got, SuperMapOf(model, expectedEntries), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also  CmpSuperMapOf godoc.\n Examples    Map example   t := \u0026amp;testing.T{} got := map[string]int{\u0026#34;foo\u0026#34;: 12, \u0026#34;bar\u0026#34;: 42, \u0026#34;zip\u0026#34;: 89} ok := CmpSuperMapOf(t, got, map[string]int{\u0026#34;bar\u0026#34;: 42}, MapEntries{\u0026#34;foo\u0026#34;: Lt(15)}, \u0026#34;checks map %v contains at leat all expected keys/values\u0026#34;, got) fmt.Println(ok) // Output: \t// true     TypedMap example   t := \u0026amp;testing.T{} type MyMap map[string]int got := MyMap{\u0026#34;foo\u0026#34;: 12, \u0026#34;bar\u0026#34;: 42, \u0026#34;zip\u0026#34;: 89} ok := CmpSuperMapOf(t, got, MyMap{\u0026#34;bar\u0026#34;: 42}, MapEntries{\u0026#34;foo\u0026#34;: Lt(15)}, \u0026#34;checks typed map %v contains at leat all expected keys/values\u0026#34;, got) fmt.Println(ok) ok = CmpSuperMapOf(t, \u0026amp;got, \u0026amp;MyMap{\u0026#34;bar\u0026#34;: 42}, MapEntries{\u0026#34;foo\u0026#34;: Lt(15)}, \u0026#34;checks pointed typed map %v contains at leat all expected keys/values\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// true  \nT.SuperMapOf shortcut func (t *T) SuperMapOf(got interface{}, model interface{}, expectedEntries MapEntries, args ...interface{}) bool SuperMapOf is a shortcut for:\nt.Cmp(got, SuperMapOf(model, expectedEntries), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also  T.SuperMapOf godoc.\n Examples    Map example   t := NewT(\u0026amp;testing.T{}) got := map[string]int{\u0026#34;foo\u0026#34;: 12, \u0026#34;bar\u0026#34;: 42, \u0026#34;zip\u0026#34;: 89} ok := t.SuperMapOf(got, map[string]int{\u0026#34;bar\u0026#34;: 42}, MapEntries{\u0026#34;foo\u0026#34;: Lt(15)}, \u0026#34;checks map %v contains at leat all expected keys/values\u0026#34;, got) fmt.Println(ok) // Output: \t// true     TypedMap example   t := NewT(\u0026amp;testing.T{}) type MyMap map[string]int got := MyMap{\u0026#34;foo\u0026#34;: 12, \u0026#34;bar\u0026#34;: 42, \u0026#34;zip\u0026#34;: 89} ok := t.SuperMapOf(got, MyMap{\u0026#34;bar\u0026#34;: 42}, MapEntries{\u0026#34;foo\u0026#34;: Lt(15)}, \u0026#34;checks typed map %v contains at leat all expected keys/values\u0026#34;, got) fmt.Println(ok) ok = t.SuperMapOf(\u0026amp;got, \u0026amp;MyMap{\u0026#34;bar\u0026#34;: 42}, MapEntries{\u0026#34;foo\u0026#34;: Lt(15)}, \u0026#34;checks pointed typed map %v contains at leat all expected keys/values\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// true  \n"
},
{
	"uri": "https://go-testdeep.zetta.rocks/operators/supersetof/",
	"title": "SuperSetOf",
	"tags": [],
	"description": "",
	"content": " func SuperSetOf(expectedItems ...interface{}) TestDeep SuperSetOf operator compares the contents of an array or a slice (or a pointer on array/slice) ignoring duplicates and without taking care of the order of items.\nDuring a match, each expected item should match in the compared array/slice. But some items in the compared array/slice may not be expected.\nCmp(t, []int{1, 1, 2}, SuperSetOf(1)) // succeeds Cmp(t, []int{1, 1, 2}, SuperSetOf(1, 3)) // fails, 3 is missing  See also  SuperSetOf godoc.\n Examples   Base example   t := \u0026amp;testing.T{} got := []int{1, 3, 5, 8, 8, 1, 2} ok := Cmp(t, got, SuperSetOf(1, 2, 3), \u0026#34;checks the items are present, in any order and ignoring duplicates\u0026#34;) fmt.Println(ok) ok = Cmp(t, got, SuperSetOf(Gt(5), Lte(2)), \u0026#34;checks at least 2 items of %v match ignoring duplicates\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// true   CmpSuperSetOf shortcut func CmpSuperSetOf(t TestingT, got interface{}, expectedItems []interface{}, args ...interface{}) bool CmpSuperSetOf is a shortcut for:\nCmp(t, got, SuperSetOf(expectedItems...), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also  CmpSuperSetOf godoc.\n Examples   Base example   t := \u0026amp;testing.T{} got := []int{1, 3, 5, 8, 8, 1, 2} ok := CmpSuperSetOf(t, got, []interface{}{1, 2, 3}, \u0026#34;checks the items are present, in any order and ignoring duplicates\u0026#34;) fmt.Println(ok) ok = CmpSuperSetOf(t, got, []interface{}{Gt(5), Lte(2)}, \u0026#34;checks at least 2 items of %v match ignoring duplicates\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// true   T.SuperSetOf shortcut func (t *T) SuperSetOf(got interface{}, expectedItems []interface{}, args ...interface{}) bool SuperSetOf is a shortcut for:\nt.Cmp(got, SuperSetOf(expectedItems...), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also  T.SuperSetOf godoc.\n Examples   Base example   t := NewT(\u0026amp;testing.T{}) got := []int{1, 3, 5, 8, 8, 1, 2} ok := t.SuperSetOf(got, []interface{}{1, 2, 3}, \u0026#34;checks the items are present, in any order and ignoring duplicates\u0026#34;) fmt.Println(ok) ok = t.SuperSetOf(got, []interface{}{Gt(5), Lte(2)}, \u0026#34;checks at least 2 items of %v match ignoring duplicates\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// true   "
},
{
	"uri": "https://go-testdeep.zetta.rocks/operators/tag/",
	"title": "Tag",
	"tags": [],
	"description": "",
	"content": " func Tag(tag string, expectedValue interface{}) TestDeep Tag is a smuggler operator. It only allows to name expectedValue, which can be an operator or a value. The data is then compared against expectedValue as if Tag was never called. It is only useful as JSON operator parameter, to name placeholders. See JSON operator for more details.\nCmp(t, gotValue, JSON(`{\u0026#34;fullname\u0026#34;: $name, \u0026#34;age\u0026#34;: $age, \u0026#34;gender\u0026#34;: $gender}`, Tag(\u0026#34;name\u0026#34;, HasPrefix(\u0026#34;Foo\u0026#34;)), // matches $name  Tag(\u0026#34;age\u0026#34;, Between(41, 43)), // matches $age  Tag(\u0026#34;gender\u0026#34;, \u0026#34;male\u0026#34;))) // matches $gender TypeBehind method is delegated to expectedValue one if expectedValue is a TestDeep operator, otherwise it returns the type of expectedValue (or nil if it is originally untyped nil).\n See also  Tag godoc.\n Examples "
},
{
	"uri": "https://go-testdeep.zetta.rocks/operators/trunctime/",
	"title": "TruncTime",
	"tags": [],
	"description": "",
	"content": " func TruncTime(expectedTime interface{}, trunc ...time.Duration) TestDeep TruncTime operator compares time.Time (or assignable) values after truncating them to the optional trunc duration. See time.Truncate for details about the truncation.\nIf trunc is missing, it defaults to 0.\nDuring comparison, location does not matter as time.Equal method is used behind the scenes: a time instant in two different locations is the same time instant.\nWhatever the trunc value is, the monotonic clock is stripped before the comparison against expectedTime.\nTypeBehind method returns the reflect.Type of expectedTime.\n See also  TruncTime godoc.\n Examples   Base example   t := \u0026amp;testing.T{} dateToTime := func(str string) time.Time { t, err := time.Parse(time.RFC3339Nano, str) if err != nil { panic(err) } return t } got := dateToTime(\u0026#34;2018-05-01T12:45:53.123456789Z\u0026#34;) // Compare dates ignoring nanoseconds and monotonic parts \texpected := dateToTime(\u0026#34;2018-05-01T12:45:53Z\u0026#34;) ok := Cmp(t, got, TruncTime(expected, time.Second), \u0026#34;checks date %v, truncated to the second\u0026#34;, got) fmt.Println(ok) // Compare dates ignoring time and so monotonic parts \texpected = dateToTime(\u0026#34;2018-05-01T11:22:33.444444444Z\u0026#34;) ok = Cmp(t, got, TruncTime(expected, 24*time.Hour), \u0026#34;checks date %v, truncated to the day\u0026#34;, got) fmt.Println(ok) // Compare dates exactly but ignoring monotonic part \texpected = dateToTime(\u0026#34;2018-05-01T12:45:53.123456789Z\u0026#34;) ok = Cmp(t, got, TruncTime(expected), \u0026#34;checks date %v ignoring monotonic part\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// true \t// true   CmpTruncTime shortcut func CmpTruncTime(t TestingT, got interface{}, expectedTime interface{}, trunc time.Duration, args ...interface{}) bool CmpTruncTime is a shortcut for:\nCmp(t, got, TruncTime(expectedTime, trunc), args...) See above for details.\nTruncTime() optional parameter trunc is here mandatory. 0 value should be passed to mimic its absence in original TruncTime() call.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also  CmpTruncTime godoc.\n Examples   Base example   t := \u0026amp;testing.T{} dateToTime := func(str string) time.Time { t, err := time.Parse(time.RFC3339Nano, str) if err != nil { panic(err) } return t } got := dateToTime(\u0026#34;2018-05-01T12:45:53.123456789Z\u0026#34;) // Compare dates ignoring nanoseconds and monotonic parts \texpected := dateToTime(\u0026#34;2018-05-01T12:45:53Z\u0026#34;) ok := CmpTruncTime(t, got, expected, time.Second, \u0026#34;checks date %v, truncated to the second\u0026#34;, got) fmt.Println(ok) // Compare dates ignoring time and so monotonic parts \texpected = dateToTime(\u0026#34;2018-05-01T11:22:33.444444444Z\u0026#34;) ok = CmpTruncTime(t, got, expected, 24*time.Hour, \u0026#34;checks date %v, truncated to the day\u0026#34;, got) fmt.Println(ok) // Compare dates exactly but ignoring monotonic part \texpected = dateToTime(\u0026#34;2018-05-01T12:45:53.123456789Z\u0026#34;) ok = CmpTruncTime(t, got, expected, 0, \u0026#34;checks date %v ignoring monotonic part\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// true \t// true   T.TruncTime shortcut func (t *T) TruncTime(got interface{}, expectedTime interface{}, trunc time.Duration, args ...interface{}) bool TruncTime is a shortcut for:\nt.Cmp(got, TruncTime(expectedTime, trunc), args...) See above for details.\nTruncTime() optional parameter trunc is here mandatory. 0 value should be passed to mimic its absence in original TruncTime() call.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also  T.TruncTime godoc.\n Examples   Base example   t := NewT(\u0026amp;testing.T{}) dateToTime := func(str string) time.Time { t, err := time.Parse(time.RFC3339Nano, str) if err != nil { panic(err) } return t } got := dateToTime(\u0026#34;2018-05-01T12:45:53.123456789Z\u0026#34;) // Compare dates ignoring nanoseconds and monotonic parts \texpected := dateToTime(\u0026#34;2018-05-01T12:45:53Z\u0026#34;) ok := t.TruncTime(got, expected, time.Second, \u0026#34;checks date %v, truncated to the second\u0026#34;, got) fmt.Println(ok) // Compare dates ignoring time and so monotonic parts \texpected = dateToTime(\u0026#34;2018-05-01T11:22:33.444444444Z\u0026#34;) ok = t.TruncTime(got, expected, 24*time.Hour, \u0026#34;checks date %v, truncated to the day\u0026#34;, got) fmt.Println(ok) // Compare dates exactly but ignoring monotonic part \texpected = dateToTime(\u0026#34;2018-05-01T12:45:53.123456789Z\u0026#34;) ok = t.TruncTime(got, expected, 0, \u0026#34;checks date %v ignoring monotonic part\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// true \t// true   "
},
{
	"uri": "https://go-testdeep.zetta.rocks/example/using-testing/",
	"title": "Using testing package",
	"tags": [],
	"description": "",
	"content": "To check the freshly created record contents using standard testing package, we have to do something like that:\nimport ( \u0026#34;testing\u0026#34; \u0026#34;time\u0026#34; ) func TestCreateRecord(t *testing.T) { before := time.Now().Truncate(time.Second) record, err := CreateRecord() if err != nil { t.Errorf(\u0026#34;An error occurred: %s\u0026#34;, err) } else { expected := Record{Name: \u0026#34;Bob\u0026#34;, Age: 23} if record.Id == 0 { t.Error(\u0026#34;Id probably not initialized\u0026#34;) } if record.Name != expected.Name { t.Errorf(\u0026#34;Name field differs, got=%s, expected=%s\u0026#34;, record.Name, expected.Name) } if record.Age != expected.Age { t.Errorf(\u0026#34;Age field differs, got=%s, expected=%s\u0026#34;, record.Age, expected.Age) } if before.After(record.CreatedAt) || time.Now().Before(record.CreatedAt) { t.Errorf(\u0026#34;CreatedAt field not expected: %s\u0026#34;, record.CreatedAt) } } }"
},
{
	"uri": "https://go-testdeep.zetta.rocks/operators/values/",
	"title": "Values",
	"tags": [],
	"description": "",
	"content": " func Values(val interface{}) TestDeep Values is a smuggler operator. It takes a map and compares its ordered values to val.\nval can be a slice of items of the same type as the map values:\nValues([]string{\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;}) as well as an other operator:\nValues(Bag(\u0026#34;c\u0026#34;, \u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;))  See also  Values godoc.\n Examples   Base example   t := \u0026amp;testing.T{} got := map[string]int{\u0026#34;foo\u0026#34;: 1, \u0026#34;bar\u0026#34;: 2, \u0026#34;zip\u0026#34;: 3} // Values tests values in an ordered manner \tok := Cmp(t, got, Values([]int{1, 2, 3})) fmt.Println(\u0026#34;All sorted values are found:\u0026#34;, ok) // If the expected values are not ordered, it fails \tok = Cmp(t, got, Values([]int{3, 1, 2})) fmt.Println(\u0026#34;All unsorted values are found:\u0026#34;, ok) // To circumvent that, one can use Bag operator \tok = Cmp(t, got, Values(Bag(3, 1, 2))) fmt.Println(\u0026#34;All unsorted values are found, with the help of Bag operator:\u0026#34;, ok) // Check that each value is between 1 and 3 \tok = Cmp(t, got, Values(ArrayEach(Between(1, 3)))) fmt.Println(\u0026#34;Each value is between 1 and 3:\u0026#34;, ok) // Output: \t// All sorted values are found: true \t// All unsorted values are found: false \t// All unsorted values are found, with the help of Bag operator: true \t// Each value is between 1 and 3: true   CmpValues shortcut func CmpValues(t TestingT, got interface{}, val interface{}, args ...interface{}) bool CmpValues is a shortcut for:\nCmp(t, got, Values(val), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also  CmpValues godoc.\n Examples   Base example   t := \u0026amp;testing.T{} got := map[string]int{\u0026#34;foo\u0026#34;: 1, \u0026#34;bar\u0026#34;: 2, \u0026#34;zip\u0026#34;: 3} // Values tests values in an ordered manner \tok := CmpValues(t, got, []int{1, 2, 3}) fmt.Println(\u0026#34;All sorted values are found:\u0026#34;, ok) // If the expected values are not ordered, it fails \tok = CmpValues(t, got, []int{3, 1, 2}) fmt.Println(\u0026#34;All unsorted values are found:\u0026#34;, ok) // To circumvent that, one can use Bag operator \tok = CmpValues(t, got, Bag(3, 1, 2)) fmt.Println(\u0026#34;All unsorted values are found, with the help of Bag operator:\u0026#34;, ok) // Check that each value is between 1 and 3 \tok = CmpValues(t, got, ArrayEach(Between(1, 3))) fmt.Println(\u0026#34;Each value is between 1 and 3:\u0026#34;, ok) // Output: \t// All sorted values are found: true \t// All unsorted values are found: false \t// All unsorted values are found, with the help of Bag operator: true \t// Each value is between 1 and 3: true   T.Values shortcut func (t *T) Values(got interface{}, val interface{}, args ...interface{}) bool Values is a shortcut for:\nt.Cmp(got, Values(val), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also  T.Values godoc.\n Examples   Base example   t := NewT(\u0026amp;testing.T{}) got := map[string]int{\u0026#34;foo\u0026#34;: 1, \u0026#34;bar\u0026#34;: 2, \u0026#34;zip\u0026#34;: 3} // Values tests values in an ordered manner \tok := t.Values(got, []int{1, 2, 3}) fmt.Println(\u0026#34;All sorted values are found:\u0026#34;, ok) // If the expected values are not ordered, it fails \tok = t.Values(got, []int{3, 1, 2}) fmt.Println(\u0026#34;All unsorted values are found:\u0026#34;, ok) // To circumvent that, one can use Bag operator \tok = t.Values(got, Bag(3, 1, 2)) fmt.Println(\u0026#34;All unsorted values are found, with the help of Bag operator:\u0026#34;, ok) // Check that each value is between 1 and 3 \tok = t.Values(got, ArrayEach(Between(1, 3))) fmt.Println(\u0026#34;Each value is between 1 and 3:\u0026#34;, ok) // Output: \t// All sorted values are found: true \t// All unsorted values are found: false \t// All unsorted values are found, with the help of Bag operator: true \t// Each value is between 1 and 3: true   "
},
{
	"uri": "https://go-testdeep.zetta.rocks/operators/zero/",
	"title": "Zero",
	"tags": [],
	"description": "",
	"content": " func Zero() TestDeep Zero operator checks that data is zero regarding its type.\n nil is the zero value of pointers, maps, slices, channels and functions; 0 is the zero value of numbers; \u0026rdquo;\u0026rdquo; is the 0 value of strings; false is the zero value of booleans; zero value of structs is the struct with no fields initialized.  Beware that:\nCmp(t, AnyStruct{}, Zero()) // is true Cmp(t, \u0026amp;AnyStruct{}, Zero()) // is false, coz pointer ≠ nil Cmp(t, \u0026amp;AnyStruct{}, Ptr(Zero())) // is true  See also  Zero godoc.\n Examples   Base example   t := \u0026amp;testing.T{} ok := Cmp(t, 0, Zero()) fmt.Println(ok) ok = Cmp(t, float64(0), Zero()) fmt.Println(ok) ok = Cmp(t, 12, Zero()) // fails, as 12 is not 0 :) \tfmt.Println(ok) ok = Cmp(t, (map[string]int)(nil), Zero()) fmt.Println(ok) ok = Cmp(t, map[string]int{}, Zero()) // fails, as not nil \tfmt.Println(ok) ok = Cmp(t, ([]int)(nil), Zero()) fmt.Println(ok) ok = Cmp(t, []int{}, Zero()) // fails, as not nil \tfmt.Println(ok) ok = Cmp(t, [3]int{}, Zero()) fmt.Println(ok) ok = Cmp(t, [3]int{0, 1}, Zero()) // fails, DATA[1] is not 0 \tfmt.Println(ok) ok = Cmp(t, bytes.Buffer{}, Zero()) fmt.Println(ok) ok = Cmp(t, \u0026amp;bytes.Buffer{}, Zero()) // fails, as pointer not nil \tfmt.Println(ok) ok = Cmp(t, \u0026amp;bytes.Buffer{}, Ptr(Zero())) // OK with the help of Ptr() \tfmt.Println(ok) // Output: \t// true \t// true \t// false \t// true \t// false \t// true \t// false \t// true \t// false \t// true \t// false \t// true   CmpZero shortcut func CmpZero(t TestingT, got interface{}, args ...interface{}) bool CmpZero is a shortcut for:\nCmp(t, got, Zero(), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also  CmpZero godoc.\n Examples   Base example   t := \u0026amp;testing.T{} ok := CmpZero(t, 0) fmt.Println(ok) ok = CmpZero(t, float64(0)) fmt.Println(ok) ok = CmpZero(t, 12) // fails, as 12 is not 0 :) \tfmt.Println(ok) ok = CmpZero(t, (map[string]int)(nil)) fmt.Println(ok) ok = CmpZero(t, map[string]int{}) // fails, as not nil \tfmt.Println(ok) ok = CmpZero(t, ([]int)(nil)) fmt.Println(ok) ok = CmpZero(t, []int{}) // fails, as not nil \tfmt.Println(ok) ok = CmpZero(t, [3]int{}) fmt.Println(ok) ok = CmpZero(t, [3]int{0, 1}) // fails, DATA[1] is not 0 \tfmt.Println(ok) ok = CmpZero(t, bytes.Buffer{}) fmt.Println(ok) ok = CmpZero(t, \u0026amp;bytes.Buffer{}) // fails, as pointer not nil \tfmt.Println(ok) ok = Cmp(t, \u0026amp;bytes.Buffer{}, Ptr(Zero())) // OK with the help of Ptr() \tfmt.Println(ok) // Output: \t// true \t// true \t// false \t// true \t// false \t// true \t// false \t// true \t// false \t// true \t// false \t// true   T.Zero shortcut func (t *T) Zero(got interface{}, args ...interface{}) bool Zero is a shortcut for:\nt.Cmp(got, Zero(), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also  T.Zero godoc.\n Examples   Base example   t := NewT(\u0026amp;testing.T{}) ok := t.Zero(0) fmt.Println(ok) ok = t.Zero(float64(0)) fmt.Println(ok) ok = t.Zero(12) // fails, as 12 is not 0 :) \tfmt.Println(ok) ok = t.Zero((map[string]int)(nil)) fmt.Println(ok) ok = t.Zero(map[string]int{}) // fails, as not nil \tfmt.Println(ok) ok = t.Zero(([]int)(nil)) fmt.Println(ok) ok = t.Zero([]int{}) // fails, as not nil \tfmt.Println(ok) ok = t.Zero([3]int{}) fmt.Println(ok) ok = t.Zero([3]int{0, 1}) // fails, DATA[1] is not 0 \tfmt.Println(ok) ok = t.Zero(bytes.Buffer{}) fmt.Println(ok) ok = t.Zero(\u0026amp;bytes.Buffer{}) // fails, as pointer not nil \tfmt.Println(ok) ok = t.Cmp(\u0026amp;bytes.Buffer{}, Ptr(Zero())) // OK with the help of Ptr() \tfmt.Println(ok) // Output: \t// true \t// true \t// false \t// true \t// false \t// true \t// false \t// true \t// false \t// true \t// false \t// true   "
},
{
	"uri": "https://go-testdeep.zetta.rocks/example/",
	"title": "Example",
	"tags": [],
	"description": "",
	"content": "Imagine a function returning a struct containing a newly created database record. The Id and the CreatedAt fields are set by the database layer:\ntype Record struct { Id uint64 Name string Age int CreatedAt time.Time } func CreateRecord(name string, age int) (*Record, error) { // Do INSERT INTO … and return newly created record or error if it failed }"
},
{
	"uri": "https://go-testdeep.zetta.rocks/functions/",
	"title": "Functions",
	"tags": [],
	"description": "",
	"content": " import ( \u0026#34;testing\u0026#34; \u0026#34;github.com/maxatome/go-testdeep\u0026#34; ) func TestMyFunc(t *testing.T) { // Compares MyFunc() result against a fixed value  testdeep.Cmp(t, MyFunc(), 128, \u0026#34;MyFunc() result is 128\u0026#34;) // Compares MyFunc() result using the Between Testdeep operator  testdeep.Cmp(t, MyFunc(), testdeep.Between(100, 199), \u0026#34;MyFunc() result is between 100 and 199\u0026#34;) }  func Cmp(t TestingT, got, expected interface{}, args ...interface{}) bool func CmpError(t TestingT, got error, args ...interface{}) bool func CmpFalse(t TestingT, got interface{}, args ...interface{}) bool func CmpLax(t TestingT, got interface{}, expected interface{}, args ...interface{}) bool (in fact the shortcut of Lax operator) func CmpNoError(t TestingT, got error, args ...interface{}) bool func CmpNot(t TestingT, got interface{}, notExpected interface{}, args ...interface{}) bool (in fact the shortcut of Not operator) func CmpNotPanic(t TestingT, fn func(), args ...interface{}) bool func CmpPanic(t TestingT, fn func(), expectedPanic interface{}, args ...interface{}) bool func CmpTrue(t TestingT, got interface{}, args ...interface{}) bool func EqDeeply(got, expected interface{}) bool func EqDeeplyError(got, expected interface{}) error  CmpDeeply() is now replaced by Cmp(), but it is still available for backward compatibility purpose.\nMain shortcut functions import ( \u0026#34;testing\u0026#34; \u0026#34;github.com/maxatome/go-testdeep\u0026#34; ) func TestMyFunc(t *testing.T) { testdeep.CmpBetween(t, MyFunc(), 100, 199, testdeep.BoundsInIn, \u0026#34;MyFunc() result is between 100 and 199\u0026#34;) } For each of these functions, it is always a shortcut on Cmp() and the correponding Testdeep operator:\nCmpHasPrefix(t, got, expected, …) ⇒ Cmp(t, got, HasPrefix(expected), …) ^-------^ ^-------^ +--------------------------------------------+  Each shortcut method is described in the corresponding operator page. See operators list.\n"
},
{
	"uri": "https://go-testdeep.zetta.rocks/operators/",
	"title": "Operators",
	"tags": [],
	"description": "",
	"content": " All operators  All all expected values have to match Any at least one expected value have to match ArrayEach compares each array or slice item Array compares the contents of an array or a pointer on an array Bag compares the contents of an array or a slice without taking care of the order of items Between checks that a number, string or time.Time is between two bounds Cap checks an array, slice or channel capacity Catch catches data on the fly before comparing it Code checks using a custom function ContainsKey checks that a map contains a key Contains checks that a string, error or fmt.Stringer interfaces contain a sub-string; or an array, slice or map contain a value Empty checks that an array, a channel, a map, a slice or a string is empty Gt checks that a number, string or time.Time is greater than a value Gte checks that a number, string or time.Time is greater or equal than a value HasPrefix checks the prefix of a string, error or fmt.Stringer interfaces HasSuffix checks the suffix of a string, error or fmt.Stringer interfaces Ignore allows to ignore a comparison Isa checks the data type or whether data implements an interface or not JSON compares against JSON representation Keys checks keys of a map Lax temporarily enables BeLax config flag Len checks an array, slice, map, string or channel length Lt checks that a number, string or time.Time is lesser than a value Lte checks that a number, string or time.Time is lesser or equal than a value MapEach compares each map entry Map compares the contents of a map N compares a number with a tolerance value NaN checks a floating number is math.NaN Nil compares to nil None no values have to match NotAny compares the contents of an array or a slice, no values have to match NotEmpty checks that an array, a channel, a map, a slice or a string is not empty NotNaN checks a floating number is not math.NaN NotNil checks that data is not nil NotZero checks that data is not zero regarding its type Not value must not match PPtr allows to easily test a pointer of pointer value Ptr allows to easily test a pointer value ReAll allows to successively apply a regexp on a string (or convertible), []byte, error or fmt.Stringer interfaces, and even test the captured groups Re allows to apply a regexp on a string (or convertible), []byte, error or fmt.Stringer interfaces, and even test the captured groups Set compares the contents of an array or a slice ignoring duplicates and without taking care of the order of items Shallow compares pointers only, not their contents Slice compares the contents of a slice or a pointer on a slice Smuggle changes data contents or mutates it into another type via a custom function or a struct fields-path before stepping down in favor of generic comparison process String checks a string, error or fmt.Stringer interfaces string contents Struct compares the contents of a struct or a pointer on a struct SubBagOf compares the contents of an array or a slice without taking care of the order of items but with potentially some exclusions SubMapOf compares the contents of a map but with potentially some exclusions SubSetOf compares the contents of an array or a slice ignoring duplicates and without taking care of the order of items but with potentially some exclusions SuperBagOf compares the contents of an array or a slice without taking care of the order of items but with potentially some extra items SuperMapOf compares the contents of a map but with potentially some extra entries SuperSetOf compares the contents of an array or a slice ignoring duplicates and without taking care of the order of items but with potentially some extra items Tag names an operator or a value. Only useful as a parameter of JSON operator, to name placeholders TruncTime compares time.Time values after truncating them Values checks values of a map Zero checks data against its zero\u0026rsquo;ed conterpart  Smuggler operators A smuggler operator is an operator able to transform the value (by changing its value or even its type) before comparing it.\nThe following operators are smuggler ones:\n Cap checks an array, slice or channel capacity Catch catches data on the fly before comparing it ContainsKey checks that a map contains a key Contains checks that a string, error or fmt.Stringer interfaces contain a sub-string; or an array, slice or map contain a value Keys checks keys of a map Lax temporarily enables BeLax config flag Len checks an array, slice, map, string or channel length PPtr allows to easily test a pointer of pointer value Ptr allows to easily test a pointer value Smuggle changes data contents or mutates it into another type via a custom function or a struct fields-path before stepping down in favor of generic comparison process Tag names an operator or a value. Only useful as a parameter of JSON operator, to name placeholders Values checks values of a map  TypeBehind method TypeBehind() reflect.Type This method returns the type handled by the operator or nil if it is not known. tdhttp helper uses it to know how to unmarshal HTTP responses bodies before comparing them using the operator.\nIt is usually not used outside the go-testdeep repository.\n"
},
{
	"uri": "https://go-testdeep.zetta.rocks/example/basic-testdeep/",
	"title": "Basic testdeep approach",
	"tags": [],
	"description": "",
	"content": "testdeep package, via its Cmp* functions, handles the tests and all the error message boiler plate. Let\u0026rsquo;s do it:\nimport ( \u0026#34;testing\u0026#34; \u0026#34;time\u0026#34; td \u0026#34;github.com/maxatome/go-testdeep\u0026#34; ) func TestCreateRecord(t *testing.T) { before := time.Now().Truncate(time.Second) record, err := CreateRecord() if td.CmpNoError(t, err) { td.Cmp(t, record.Id, td.NotZero(), \u0026#34;Id initialized\u0026#34;) td.Cmp(t, record.Name, \u0026#34;Bob\u0026#34;) td.Cmp(t, record.Age, 23) td.Cmp(t, record.CreatedAt, td.Between(before, time.Now())) } } As we cannot guess the Id field value before its creation, we use the NotZero operator to check it is set by CreateRecord() call. The same is true for the creation date field CreatedAt. Thanks to the Between operator we can check it is set with a value included between the date before CreateRecord() call and the date just after.\nNote that if Id and CreateAt could be known in advance, we could simply do:\nimport ( \u0026#34;testing\u0026#34; \u0026#34;time\u0026#34; td \u0026#34;github.com/maxatome/go-testdeep\u0026#34; ) func TestCreateRecord(t *testing.T) { before := time.Now().Truncate(time.Second) record, err := CreateRecord() if td.CmpNoError(t, err) { td.Cmp(t, record, \u0026amp;Record{ Id: 1234, Name: \u0026#34;Bob\u0026#34;, Age: 23, CreatedAt: time.Date(2019, time.May, 1, 12, 13, 14, 0, time.UTC), }) } } But unfortunately, it is common to not know exactly the value of some fields…\n"
},
{
	"uri": "https://go-testdeep.zetta.rocks/faq/",
	"title": "FAQ",
	"tags": [],
	"description": "",
	"content": " How to mix strict requirements and simple assertions? import ( \u0026#34;testing\u0026#34; td \u0026#34;github.com/maxatome/go-testdeep\u0026#34; ) func TestAssertionsAndRequirements(t *testing.T) { assert := td.NewT(t) require := assert.FailureIsFatal() got := SomeFunction() require.Cmp(got, expected) // if it fails: report error + abort  assert.Cmp(got, expected) // if it fails: report error + continue } How to test io.Reader contents, like http.Response.Body for example? The Smuggle operator is done for that, here with the help of ReadAll.\nimport ( \u0026#34;net/http\u0026#34; \u0026#34;testing\u0026#34; \u0026#34;io/ioutil\u0026#34; td \u0026#34;github.com/maxatome/go-testdeep\u0026#34; ) func TestResponseBody(t *testing.T) { // Expect this response sends \u0026#34;Expected Response!\u0026#34;  var resp *http.Response = GetResponse() td.Cmp(t, resp.Body, td.Smuggle(ioutil.ReadAll, []byte(\u0026#34;Expected Response!\u0026#34;))) } OK, but I prefer comparing strings instead of bytes No problem, ReadAll the body by yourself and cast returned []byte contents to string, still using Smuggle operator:\nimport ( \u0026#34;io\u0026#34; \u0026#34;io/ioutil\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;testing\u0026#34; td \u0026#34;github.com/maxatome/go-testdeep\u0026#34; ) func TestResponseBody(t *testing.T) { // Expect this response sends \u0026#34;Expected Response!\u0026#34;  var resp *http.Response = GetResponse() td.Cmp(t, body, td.Smuggle( func(body io.Reader) (string, error) { b, err := ioutil.ReadAll(body) return string(b), err }, \u0026#34;Expected Response!\u0026#34;)) } OK, but my response is in fact a JSON marshaled struct of my own No problem, JSON unmarshal it just after reading the body:\nimport ( \u0026#34;encoding/json\u0026#34; \u0026#34;io\u0026#34; \u0026#34;io/ioutil\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;testing\u0026#34; td \u0026#34;github.com/maxatome/go-testdeep\u0026#34; ) func TestResponseBody(t *testing.T) { // Expect this response sends `{\u0026#34;ID\u0026#34;:42,\u0026#34;Name\u0026#34;:\u0026#34;Bob\u0026#34;,\u0026#34;Age\u0026#34;:28}`  var resp *http.Response = GetResponse() type Person struct { ID uint64 Name string Age int } td.Cmp(t, body, td.Smuggle( func(body io.Reader) (\u0026amp;Person, error) { b, err := ioutil.ReadAll(body) if err != nil { return nil, err } var s Person return \u0026amp;s, json.Unmarshal(b, \u0026amp;s) }, \u0026amp;Person{ ID: 42, Name: \u0026#34;Bob\u0026#34;, Age: 28, })) } OK, but you are funny, this response sends a new created object, so I don\u0026rsquo;t know the ID in advance! No problem, use Struct operator to test that ID field is non-zero:\nimport ( \u0026#34;encoding/json\u0026#34; \u0026#34;io\u0026#34; \u0026#34;io/ioutil\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;testing\u0026#34; td \u0026#34;github.com/maxatome/go-testdeep\u0026#34; ) func TestResponseBody(t *testing.T) { // Expect this response sends `{\u0026#34;ID\u0026#34;:42,\u0026#34;Name\u0026#34;:\u0026#34;Bob\u0026#34;,\u0026#34;Age\u0026#34;:28}`  var resp *http.Response = GetResponse() type Person struct { ID uint64 Name string Age int } td.Cmp(t, body, td.Smuggle( func(body io.Reader) (*Person, error) { b, err := ioutil.ReadAll(body) if err != nil { return nil, err } var s Person return \u0026amp;s, json.Unmarshal(b, \u0026amp;s) }, td.Struct(\u0026amp;Person{ Name: \u0026#34;Bob\u0026#34;, Age: 28, }, td.StructFields{ \u0026#34;ID\u0026#34;: td.NotZero(), }))) } What about testing the response using my API? tdhttp helper is done for that!\nimport ( \u0026#34;encoding/json\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;testing\u0026#34; td \u0026#34;github.com/maxatome/go-testdeep\u0026#34; \u0026#34;github.com/maxatome/go-testdeep/helpers/tdhttp\u0026#34; ) type Person struct { ID uint64 Name string Age int } // MyApi defines our API. func MyAPI() *http.ServeMux { mux := http.NewServeMux() // GET /json  mux.HandleFunc(\u0026#34;/json\u0026#34;, func(w http.ResponseWriter, req *http.Request) { if req.Method != \u0026#34;GET\u0026#34; { http.NotFound(w, req) return } b, err := json.Marshal(Person{ ID: 42, Name: \u0026#34;Bob\u0026#34;, Age: 28, }) if err != nil { http.Error(w, \u0026#34;Internal server error\u0026#34;, http.StatusInternalServerError) return } w.Header().Set(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/json\u0026#34;) w.WriteHeader(http.StatusOK) w.Write(b) }) return mux } func TestMyApi(t *testing.T) { myAPI := MyAPI() tdhttp.CmpJSONResponse(t, tdhttp.NewRequest(\u0026#34;GET\u0026#34;, \u0026#34;/json\u0026#34;, nil), myAPI.ServeHTTP, tdhttp.Response{ Status: http.StatusOK, // Header can be tested too… See tdhttp doc.  Body: td.Struct(\u0026amp;Person{ Name: \u0026#34;Bob\u0026#34;, Age: 28, }, td.StructFields{ \u0026#34;ID\u0026#34;: td.NotZero(), }), }, \u0026#34;Testing GET /json\u0026#34;) } Arf, I use Gin Gonic, and so no net/http handlers It is exactly the same as for net/http handlers as *gin.Engine implements http.Handler interface! So keep using tdhttp helper:\nimport ( \u0026#34;net/http\u0026#34; \u0026#34;testing\u0026#34; \u0026#34;github.com/gin-gonic/gin\u0026#34; td \u0026#34;github.com/maxatome/go-testdeep\u0026#34; \u0026#34;github.com/maxatome/go-testdeep/helpers/tdhttp\u0026#34; ) type Person struct { ID uint64 Name string Age int } // MyGinGonicApi defines our API. func MyGinGonicAPI() *gin.Engine { router := gin.Default() // or gin.New() or receive the router by param it doesn\u0026#39;t matter  router.GET(\u0026#34;/json\u0026#34;, func(c *gin.Context) { c.JSON(http.StatusOK, Person{ ID: 42, Name: \u0026#34;Bob\u0026#34;, Age: 28, }) }) return router } func TestMyGinGonicApi(t *testing.T) { myAPI := MyGinGonicAPI() tdhttp.CmpJSONResponse(t, tdhttp.NewRequest(\u0026#34;GET\u0026#34;, \u0026#34;/json\u0026#34;, nil), myAPI.ServeHTTP, tdhttp.Response{ Status: http.StatusOK, // Header can be tested too… See tdhttp doc.  Body: td.Struct(\u0026amp;Person{ Name: \u0026#34;Bob\u0026#34;, Age: 28, }, td.StructFields{ \u0026#34;ID\u0026#34;: td.NotZero(), }), }, \u0026#34;Testing GET /json\u0026#34;) } go-testdeep dumps only 10 errors, how to have more (or less)? Using the environment variable TESTDEEP_MAX_ERRORS.\nTESTDEEP_MAX_ERRORS contains the maximum number of errors to report before stopping during one comparison (one Cmp execution for example). It defaults to 10.\nExample:\nTESTDEEP_MAX_ERRORS=30 go test Setting it to -1 means no limit:\nTESTDEEP_MAX_ERRORS=-1 go test How do I change these crappy colors? Using some environment variables:\n TESTDEEP_COLOR enable (on) or disable (off) the color output. It defaults to on; TESTDEEP_COLOR_TEST_NAME color of the test name. See below for color format, it defaults to yellow; TESTDEEP_COLOR_TITLE color of the test failure title. See below for color format, it defaults to cyan; TESTDEEP_COLOR_OK color of the test expected value. See below for color format, it defaults to green; TESTDEEP_COLOR_BAD color of the test got value. See below for color format, it defaults to red;  Color format A color in TESTDEEP_COLOR_* environment variables has the following format:\nforeground_color # set foreground color, background one untouched foreground_color:background_color # set foreground AND background color :background_color # set background color, foreground one untouched  foreground_color and background_color can be:\n black red green yellow blue magenta cyan white gray  For example:\nTESTDEEP_COLOR_OK=black:green \\  TESTDEEP_COLOR_BAD=white:red \\  TESTDEEP_COLOR_TITLE=yellow \\  go test How to add a new operator? You want to add a new FooBar operator.\ncheck that another operator does not exist with the same meaning; add the operator definition in td_foo_bar.go file and fully document its usage:  add a // summary(FooBar): small description line, before operator comment, add a // input(FooBar): … line, just after summary(FooBar) line. This one lists all inputs accepted by the operator;  add operator tests in td_foo_bar_test.go file; in example_test.go file, add examples function(s) ExampleFooBar* in alphabetical order; automatically generate CmpFooBar \u0026amp; T.FooBar (+ examples) code: ./tools/gen_funcs.pl . do not forget to run tests: go test ./... run golangci-lint as in .travis.yml;  Each time you change example_test.go, re-run ./tools/gen_funcs.pl . to update corresponding CmpFooBar \u0026amp; T.FooBar examples.\nTest coverage must be 100%.\n"
},
{
	"uri": "https://go-testdeep.zetta.rocks/example/advanced-testdeep/",
	"title": "Advanced testdeep technique",
	"tags": [],
	"description": "",
	"content": "Of course we can test struct fields one by one, but with testdeep, the whole struct can be compared with one Cmp call.\nWe can choose to ignore the non-guessable fields set by CreateRecord():\nimport ( \u0026#34;testing\u0026#34; \u0026#34;time\u0026#34; td \u0026#34;github.com/maxatome/go-testdeep\u0026#34; ) func TestCreateRecord(t *testing.T) { before := time.Now().Truncate(time.Second) record, err := CreateRecord() if td.CmpNoError(t, err) { td.Cmp(t, record, td.Struct( \u0026amp;Record{ Name: \u0026#34;Bob\u0026#34;, Age: 23, }, nil), \u0026#34;Newly created record\u0026#34;) } } The Struct operator, used here, ignores zero fields in its model parameter.\nBut it is better to check all fields:\nimport ( \u0026#34;testing\u0026#34; \u0026#34;time\u0026#34; td \u0026#34;github.com/maxatome/go-testdeep\u0026#34; ) func TestCreateRecord(t *testing.T) { before := time.Now().Truncate(time.Second) record, err := CreateRecord() if td.CmpNoError(t, err) { td.Cmp(t, record, td.Struct( \u0026amp;Record{ Name: \u0026#34;Bob\u0026#34;, Age: 23, }, td.StructFields{ \u0026#34;Id\u0026#34;: td.NotZero(), \u0026#34;CreatedAt\u0026#34;: td.Between(before, time.Now()), }), \u0026#34;Newly created record\u0026#34;) } } See the use of the Struct operator. It is needed here to overcome the go static typing system and so use other testdeep operators for some fields, here NotZero for Id and Between for CreatedAt.\nNot only structs can be compared. A lot of operators can be found to cover most (all?) needed tests. See the operators list.\nSay CreateRecord() does not set correctly CreatedAt field, then:\ngo test -run=TestCreateRecord outputs for last td.Cmp call:\nIf CreateRecord() had not set correctly Id field, output would have been:\nIf CreateRecord() had set Name field to \u0026ldquo;Alice\u0026rdquo; value instead of expected \u0026ldquo;Bob\u0026rdquo;, output would have been:\n"
},
{
	"uri": "https://go-testdeep.zetta.rocks/example/testdeep-cmp-shortcuts/",
	"title": "testdeep Cmp shortcuts",
	"tags": [],
	"description": "",
	"content": "The Cmp function is the keystone of this package, but to make the writing of tests even easier, the family of Cmp* functions are provided and act as shortcuts. Using CmpStruct function, the previous example can be written as:\nimport ( \u0026#34;testing\u0026#34; \u0026#34;time\u0026#34; td \u0026#34;github.com/maxatome/go-testdeep\u0026#34; ) func TestCreateRecord(t *testing.T) { before := time.Now().Truncate(time.Second) record, err := CreateRecord() if td.CmpNoError(t, err) { td.CmpStruct(t, record, \u0026amp;Record{ Name: \u0026#34;Bob\u0026#34;, Age: 23, }, td.StructFields{ \u0026#34;Id\u0026#34;: td.NotZero(), \u0026#34;CreatedAt\u0026#34;: td.Between(before, time.Now()), }, \u0026#34;Newly created record\u0026#34;) } }"
},
{
	"uri": "https://go-testdeep.zetta.rocks/example/testdeep-t/",
	"title": "testdeep.T type",
	"tags": [],
	"description": "",
	"content": "Last, testing.T can be encapsulated in testdeep T type, simplifying again the test:\nimport ( \u0026#34;testing\u0026#34; \u0026#34;time\u0026#34; td \u0026#34;github.com/maxatome/go-testdeep\u0026#34; ) func TestCreateRecord(tt *testing.T) { t := td.NewT(tt) before := time.Now().Truncate(time.Second) record, err := CreateRecord() if t.CmpNoError(err) { t := t.RootName(\u0026#34;RECORD\u0026#34;) // Use RECORD instead of DATA in failure reports  // Using Struct shortcut method  t.Struct(record, \u0026amp;Record{ Name: \u0026#34;Bob\u0026#34;, Age: 23, }, td.StructFields{ \u0026#34;Id\u0026#34;: td.NotZero(), \u0026#34;CreatedAt\u0026#34;: td.Between(before, time.Now()), }, \u0026#34;Newly created record\u0026#34;) // Or using Cmp method, it\u0026#39;s a matter of taste  t.Cmp(record, td.Struct( Record{ Name: \u0026#34;Bob\u0026#34;, Age: 23, }, td.StructFields{ \u0026#34;Id\u0026#34;: td.NotZero(), \u0026#34;CreatedAt\u0026#34;: td.Between(before, time.Now()), }), \u0026#34;Newly created record\u0026#34;) } } Note the use of RootName method, it allows to name what we are going to test, instead of the default \u0026ldquo;DATA\u0026rdquo;.\nIf CreateRecord() had set Name field to \u0026ldquo;Alice\u0026rdquo; value instead of expected \u0026ldquo;Bob\u0026rdquo;, output would have been (note \u0026ldquo;RECORD\u0026rdquo; replaced default \u0026ldquo;DATA\u0026rdquo;):\n"
},
{
	"uri": "https://go-testdeep.zetta.rocks/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://go-testdeep.zetta.rocks/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://go-testdeep.zetta.rocks/functions/testdeep-t/",
	"title": "testdeep.T",
	"tags": [],
	"description": "",
	"content": " Constructing *testdeep.T import ( \u0026#34;testing\u0026#34; \u0026#34;github.com/maxatome/go-testdeep\u0026#34; ) func TestMyFunc(tt *testing.T) { t := testdeep.NewT(tt) t.Cmp(MyFunc(), 12) }  func NewT(t TestingFT, config ...ContextConfig) *T  Configuring *testdeep.T func TestMyFunc(tt *testing.T) { t := testdeep.NewT(tt).UseEqual().RootName(\u0026#34;RECORD\u0026#34;) ... }  func (t *T) BeLax(enable ...bool) *T func (t *T) FailureIsFatal(enable ...bool) *T func (t *T) RootName(rootName string) *T func (t *T) UseEqual(enable ...bool) *T  Main methods of *testdeep.T import ( \u0026#34;testing\u0026#34; \u0026#34;github.com/maxatome/go-testdeep\u0026#34; ) func TestMyFunc(tt *testing.T) { t := testdeep.NewT(tt).UseEqual() // Compares MyFunc() result against a fixed value  t.Cmp(MyFunc(), 128, \u0026#34;MyFunc() result is 128\u0026#34;) // Compares MyFunc() result using the Between Testdeep operator  t.Cmp(MyFunc(), testdeep.Between(100, 199), \u0026#34;MyFunc() result is between 100 and 199\u0026#34;) }  func (t *T) Cmp(got, expected interface{}, args ...interface{}) bool func (t *T) CmpError(got error, args ...interface{}) bool func (t *T) CmpLax(got interface{}, expected interface{}, args ...interface{}) bool (in fact the shortcut of Lax operator) func (t *T) CmpNoError(got error, args ...interface{}) bool func (t *T) CmpNotPanic(fn func(), args ...interface{}) bool func (t *T) CmpPanic(fn func(), expected interface{}, args ...interface{}) bool func (t *T) False(got interface{}, args ...interface{}) bool func (t *T) Not(got interface{}, notExpected interface{}, args ...interface{}) bool (in fact the shortcut of Not operator) func (t *T) RunT(name string, f func(t *T)) bool func (t *T) True(got interface{}, args ...interface{}) bool  CmpDeeply() method is now replaced by Cmp(), but it is still available for backward compatibility purpose.\nShortcut methods of *testdeep.T import ( \u0026#34;testing\u0026#34; \u0026#34;github.com/maxatome/go-testdeep\u0026#34; ) func TestMyFunc(tt *testing.T) { t := testdeep.NewT(tt).UseEqual() t.Between(MyFunc(), 100, 199, testdeep.BoundsInIn, \u0026#34;MyFunc() result is between 100 and 199\u0026#34;) } For each of these methods, it is always a shortcut on T.Cmp() and the correponding Testdeep operator:\nT.HasPrefix(got, expected, …) ⇒ T.Cmp(t, got, HasPrefix(expected), …) ^-------^ ^-------^ +-------------------------------------------+  Excluding Lax operator for which the shortcut method stays CmpLax.\nEach shortcut method is described in the corresponding operator page. See operators list.\n"
}]